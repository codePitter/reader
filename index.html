<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lector EPUB con TTS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0f0e0c;
            --surface: #1a1814;
            --surface2: #242018;
            --border: #2e2a22;
            --accent: #c8a96e;
            --accent2: #7eb89a;
            --text: #e8e0d0;
            --text-muted: #8a8070;
            --text-dim: #5a5248;
            --sidebar-w: 300px;
        }

        body {
            font-family: 'DM Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
            padding-bottom: max(0.5vh, 14px);
            box-sizing: border-box;
        }

        /* ─── MAIN CONTENT (LEFT 80%) ─── */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        .top-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

            .top-bar h1 {
                font-family: 'Lora', serif;
                font-size: 1.15rem;
                font-weight: 600;
                color: var(--accent);
                letter-spacing: 0.02em;
            }

            .top-bar .subtitle {
                font-size: 0.7rem;
                color: var(--text-muted);
                margin-left: auto;
            }

        .stats-bar {
            display: flex;
            gap: 24px;
            padding: 8px 28px;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .stat {
            font-size: 0.65rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 5px;
        }

            .stat strong {
                color: var(--accent);
                font-weight: 500;
            }

        /* Reading area */
        .reading-area {
            flex: 1;
            overflow-y: auto;
            padding: 48px 80px;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .reading-area::-webkit-scrollbar {
                width: 4px;
            }

            .reading-area::-webkit-scrollbar-track {
                background: transparent;
            }

            .reading-area::-webkit-scrollbar-thumb {
                background: var(--border);
                border-radius: 2px;
            }

        #texto-contenido {
            font-family: 'Lora', serif;
            font-size: 1.1rem;
            line-height: 1.85;
            color: var(--text);
            max-width: 680px;
            margin: 0 auto;
            white-space: pre-wrap;
        }

            #texto-contenido p {
                margin-bottom: 1.2em;
            }

        /* Progress bar at bottom of reading area */
        .progress-wrap {
            flex-shrink: 0;
            padding: 0 28px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            transition: opacity 0.4s ease, max-height 0.4s ease;
            overflow: visible;
            max-height: 40px;
        }

            .progress-wrap.processing-hidden {
                opacity: 0;
                max-height: 0;
                pointer-events: none;
            }

        .progress-track {
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            margin: 8px 0;
            overflow: visible;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Tooltip de preview en barra de progreso principal */
        #main-progress-tooltip {
            position: absolute;
            bottom: calc(100% + 10px);
            transform: translateX(-50%);
            background: rgba(18, 16, 14, 0.96);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 7px 12px;
            font-size: 0.65rem;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            max-width: 240px;
            white-space: pre-wrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 200;
            text-align: center;
            line-height: 1.45;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
        }

            #main-progress-tooltip.visible {
                opacity: 1;
            }

        /* Footer fijo */
        .app-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0.5vh;
            min-height: 14px;
            background: var(--surface2);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            font-family: 'DM Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-dim);
            z-index: 50;
            padding: 0 20px;
            white-space: nowrap;
            overflow: hidden;
        }

            .app-footer a {
                color: var(--accent);
                text-decoration: none;
                transition: color 0.2s;
            }

                .app-footer a:hover {
                    color: var(--text);
                }

            .app-footer .footer-sep {
                opacity: 0.3;
            }

        .tts-status-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        /*.tts-percent-badge {
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 0.6rem;
            color: var(--accent);
            font-weight: 500;
        }*/

        /* Editor panel (collapsible) */
        .editor-panel {
            flex-shrink: 0;
            background: var(--surface2);
            border-top: 1px solid var(--border);
            transition: max-height 0.3s ease;
            max-height: 0;
            overflow: hidden;
        }

            .editor-panel.open {
                max-height: 260px;
            }

        .editor-inner {
            padding: 16px 28px;
        }

        #editor-texto {
            width: 100%;
            height: 130px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.78rem;
            padding: 12px;
            resize: vertical;
            outline: none;
            margin-bottom: 10px;
        }

            #editor-texto:focus {
                border-color: var(--accent);
            }

        .editor-actions {
            display: flex;
            gap: 8px;
        }

        /* ─── SIDEBAR (RIGHT) ─── */
        .sidebar {
            width: var(--sidebar-w);
            flex-shrink: 0;
            background: var(--surface);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .sidebar::-webkit-scrollbar {
                width: 3px;
            }

            .sidebar::-webkit-scrollbar-thumb {
                background: var(--border);
            }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

            .sidebar-section:last-child {
                border-bottom: none;
            }

        .section-label {
            font-size: 0.6rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .section-label::after {
                content: '';
                flex: 1;
                height: 1px;
                background: var(--border);
            }

        /* File upload */
        .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 10px;
            background: var(--accent);
            color: var(--bg);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.72rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            transition: opacity 0.2s;
        }

            .file-label:hover {
                opacity: 0.85;
            }

        input[type="file"] {
            display: none;
        }

        #file-name {
            display: block;
            font-size: 0.62rem;
            color: var(--text-dim);
            margin-top: 6px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Chapter select */
        #chapters {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 4px;
            height: 110px;
            outline: none;
        }

            #chapters:focus {
                border-color: var(--accent);
            }

            #chapters option {
                padding: 4px 6px;
            }

                #chapters option:checked {
                    background: var(--accent);
                    color: var(--bg);
                }

        /* Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

            .toggle-row span {
                font-size: 0.68rem;
                color: var(--text-muted);
            }

        .toggle {
            position: relative;
            width: 36px;
            height: 19px;
        }

            .toggle input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .toggle-slider {
            position: absolute;
            inset: 0;
            background: var(--border);
            border-radius: 19px;
            cursor: pointer;
            transition: background 0.2s;
        }

            .toggle-slider::before {
                content: '';
                position: absolute;
                width: 13px;
                height: 13px;
                left: 3px;
                top: 3px;
                background: var(--text-muted);
                border-radius: 50%;
                transition: transform 0.2s, background 0.2s;
            }

        .toggle input:checked + .toggle-slider {
            background: var(--accent2);
        }

            .toggle input:checked + .toggle-slider::before {
                transform: translateX(17px);
                background: white;
            }

        #translation-status {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        /* Replace */
        .replace-pair {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* TTS Buttons */
        .tts-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        /* Sliders */
        .slider-row {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.62rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

            .slider-label span {
                color: var(--accent);
            }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--accent);
                cursor: pointer;
                transition: transform 0.15s;
            }

                input[type="range"]::-webkit-slider-thumb:hover {
                    transform: scale(1.3);
                }

        select#voice-select {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            padding: 6px 8px;
            outline: none;
            margin-bottom: 12px;
        }

            select#voice-select:focus {
                border-color: var(--accent);
            }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.68rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            transition: opacity 0.2s, transform 0.1s;
        }

            .btn:hover {
                opacity: 0.85;
            }

            .btn:active {
                transform: scale(0.97);
            }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn-secondary {
            background: var(--surface2);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .btn-success {
            background: var(--accent2);
            color: var(--bg);
        }

        .btn-tts {
            background: var(--surface2);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.65rem;
            padding: 7px 6px;
        }

            .btn-tts:disabled {
                opacity: 0.35;
                cursor: not-allowed;
                transform: none;
            }

            .btn-tts.active {
                background: var(--accent);
                color: var(--bg);
                border-color: var(--accent);
            }

        .btn-full {
            width: 100%;
        }

        /* Inputs */
        input[type="text"] {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 7px 10px;
            outline: none;
        }

            input[type="text"]:focus {
                border-color: var(--accent);
            }

            input[type="text"]::placeholder {
                color: var(--text-dim);
            }

        /* Modal de reemplazos */
        #modal-reemplazos {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 500;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

            #modal-reemplazos.open {
                display: flex;
            }

        .modal-box {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: min(480px, 90vw);
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 24px 60px rgba(0,0,0,0.6);
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            font-family: 'DM Mono', monospace;
            font-size: 0.78rem;
            color: var(--text);
        }

            .modal-header button {
                background: none;
                border: none;
                color: var(--text-dim);
                cursor: pointer;
                font-size: 1rem;
                line-height: 1;
                padding: 2px 6px;
                border-radius: 4px;
                transition: color 0.2s;
            }

                .modal-header button:hover {
                    color: var(--text);
                }

        .modal-body {
            overflow-y: auto;
            padding: 14px 20px;
            flex: 1;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        .modal-empty {
            color: var(--text-dim);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            font-style: italic;
            text-align: center;
            padding: 24px 0;
        }

        .modal-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
        }

            .modal-row:last-child {
                border-bottom: none;
            }

            .modal-row .from {
                color: var(--text-muted);
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .modal-row .arrow {
                color: var(--text-dim);
                flex-shrink: 0;
            }

            .modal-row .to {
                color: var(--accent);
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .modal-row .del-btn {
                background: none;
                border: none;
                color: var(--text-dim);
                cursor: pointer;
                font-size: 0.8rem;
                padding: 2px 5px;
                border-radius: 3px;
                flex-shrink: 0;
                transition: color 0.2s;
            }

                .modal-row .del-btn:hover {
                    color: #e05252;
                }

        #notification {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.72rem;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

            #notification.show {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }

        /* Scrollbar for reading area */
        .reading-area {
            scroll-behavior: smooth;
        }

        /* Highlight spoken word */
        .spoken {
            background: rgba(200, 169, 110, 0.18);
            border-radius: 2px;
        }

        /* TTS sentence highlight */
        .tts-sentence {
            border-radius: 3px;
            transition: background 0.25s ease, box-shadow 0.25s ease;
        }

            .tts-sentence.tts-active {
                background: rgba(200, 169, 110, 0.22);
                box-shadow: 0 0 0 2px rgba(200, 169, 110, 0.15);
                border-radius: 3px;
            }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .playing-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent2);
            animation: pulse 1s infinite;
            margin-right: 6px;
        }

        /* Responsive */
        @media (max-width: 700px) {
            :root {
                --sidebar-w: 240px;
            }

            .reading-area {
                padding: 32px 24px;
            }
        }

        /* ─── AMBIENT MUSIC PLAYER ─── */
        #ambient-player {
            position: fixed;
            bottom: 36px; /* just above progress-wrap + footer */
            left: 0;
            width: 240px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0 10px 0 0;
            border-bottom: none;
            border-left: none;
            z-index: 100;
            overflow: hidden;
            box-shadow: 4px -4px 20px rgba(0,0,0,0.4);
            transition: transform 0.4s ease, opacity 0.5s ease, bottom 0.4s ease;
        }

            /* Translúcido cuando está reproduciendo */
            #ambient-player.ambient-playing {
                opacity: 0.25;
            }

                /* Al pasar el mouse, vuelve completamente visible */
                #ambient-player.ambient-playing:hover {
                    opacity: 1;
                }

            #ambient-player.processing-raised {
                bottom: 104px;
            }

            #ambient-player.collapsed .ambient-body {
                display: none;
            }

        .ambient-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            user-select: none;
        }

        .ambient-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.68rem;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .ambient-eq {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 12px;
        }

            .ambient-eq span {
                width: 3px;
                background: var(--accent2);
                border-radius: 1px;
                animation: none;
                height: 3px;
                transition: height 0.2s;
            }

            .ambient-eq.playing span:nth-child(1) {
                animation: eq1 0.8s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(2) {
                animation: eq2 0.6s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(3) {
                animation: eq3 1s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(4) {
                animation: eq2 0.7s ease-in-out infinite;
            }

        @keyframes eq1 {
            0%,100% {
                height: 3px
            }

            50% {
                height: 10px
            }
        }

        @keyframes eq2 {
            0%,100% {
                height: 6px
            }

            50% {
                height: 12px
            }
        }

        @keyframes eq3 {
            0%,100% {
                height: 9px
            }

            50% {
                height: 4px
            }
        }

        .ambient-collapse-btn {
            font-size: 0.6rem;
            color: var(--text-dim);
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
        }

        .ambient-body {
            padding: 14px;
        }

        .ambient-genres {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .genre-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 4px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.58rem;
            color: var(--text-muted);
            transition: all 0.2s;
        }

            .genre-btn:hover {
                border-color: var(--accent);
                color: var(--text);
            }

            .genre-btn.active {
                border-color: var(--accent2);
                background: rgba(126, 184, 154, 0.1);
                color: var(--accent2);
            }

            .genre-btn .genre-icon {
                font-size: 1rem;
            }

        .ambient-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .ambient-play-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--accent2);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--bg);
            flex-shrink: 0;
            transition: transform 0.15s, opacity 0.15s;
        }

            .ambient-play-btn:hover {
                transform: scale(1.1);
            }

        .ambient-track-info {
            flex: 1;
            overflow: hidden;
        }

        .ambient-track-name {
            font-size: 0.6rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ambient-track-genre {
            font-size: 0.55rem;
            color: var(--text-dim);
        }

        .ambient-vol-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ambient-vol-icon {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .ambient-vol-row input[type=range] {
            flex: 1;
            height: 3px;
        }

        .ambient-vol-val {
            font-size: 0.6rem;
            color: var(--text-dim);
            width: 26px;
            text-align: right;
        }


        /* ─── GRABACIÓN & VIDEO ─── */
        .rec-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--surface2);
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

            .rec-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

            .rec-btn.recording {
                border-color: #e05555;
                color: #e05555;
                animation: recpulse 1s infinite;
            }

        @keyframes recpulse {
            0%,100% {
                opacity: 1
            }

            50% {
                opacity: 0.5
            }
        }

        /* Spotify-style video overlay */
        #video-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 9, 8, 0.92);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            padding-bottom: 6px;
            overflow: hidden;
        }

            #video-overlay.active {
                display: flex;
            }

        #video-canvas {
            border-radius: 12px;
            background: transparent;
        }

        #video-close {
            position: absolute;
            top: 20px;
            right: 24px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.4rem;
            cursor: pointer;
            transition: color 0.2s;
        }

            #video-close:hover {
                color: var(--text);
            }

        /* ── Panel de índice de capítulos en modo video ── */
        #video-index-panel {
            display: none;
            position: absolute;
            top: 0;
            right: 0;
            width: 260px;
            height: 100%;
            background: rgba(15, 14, 12, 0.92);
            border-left: 1px solid var(--border);
            border-radius: 0 12px 12px 0;
            flex-direction: column;
            z-index: 5;
            backdrop-filter: blur(4px);
            overflow: hidden;
        }

            #video-index-panel.open {
                display: flex;
            }

        #video-index-header {
            padding: 10px 14px 8px;
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        #video-index-search {
            margin: 8px 10px;
            padding: 6px 10px;
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            outline: none;
            width: calc(100% - 20px);
            flex-shrink: 0;
        }

            #video-index-search:focus {
                border-color: var(--accent);
            }

        #video-index-list {
            flex: 1;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

        .video-index-item {
            padding: 8px 14px;
            font-size: 0.68rem;
            color: var(--text-muted);
            cursor: pointer;
            border-bottom: 1px solid rgba(46,42,34,0.4);
            transition: background 0.15s, color 0.15s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: 'DM Mono', monospace;
        }

            .video-index-item:hover {
                background: var(--surface2);
                color: var(--text);
            }

            .video-index-item.active {
                color: var(--accent);
                background: rgba(200,169,110,0.08);
            }

        /* ── Barra de progreso tipo YouTube en video ── */
        #video-progress-wrap {
            width: min(900px, 95vw);
            margin-top: 12px;
            position: relative;
            user-select: none;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #video-progress-track {
            height: 20px; /* área clickeable amplia, sin desplazar layout */
            background: transparent;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
        }

            /* Riel visual: centrado verticalmente dentro del área clickeable */
            #video-progress-track::before {
                content: '';
                position: absolute;
                left: 0;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                height: 3px;
                background: rgba(255,255,255,0.15);
                border-radius: 4px;
                transition: height 0.15s ease;
                pointer-events: none;
            }

            #video-progress-track:hover::before {
                height: 5px;
            }

            #video-progress-track:hover #video-progress-thumb {
                opacity: 1;
                transform: translateY(-50%) scale(1);
            }

        #video-progress-fill {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 3px;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            border-radius: 4px;
            pointer-events: none;
            transition: height 0.15s ease;
        }

        #video-progress-track:hover #video-progress-fill {
            height: 5px;
        }

        #video-progress-thumb {
            position: absolute;
            right: -7px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.15s, transform 0.15s;
            pointer-events: none;
        }

        /* Tooltip de preview */
        #video-seek-tooltip {
            position: absolute;
            bottom: 16px;
            transform: translateX(-50%);
            background: rgba(18,16,14,0.95);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.65rem;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            max-width: 220px;
            white-space: pre-wrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
            text-align: center;
            line-height: 1.4;
        }

            #video-seek-tooltip.visible {
                opacity: 1;
            }

        #video-progress-time {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: var(--text-dim);
            font-family: 'DM Mono', monospace;
            margin-top: 4px;
            padding: 0 2px;
        }

        .video-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 6px;
            margin-bottom: 4px;
            width: min(900px, 95vw);
            position: relative;
            opacity: 1;
            transition: opacity 0.5s ease;
            flex-shrink: 0;
        }

        /* En pantalla completa, el overlay cubre toda la pantalla */
        :fullscreen #video-overlay,
        :-webkit-full-screen #video-overlay {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            border-radius: 0 !important;
            max-width: none !important;
            justify-content: center;
        }

            :fullscreen #video-overlay #ai-bg-wrap,
            :-webkit-full-screen #video-overlay #ai-bg-wrap {
                width: 100vw !important;
                height: calc(100vh - 80px) !important;
                max-width: none !important;
                border-radius: 0 !important;
            }

        :fullscreen .video-bar,
        :-webkit-full-screen .video-bar {
            width: 95vw !important;
        }

        :fullscreen #video-progress-wrap,
        :-webkit-full-screen #video-progress-wrap {
            width: 95vw !important;
        }

        .video-track {
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .video-controls {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

            .video-controls button {
                background: var(--surface2);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-muted);
                font-size: 0.65rem;
                font-family: 'DM Mono', monospace;
                padding: 6px 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

                .video-controls button:hover {
                    border-color: var(--accent);
                    color: var(--accent);
                }

                .video-controls button.ai-active {
                    border-color: var(--accent2);
                    color: var(--accent2);
                    background: rgba(126,184,154,0.1);
                }

        .video-playbar {
            display: flex;
            align-items: center;
            gap: 10px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .kbtn {
            border: none;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            transition: all 0.18s;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .kbtn-nav {
            background: rgba(255,255,255,0.06);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.6rem;
            padding: 7px 10px;
            letter-spacing: 0.02em;
            min-width: 0;
            width: auto;
        }

            .kbtn-nav:hover {
                background: rgba(200,169,110,0.12);
                border-color: var(--accent);
                color: var(--accent);
            }

        .kbtn-music {
            background: rgba(126,184,154,0.08);
            border: 1px solid rgba(126,184,154,0.2);
            border-radius: 6px;
            color: var(--accent2);
            font-size: 0.55rem;
            padding: 4px 6px;
            min-width: 0;
            width: auto;
        }

            .kbtn-music:hover {
                background: rgba(126,184,154,0.18);
                border-color: var(--accent2);
            }

        .kbtn-play {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: var(--accent);
            color: var(--bg);
            font-size: 0.95rem;
            box-shadow: 0 0 16px rgba(200,169,110,0.3);
            flex-shrink: 0;
        }

            .kbtn-play:hover {
                transform: scale(1.08);
                box-shadow: 0 0 24px rgba(200,169,110,0.5);
            }

            .kbtn-play.paused {
                background: var(--accent2);
                box-shadow: 0 0 16px rgba(126,184,154,0.3);
            }
    </style>
</head>
<body>

    <div id="notification" class="notification"></div>

    <!-- ─── MAIN PANEL ─── -->
    <div class="main-panel">
        <div class="top-bar">
            <h1>📚 Lector EPUB</h1>
            <button class="rec-btn" id="btn-rec-audio" onclick="toggleGrabacion()" style="margin-left:16px;margin-bottom:0;">
                <span id="rec-dot">⏺</span> Grabar audio
            </button>
            <button class="rec-btn" onclick="abrirvideo()" style="margin-bottom:0;">
                🎬 Modo Video
            </button>
            <button class="rec-btn" onclick="toggleEditor()" id="editor-toggle-btn" style="margin-bottom:0;">
                ✏️ Editor
            </button>
            <span class="subtitle" id="current-chapter-title">Ningún capítulo seleccionado</span>
        </div>

        <div class="stats-bar">
            <div class="stat">📝 Palabras: <strong id="contador-palabras">0</strong></div>
            <div class="stat">🔤 Chars: <strong id="contador-caracteres">0</strong></div>
            <div class="stat">📄 Párrafos: <strong id="contador-parrafos">0</strong></div>
            <div class="stat" id="tts-stat" style="margin-left:auto;">⏹️ <strong id="tts-status">Detenido</strong></div>
        </div>

        <div class="reading-area" style="position:relative;">
            <div id="texto-contenido" style="font-family:'Lora',serif;font-size:1.1rem;line-height:1.85;color:var(--text);max-width:680px;margin:0 auto;white-space:pre-wrap;">
                <p style="color:var(--text-dim);font-style:italic;">Carga un archivo EPUB desde el panel lateral para comenzar a leer...</p>
            </div>
            <!-- Música ambiental flotante anclada a esquina inferior izquierda del reading area -->
        </div><!-- cierre reading-area -->
        <!-- Barra de procesamiento con fases — visible en el reading area al procesar -->
        <div id="main-processing-bar" style="display:none;flex-direction:column;align-items:stretch;gap:6px;padding:10px 28px 12px;background:var(--surface2);border-top:1px solid var(--border);border-bottom:1px solid var(--border);">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                <span id="mpb-label" style="font-size:0.7rem;color:var(--accent2);font-family:'DM Mono',monospace;font-style:italic;flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">Procesando...</span>
                <span id="mpb-pct" style="font-size:0.65rem;color:var(--text-dim);font-family:'DM Mono',monospace;flex-shrink:0;">0%</span>
            </div>
            <!-- Barra unificada -->
            <div style="height:4px;background:var(--border);border-radius:4px;overflow:hidden;">
                <div id="mpb-fill" style="height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent2));border-radius:4px;transition:width 0.5s ease;"></div>
            </div>
            <!-- Indicadores de fase -->
            <div style="display:flex;justify-content:space-between;font-family:'DM Mono',monospace;font-size:0.58rem;color:var(--text-dim);margin-top:1px;">
                <span id="mpb-f1" style="transition:color 0.3s;">① Traducción</span>
                <span id="mpb-f2" style="transition:color 0.3s;">② Revisión</span>
                <span id="mpb-f3" style="transition:color 0.3s;">③ Optimización</span>
            </div>
        </div>

        <div class="editor-panel" id="editor-panel">
            <div class="editor-inner">
                <div class="section-label">Editor de Texto</div>
                <textarea id="editor-texto" placeholder="Pega aquí tu texto o edita el contenido actual..."></textarea>
                <div class="editor-actions">
                    <button class="btn btn-success" onclick="aplicarTexto()">Aplicar</button>
                    <button class="btn btn-secondary" onclick="limpiarEditor()">Limpiar</button>
                    <button class="btn btn-secondary" onclick="copiarTexto()">Copiar</button>
                    <button class="btn btn-secondary" onclick="traducirTextoActual()" style="margin-left:auto;">Traducir</button>
                </div>
            </div>
        </div>

        <!-- tts-status-label y tts-percent se mantienen en el DOM pero ocultos (usados por JS) -->
        <span id="tts-status-label" style="display:none;"></span>
        <!--<span id="tts-percent" style="display:none;"></span>-->

        <div class="progress-wrap">
            <div class="progress-track" id="main-progress-track"
                 onclick="seekTTS(event)"
                 onmousemove="mainProgressMouseMove(event)"
                 onmouseleave="mainProgressMouseLeave()">
                <div class="progress-fill" id="progress-fill"></div>
                <div id="main-progress-tooltip"></div>
            </div>
        </div>
    </div>

    <!-- ─── SIDEBAR ─── -->
    <div class="sidebar">

        <!-- Cargar EPUB -->
        <div class="sidebar-section">
            <div class="section-label">Archivo</div>
            <label for="epub-file" class="file-label">📂 Seleccionar EPUB</label>
            <input type="file" id="epub-file" accept=".epub">
            <span id="file-name">Ningún archivo seleccionado</span>
        </div>

        <!-- Capítulos -->
        <div class="sidebar-section">
            <div class="section-label">Capítulos</div>
            <div id="chapter-selector">
                <input type="text" id="chapter-search" placeholder="🔍 Buscar capítulo..."
                       oninput="filtrarCapitulos(this.value)"
                       style="width:100%;margin-bottom:6px;font-size:0.68rem;padding:6px 10px;
                              background:var(--bg);border:1px solid var(--border);border-radius:4px;
                              color:var(--text);font-family:'DM Mono',monospace;outline:none;">
                <select id="chapters" size="6">
                    <option disabled>— sin capítulos —</option>
                </select>
            </div>
        </div>

        <!-- Traducción -->
        <div class="sidebar-section">
            <div class="section-label">Traducción</div>
            <div class="toggle-row">
                <span>Auto EN → ES</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-translate" onchange="marcarCambioPendiente()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div id="translation-status">Traducción desactivada</div>

            <!-- ✨ Naturalizar para TTS -->
            <div class="toggle-row" style="margin-top:8px;">
                <span style="display:flex;flex-direction:column;gap:2px;">
                    <span>✨ Naturalizar para TTS</span>
                    <span style="font-size:0.7rem;color:var(--text-dim);" id="humanizer-status">Desactivado</span>
                </span>
                <label class="toggle">
                    <input type="checkbox" id="tts-humanizer" onchange="toggleTTSHumanizer()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div id="claude-key-panel" style="margin-top:6px;display:none;">
                <!-- Selector de proveedor de IA -->
                <select id="humanizer-provider" onchange="cambiarProveedorHumanizer(this.value)"
                        style="width:100%;background:var(--bg);border:1px solid var(--border);border-radius:4px;
                               color:var(--text);font-family:'DM Mono',monospace;font-size:0.62rem;
                               padding:5px 8px;outline:none;cursor:pointer;margin-bottom:6px;">
                    <option value="perplexity">Perplexity AI (sonar)</option>
                    <option value="openai">OpenAI (gpt-4o-mini)</option>
                    <option value="anthropic">Anthropic (claude-haiku)</option>
                    <option value="gemini">Google Gemini (flash)</option>
                    <option value="groq">Groq (llama-3.3-70b)</option>
                    <option value="openrouter">OpenRouter (auto)</option>
                </select>
                <div style="font-size:0.58rem;color:var(--text-dim);margin-bottom:4px;">
                    🔑 API Key <span style="color:var(--accent2)" id="claude-key-status"></span>
                </div>
                <div style="display:flex;gap:6px;">
                    <input type="password" id="claude-api-key" placeholder="Pega tu API key..."
                           style="flex:1;background:var(--bg);border:1px solid var(--border);border-radius:4px;
                           color:var(--text);font-family:'DM Mono',monospace;font-size:0.62rem;padding:5px 8px;outline:none;">
                    <button onclick="guardarClaudeApiKey()"
                            style="background:var(--accent);border:none;border-radius:4px;color:var(--bg);
                            font-family:'DM Mono',monospace;font-size:0.6rem;padding:5px 8px;cursor:pointer;">
                        OK
                    </button>
                </div>
                <div style="font-size:0.55rem;color:var(--text-dim);margin-top:3px;" id="humanizer-info">
                    Procesa ~2500 chars por bloque · puede tardar unos segundos
                </div>
            </div>

            <!-- ▶ Reproducir al terminar -->
            <div class="toggle-row" id="auto-play-row" style="margin-top:8px;display:none;">
                <span style="font-size:0.85rem;color:var(--text-dim);">▶ Reproducir al terminar</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-play-after-translate" onchange="marcarCambioPendiente()">
                    <span class="toggle-slider"></span>
                </label>
            </div>

            <!-- Botón Aplicar — solo visible cuando hay cambios sin confirmar -->
            <div id="aplicar-row" style="display:none;margin-top:10px;">
                <button id="btn-aplicar" onclick="aplicarConfiguracion()"
                        style="width:100%;background:var(--accent);border:none;border-radius:6px;
                               color:var(--bg);font-family:'DM Mono',monospace;font-size:0.72rem;
                               font-weight:700;padding:8px 0;cursor:pointer;letter-spacing:0.03em;
                               transition:opacity 0.2s;">
                    ✓ Aplicar
                </button>
                <div style="font-size:0.55rem;color:var(--text-dim);text-align:center;margin-top:3px;" id="aplicar-hint">
                    Cambios pendientes — recarga el capítulo actual
                </div>
            </div>
        </div>

        <!-- Reemplazar palabras -->
        <div class="sidebar-section">
            <div class="section-label collapsible-label" onclick="toggleReemplazar()" style="cursor:pointer;user-select:none;display:flex;align-items:center;">
                Reemplazar
                <span id="reemplazar-arrow" style="margin-left:auto;font-size:0.7rem;color:var(--text-dim);">▶</span>
                <button onclick="event.stopPropagation();abrirModalReemplazos()" title="Ver reemplazos activos"
                        style="margin-left:6px;background:none;border:1px solid var(--border);border-radius:4px;color:var(--text-dim);font-size:0.58rem;padding:1px 5px;cursor:pointer;line-height:1.4;transition:color 0.2s,border-color 0.2s;"
                        onmouseover="this.style.color='var(--accent)';this.style.borderColor='var(--accent)'"
                        onmouseout="this.style.color='var(--text-dim)';this.style.borderColor='var(--border)'">
                    📋
                </button>
            </div>
            <div class="replace-pair" id="reemplazar-body" style="display:none;">
                <input type="text" id="palabra-buscar" placeholder="Buscar...">
                <input type="text" id="palabra-reemplazar" placeholder="Reemplazar con...">
                <div style="display:flex;gap:6px;">
                    <button class="btn btn-secondary" id="btn-limpiar-reemplazos" onclick="limpiarReemplazosGuardados()" style="flex:1;font-size:0.62rem;" disabled>🗑 Limpiar</button>
                    <button class="btn btn-primary" onclick="reemplazarPalabra()" style="flex:1;">Reemplazar</button>
                </div>
                <div id="reemplazos-guardados-lista" style="display:none;margin-top:6px;max-height:90px;overflow-y:auto;scrollbar-width:thin;scrollbar-color:var(--border) transparent;"></div>
            </div>
        </div>

        <!-- TTS Controles -->
        <div class="sidebar-section">
            <div class="section-label">Reproducción</div>
            <div class="tts-btn-grid">
                <button class="btn-tts btn" onclick="iniciarTTS()" id="btn-play">▶ Play</button>
                <button class="btn-tts btn" onclick="pausarTTS()" id="btn-pause" disabled>⏸ Pausa</button>
                <button class="btn-tts btn" onclick="reanudarTTS()" id="btn-resume" disabled>▶ Cont.</button>
                <button class="btn-tts btn" onclick="detenerTTS()" id="btn-stop" disabled>⏹ Stop</button>
            </div>

            <div class="section-label" style="margin-top:4px;">Voz</div>
            <select id="voice-select"></select>

            <div class="slider-row">
                <div class="slider-label">Velocidad <span id="rate-value">1.0</span>x</div>
                <input type="range" id="rate-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Tono <span id="pitch-value">1.0</span></div>
                <input type="range" id="pitch-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Volumen <span id="volume-value">100</span>%</div>
                <input type="range" id="volume-control" min="0" max="100" step="5" value="100">
            </div>
        </div>

    </div>

    <script src="js/main.js"></script>
    <script>
        // ─── REEMPLAZOS GUARDADOS EN LOCALSTORAGE ───
        function actualizarBotonLimpiarReemplazos() {
            const datos = JSON.parse(localStorage.getItem('reemplazos_custom') || '{}');
            const btn = document.getElementById('btn-limpiar-reemplazos');
            const lista = document.getElementById('reemplazos-guardados-lista');
            const tiene = Object.keys(datos).length > 0;
            if (btn) btn.disabled = !tiene;
            if (lista) {
                if (tiene) {
                    lista.style.display = 'block';
                    lista.innerHTML = Object.entries(datos).map(([k, v]) =>
                        `<div style="font-size:0.58rem;color:var(--text-dim);padding:2px 0;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;gap:4px;">
                                            <span style="color:var(--text-muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${k}</span>
                                            <span style="color:var(--accent);flex-shrink:0;">→ ${v}</span>
                                        </div>`
                    ).join('');
                } else {
                    lista.style.display = 'none';
                    lista.innerHTML = '';
                }
            }
        }

        function limpiarReemplazosGuardados() {
            if (!confirm('¿Borrar todos los reemplazos guardados?')) return;
            localStorage.removeItem('reemplazos_custom');
            // Limpiar el objeto activo en main.js
            if (typeof reemplazosAutomaticos !== 'undefined') {
                Object.keys(reemplazosAutomaticos).forEach(k => delete reemplazosAutomaticos[k]);
            }
            actualizarBotonLimpiarReemplazos();
            mostrarNotificacion('🗑 Reemplazos borrados');
        }

        // Inicializar estado del botón al cargar
        window.addEventListener('DOMContentLoaded', () => {
            actualizarBotonLimpiarReemplazos();
        });

        // Exponer para que main.js pueda llamarla
        window.actualizarBotonLimpiarReemplazos = actualizarBotonLimpiarReemplazos;

        // Reemplazar toggle
        function toggleReemplazar() {
            const body = document.getElementById('reemplazar-body');
            const arrow = document.getElementById('reemplazar-arrow');
            const open = body.style.display === 'none';
            body.style.display = open ? 'flex' : 'none';
            arrow.textContent = open ? '▼' : '▶';
            if (open) actualizarBotonLimpiarReemplazos();
        }

        // Editor toggle (UI only)
        function toggleEditor() {
            const panel = document.getElementById('editor-panel');
            const btn = document.getElementById('editor-toggle-btn');
            panel.classList.toggle('open');
            btn.textContent = panel.classList.contains('open') ? '✕ Cerrar Editor' : '✏️ Editor';
        }

        // Sync chapter title in top bar when chapter changes
        document.getElementById('chapters').addEventListener('change', function (e) {
            const opt = e.target.options[e.target.selectedIndex];
            if (opt) document.getElementById('current-chapter-title').textContent = opt.textContent;
        });

        // Patch actualizarEstadoTTS to also update the extra status elements in the new layout
        const _origActualizarEstadoTTS = actualizarEstadoTTS;
        // Wait for main.js to load first
        window.addEventListener('DOMContentLoaded', () => { });

        // Patch iniciarTTS: reconstruir slot map de IA y detectar universo al iniciar
        const _origIniciarTTS = iniciarTTS;
        window.iniciarTTS = function () {
            _origIniciarTTS.apply(this, arguments);
            // Tras iniciar, sentences ya fue reconstruido en main.js
            setTimeout(() => {
                if (typeof buildAiSlotMap === 'function') buildAiSlotMap();
                if (typeof detectarUniverso === 'function') detectarUniverso();
                // Sincronizar botón play/pausa del visor
                const btn = document.getElementById('kbtn-playpause');
                if (btn) { btn.innerHTML = '⏸'; btn.classList.remove('paused'); }
            }, 80);
        };
        iniciarTTS = window.iniciarTTS;
    </script>

    <!-- ─── AMBIENT MUSIC PLAYER ─── -->
    <div id="ambient-player" class="collapsed">
        <div class="ambient-header" onclick="toggleAmbientPanel()">
            <div class="ambient-header-left">
                <div class="ambient-eq" id="ambient-eq">
                    <span></span><span></span><span></span><span></span>
                </div>
                Música Ambiental
            </div>
            <button class="ambient-collapse-btn" id="ambient-arrow">▲</button>
        </div>
        <div class="ambient-body">

            <!-- API Key panel -->
            <div id="freesound-key-panel" style="margin-bottom:10px;">
                <div style="font-size:0.58rem;color:var(--text-dim);margin-bottom:4px;">
                    🎵 Freesound API Key <span style="color:var(--accent2)" id="key-status"></span>
                </div>
                <div style="display:flex;gap:6px;">
                    <input type="password" id="freesound-api-key" placeholder="Pegar API key..."
                           style="flex:1;background:var(--bg);border:1px solid var(--border);border-radius:4px;
                    color:var(--text);font-family:'DM Mono',monospace;font-size:0.62rem;padding:5px 8px;outline:none;">
                    <button onclick="guardarApiKey()"
                            style="background:var(--accent2);border:none;border-radius:4px;color:var(--bg);
                    font-family:'DM Mono',monospace;font-size:0.6rem;padding:5px 8px;cursor:pointer;">
                        OK
                    </button>
                </div>
                <div style="font-size:0.55rem;color:var(--text-dim);margin-top:3px;">
                    Sin key → generador procedural local
                </div>
            </div>

            <div class="ambient-genres">
                <button class="genre-btn" onclick="selectGenre('mystery')" id="genre-mystery">
                    <span class="genre-icon">🔍</span>Misterio
                </button>
                <button class="genre-btn" onclick="selectGenre('suspense')" id="genre-suspense">
                    <span class="genre-icon">😰</span>Suspenso
                </button>
                <button class="genre-btn" onclick="selectGenre('drama')" id="genre-drama">
                    <span class="genre-icon">🎭</span>Drama
                </button>
                <button class="genre-btn" onclick="selectGenre('action')" id="genre-action">
                    <span class="genre-icon">⚡</span>Acción
                </button>
                <button class="genre-btn" onclick="selectGenre('fantasy')" id="genre-fantasy">
                    <span class="genre-icon">🧙</span>Fantasía
                </button>
                <button class="genre-btn" onclick="selectGenre('romance')" id="genre-romance">
                    <span class="genre-icon">💫</span>Romance
                </button>
                <button class="genre-btn" onclick="selectGenre('lofi')" id="genre-lofi">
                    <span class="genre-icon">📚</span>Lo-Fi
                </button>
                <button class="genre-btn" onclick="selectGenre('nature')" id="genre-nature">
                    <span class="genre-icon">🌿</span>Naturaleza
                </button>
            </div>

            <button class="btn btn-secondary" onclick="detectarGeneroConIA()" id="btn-detect-genre"
                    style="width:100%;margin-bottom:10px;font-size:0.62rem;gap:6px;">
                ✨ Detectar género del texto
            </button>

            <div class="ambient-controls">
                <button class="ambient-play-btn" id="ambient-play-btn" onclick="toggleAmbientPlay()">▶</button>
                <div class="ambient-track-info">
                    <div class="ambient-track-name" id="ambient-track-name">Selecciona un género</div>
                    <div class="ambient-track-genre" id="ambient-track-genre">─</div>
                </div>
                <button onclick="siguienteTrack()" title="Siguiente track" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:0.9rem;padding:4px;transition:color 0.2s;" onmouseover="this.style.color='var(--accent)'" onmouseout="this.style.color='var(--text-dim)'">⏭</button>
            </div>

            <div class="ambient-vol-row">
                <span class="ambient-vol-icon">🎵</span>
                <input type="range" id="ambient-volume" min="0" max="100" value="15" oninput="setAmbientVolume(this.value)">
                <span class="ambient-vol-val" id="ambient-vol-val">15%</span>
            </div>
        </div>
    </div><!-- cierre ambient-player -->

    <script>
        // ─── AMBIENT MUSIC ENGINE — Web Audio API Procedural Generation ───
        // Genera música ambiental 100% en el navegador sin URLs externas

        let ambientCtx = null;
        let ambientNodes = [];
        let ambientPlaying = false;
        let ambientGenre = null;
        let ambientGainNode = null;
        let ambientVolume = 0.15;

        function getAudioCtx() {
            if (!ambientCtx) ambientCtx = new (window.AudioContext || window.webkitAudioContext)();
            return ambientCtx;
        }

        // ── Generadores por género ──
        const GENRE_GENERATORS = {

            mystery: (ctx, gain) => {
                // Notas oscuras lentas + reverb simulado
                const notes = [130.81, 155.56, 174.61, 196.00, 220.00];
                const nodes = [];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain);
                    osc.start();
                    // Pulsa cada nota con tiempo diferente
                    const interval = setInterval(() => {
                        const now = ctx.currentTime;
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(0.08, now + 0.3);
                        g.gain.linearRampToValueAtTime(0, now + 2.5);
                    }, 3000 + i * 700);
                    nodes.push({ osc, interval });
                });
                // Rumble bajo
                const rumble = ctx.createOscillator();
                const rg = ctx.createGain();
                rumble.type = 'sine'; rumble.frequency.value = 55;
                rg.gain.value = 0.04;
                rumble.connect(rg); rg.connect(gain); rumble.start();
                nodes.push({ osc: rumble });
                return nodes;
            },

            suspense: (ctx, gain) => {
                const nodes = [];
                // Tremolo tense string simulation
                [220, 233, 246].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    const g = ctx.createGain();
                    osc.type = 'sawtooth'; osc.frequency.value = freq;
                    lfo.type = 'sine'; lfo.frequency.value = 6 + i;
                    lfoGain.gain.value = 0.03;
                    g.gain.value = 0.04;
                    lfo.connect(lfoGain); lfoGain.connect(g.gain);
                    osc.connect(g); g.connect(gain);
                    osc.start(); lfo.start();
                    nodes.push({ osc }, { osc: lfo });
                });
                // Heartbeat-like bass
                const bass = ctx.createOscillator();
                const bg = ctx.createGain();
                bass.type = 'sine'; bass.frequency.value = 80;
                bg.gain.value = 0;
                bass.connect(bg); bg.connect(gain); bass.start();
                const beat = setInterval(() => {
                    const now = ctx.currentTime;
                    bg.gain.setValueAtTime(0, now);
                    bg.gain.linearRampToValueAtTime(0.12, now + 0.05);
                    bg.gain.linearRampToValueAtTime(0, now + 0.3);
                    bg.gain.setValueAtTime(0, now + 0.5);
                    bg.gain.linearRampToValueAtTime(0.08, now + 0.55);
                    bg.gain.linearRampToValueAtTime(0, now + 0.8);
                }, 1800);
                nodes.push({ osc: bass, interval: beat });
                return nodes;
            },

            drama: (ctx, gain) => {
                const nodes = [];
                // Slow cinematic pads
                [[261.63, 0.06], [329.63, 0.04], [392.00, 0.03], [493.88, 0.025]].forEach(([freq, vol]) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    g.gain.value = vol;
                    osc.connect(g); g.connect(gain); osc.start();
                    nodes.push({ osc });
                });
                // Slow filter sweep
                const noise = ctx.createOscillator();
                const ng = ctx.createGain();
                noise.type = 'triangle'; noise.frequency.value = 110;
                ng.gain.value = 0.05;
                noise.connect(ng); ng.connect(gain); noise.start();
                nodes.push({ osc: noise });
                return nodes;
            },

            action: (ctx, gain) => {
                const nodes = [];
                // Aggressive rhythm + brass-like hits
                const bassOsc = ctx.createOscillator();
                const bg = ctx.createGain();
                bassOsc.type = 'square'; bassOsc.frequency.value = 110;
                bg.gain.value = 0;
                bassOsc.connect(bg); bg.connect(gain); bassOsc.start();
                let beat = 0;
                const rhythm = [1, 0, 1, 0, 1, 1, 0, 1];
                const interval = setInterval(() => {
                    if (rhythm[beat % rhythm.length]) {
                        const now = ctx.currentTime;
                        bg.gain.setValueAtTime(0.1, now);
                        bg.gain.linearRampToValueAtTime(0, now + 0.15);
                    }
                    beat++;
                }, 200);
                nodes.push({ osc: bassOsc, interval });
                // High tension strings
                [440, 554, 659].forEach(freq => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sawtooth'; o.frequency.value = freq;
                    g.gain.value = 0.025;
                    o.connect(g); g.connect(gain); o.start();
                    nodes.push({ osc: o });
                });
                return nodes;
            },

            fantasy: (ctx, gain) => {
                const nodes = [];
                // Magical harp-like arpeggios
                const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
                let noteIdx = 0;
                const playNote = () => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = scale[noteIdx % scale.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(0.07, now + 0.05);
                    g.gain.linearRampToValueAtTime(0, now + 1.2);
                    setTimeout(() => osc.stop(), 1500);
                    noteIdx++;
                };
                const interval = setInterval(playNote, 400);
                nodes.push({ interval });
                // Pad underneath
                const pad = ctx.createOscillator();
                const pg = ctx.createGain();
                pad.type = 'sine'; pad.frequency.value = 130.81;
                pg.gain.value = 0.03;
                pad.connect(pg); pg.connect(gain); pad.start();
                nodes.push({ osc: pad });
                return nodes;
            },

            romance: (ctx, gain) => {
                const nodes = [];
                // Warm, slow piano-like notes
                const melody = [261.63, 329.63, 392.00, 329.63, 261.63, 293.66, 349.23, 293.66];
                let idx = 0;
                const interval = setInterval(() => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = melody[idx % melody.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.linearRampToValueAtTime(0.08, now + 0.1);
                    g.gain.linearRampToValueAtTime(0, now + 1.8);
                    setTimeout(() => osc.stop(), 2000);
                    // Armonía
                    const osc2 = ctx.createOscillator();
                    const g2 = ctx.createGain();
                    osc2.type = 'sine'; osc2.frequency.value = melody[idx % melody.length] * 1.5;
                    g2.gain.value = 0;
                    osc2.connect(g2); g2.connect(gain); osc2.start();
                    g2.gain.linearRampToValueAtTime(0.04, now + 0.15);
                    g2.gain.linearRampToValueAtTime(0, now + 1.5);
                    setTimeout(() => osc2.stop(), 1800);
                    idx++;
                }, 800);
                nodes.push({ interval });
                return nodes;
            },

            lofi: (ctx, gain) => {
                const nodes = [];
                // Lo-fi: muffled chords + vinyl crackle simulation
                const chords = [[261.63, 329.63, 392.00], [246.94, 311.13, 369.99], [220.00, 277.18, 329.63]];
                let ci = 0;
                const interval = setInterval(() => {
                    chords[ci % chords.length].forEach(freq => {
                        const osc = ctx.createOscillator();
                        const g = ctx.createGain();
                        const filter = ctx.createBiquadFilter();
                        filter.type = 'lowpass'; filter.frequency.value = 800; // Muffled
                        osc.type = 'triangle'; osc.frequency.value = freq;
                        g.gain.value = 0;
                        osc.connect(filter); filter.connect(g); g.connect(gain); osc.start();
                        const now = ctx.currentTime;
                        g.gain.linearRampToValueAtTime(0.05, now + 0.1);
                        g.gain.linearRampToValueAtTime(0.04, now + 1.5);
                        g.gain.linearRampToValueAtTime(0, now + 2);
                        setTimeout(() => osc.stop(), 2200);
                    });
                    ci++;
                }, 2000);
                nodes.push({ interval });
                // Rain-like noise
                const bufferSize = ctx.sampleRate * 2;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.015;
                const src = ctx.createBufferSource();
                src.buffer = buffer; src.loop = true;
                const nf = ctx.createBiquadFilter();
                nf.type = 'bandpass'; nf.frequency.value = 2000;
                src.connect(nf); nf.connect(gain); src.start();
                nodes.push({ src });
                return nodes;
            },

            nature: (ctx, gain) => {
                const nodes = [];
                // Wind + birds simulation
                // Wind: filtered noise
                const bufferSize = ctx.sampleRate * 3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const wind = ctx.createBufferSource();
                wind.buffer = buffer; wind.loop = true;
                const wf = ctx.createBiquadFilter();
                wf.type = 'bandpass'; wf.frequency.value = 400; wf.Q.value = 0.5;
                const wg = ctx.createGain(); wg.gain.value = 0.08;
                wind.connect(wf); wf.connect(wg); wg.connect(gain); wind.start();
                nodes.push({ src: wind });
                // Bird chirps
                const chirp = () => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(2000 + Math.random() * 1000, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(2800 + Math.random() * 800, ctx.currentTime + 0.1);
                    g.gain.setValueAtTime(0, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 0.02);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.15);
                    o.connect(g); g.connect(gain); o.start();
                    setTimeout(() => o.stop(), 200);
                };
                const interval = setInterval(() => {
                    chirp();
                    if (Math.random() > 0.5) setTimeout(chirp, 150);
                }, 1500 + Math.random() * 3000);
                nodes.push({ interval });
                return nodes;
            }
        };

        const GENRE_LABELS = {
            mystery: 'Misterio oscuro', suspense: 'Suspenso tenso', drama: 'Drama cinematográfico',
            action: 'Acción intensa', fantasy: 'Fantasía mágica', romance: 'Romance suave',
            lofi: 'Lo-Fi + lluvia', nature: 'Naturaleza y viento'
        };

        // ── Freesound API key management ──
        let freesoundApiKey = localStorage.getItem('freesound_api_key') || 'JCXLtKvEpLo3DJTYy3pRIXEcEWMTLRWK3UEcJ5iD';

        function guardarApiKey() {
            const key = document.getElementById('freesound-api-key').value.trim();
            if (key) {
                freesoundApiKey = key;
                localStorage.setItem('freesound_api_key', key);
                document.getElementById('key-status').textContent = '✓ guardada';
                document.getElementById('freesound-api-key').value = '';
                setTimeout(() => document.getElementById('key-status').textContent = '', 2000);
            }
        }

        // Show key status on load
        window.addEventListener('DOMContentLoaded', () => {
            if (freesoundApiKey) {
                document.getElementById('key-status').textContent = '✓ configurada';
            }
        });

        // ── Freesound multi-query system con subtonos ──
        // Múltiples queries por género para mejor variedad y precisión
        const FREESOUND_QUERIES = {
            mystery: ['dark mystery ambient', 'noir detective atmosphere', 'eerie suspense drone', 'dark cinematic tension'],
            suspense: ['suspense thriller tension', 'psychological horror ambient', 'heartbeat tense atmosphere', 'chase scene cinematic'],
            drama: ['emotional piano ambient', 'cinematic sad orchestral', 'melancholy strings atmosphere', 'dramatic film score'],
            action: ['epic battle cinematic', 'intense action orchestral', 'war drums epic', 'adrenaline cinematic score'],
            fantasy: ['magical fantasy ambient', 'ethereal fantasy soundscape', 'enchanted forest music', 'epic fantasy orchestral'],
            romance: ['romantic piano soft', 'love theme gentle strings', 'tender romantic ambient', 'soft acoustic romance'],
            lofi: ['lofi hip hop chill', 'study music ambient beats', 'chill lofi background', 'jazzy lofi instrumental'],
            nature: ['forest nature ambient', 'rain birds peaceful', 'ocean waves relaxing', 'meditation nature sounds'],
            horror: ['horror dark ambient', 'scary atmosphere drone', 'creepy tension music', 'dark horror soundscape'],
            adventure: ['adventure epic journey', 'exploration cinematic', 'heroic adventure theme', 'discovery orchestral'],
        };

        // Análisis avanzado: detecta tono, intensidad y subtono del texto
        function analizarTextoDetallado(texto) {
            const lower = texto.toLowerCase().slice(0, 3000);
            const words = lower.split(/\s+/);
            const totalWords = words.length;

            // Función helper: cuenta ocurrencias por 1000 palabras (normalizado)
            const freq = (lista) => lista.reduce((s, w) => s + (lower.split(w).length - 1), 0) / totalWords * 1000;

            const scores = {
                mystery: freq(['misterio', 'enigma', 'sombra', 'oscuro', 'secreto', 'oculto', 'extraño', 'cadáver', 'crimen', 'investigar', 'pista', 'detecti', 'desapareció', 'cuerpo', 'asesino', 'veneno', 'conspiración']),
                suspense: freq(['tensión', 'peligro', 'trampa', 'amenaza', 'miedo', 'terror', 'acecho', 'perseguir', 'escapar', 'corazón', 'aceleró', 'tiempo', 'demasiado tarde', 'pistola', 'arma', 'disparó', 'huir', 'atrapado']),
                drama: freq(['llanto', 'lágrimas', 'dolor', 'sufrir', 'perder', 'traición', 'soledad', 'sacrificio', 'promesa', 'herida', 'culpa', 'perdón', 'familia', 'ruptura', 'pérdida', 'luto', 'desesperanza', 'fracasó']),
                action: freq(['combate', 'batalla', 'golpe', 'atacar', 'disparar', 'explotar', 'luchar', 'espada', 'victoria', 'enemigo', 'guerrero', 'sangre', 'herido', 'correr', 'saltar', 'velocidad', 'patada', 'puño', 'chocó']),
                fantasy: freq(['magia', 'hechizo', 'dragón', 'reino', 'elfo', 'mago', 'destino', 'profecía', 'criatura', 'portal', 'artefacto', 'encantamiento', 'espíritu', 'runa', 'hada', 'brujo', 'varita', 'conjuro', 'poción']),
                romance: freq(['amor', 'beso', 'mirada', 'suave', 'sentir', 'latir', 'ternura', 'abrazo', 'sonrisa', 'deseo', 'piel', 'suspirar', 'juntos', 'enamorar', 'cariño', 'corazón', 'acarició', 'besó', 'amaba']),
                lofi: freq(['estudiar', 'aprender', 'libro', 'notas', 'lección', 'conocimiento', 'teoría', 'análisis', 'investigación', 'datos', 'concepto', 'comprender', 'fórmula', 'clase', 'universidad', 'examen', 'trabajo']),
                nature: freq(['bosque', 'árbol', 'río', 'montaña', 'viento', 'lluvia', 'animal', 'campo', 'flor', 'tierra', 'cielo', 'amanecer', 'naturaleza', 'verde', 'agua', 'pájaro', 'mar', 'playa', 'selva', 'tormenta']),
                horror: freq(['horror', 'aterrador', 'monstruo', 'demonio', 'sangre', 'muerte', 'oscuridad', 'grito', 'pesadilla', 'fantasma', 'sombra', 'aparición', 'terror', 'carne', 'víscera', 'mutilado', 'cadáver', 'pudrir']),
                adventure: ['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'montaña', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio'].reduce ? freq(['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio']) : 0,
            };

            // Detectar intensidad general del texto
            const intensityWords = freq(['!', 'muy', 'enorme', 'increíble', 'absolutamente', 'completamente', 'jamás', 'nunca', 'siempre', 'desesperado', 'urgente']);
            const intensity = Math.min(intensityWords / 5, 1); // 0-1

            // Detectar ritmo (oraciones cortas = acción/suspenso, largas = drama/romance)
            const avgSentenceLen = lower.split(/[.!?]+/).filter(s => s.trim()).reduce((s, o) => s + o.split(' ').length, 0) / Math.max(lower.split(/[.!?]+/).length, 1);
            const isPaced = avgSentenceLen < 12; // oraciones cortas = más urgente

            // Ganador
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const winner = sorted[0][0];
            const runnerUp = sorted[1][0];
            const confidence = sorted[0][1] > 0 ? Math.min(sorted[0][1] / (sorted[1][1] + 0.1), 3) : 0;

            return { genre: winner, secondary: runnerUp, confidence, intensity, isPaced, scores };
        }

        let freesoundTrackUrl = null;
        let freesoundAudio = null;
        let _lastFreesoundResults = {};  // cache por género

        async function buscarEnFreesound(genre, subtono) {
            if (!freesoundApiKey) return null;

            // Elegir query: usar subtono si hay alta confianza, sino query principal
            const queries = FREESOUND_QUERIES[genre] || FREESOUND_QUERIES['mystery'];
            const queryStr = queries[Math.floor(Math.random() * queries.length)];

            // Cache: si ya tenemos resultados de este género, rotar entre ellos
            if (_lastFreesoundResults[genre] && _lastFreesoundResults[genre].length > 1) {
                const pool = _lastFreesoundResults[genre];
                const pick = pool[Math.floor(Math.random() * pool.length)];
                return pick;
            }

            const query = encodeURIComponent(queryStr);
            const url = `https://freesound.org/apiv2/search/text/?query=${query}&filter=duration:[60 TO 360]&fields=name,previews,duration,avg_rating&page_size=20&sort=rating_desc&token=${freesoundApiKey}`;

            try {
                const res = await fetch(url);
                if (!res.ok) {
                    if (res.status === 401) document.getElementById('key-status').textContent = '✗ key inválida';
                    return null;
                }
                const data = await res.json();
                if (data.results && data.results.length > 0) {
                    // Filtrar los mejores (rating > 3 o top 10)
                    const good = data.results
                        .filter(t => t.avg_rating >= 3 || data.results.indexOf(t) < 8)
                        .map(t => ({ url: t.previews['preview-hq-mp3'], name: t.name, duration: t.duration }));
                    _lastFreesoundResults[genre] = good;
                    return good[Math.floor(Math.random() * good.length)];
                }
            } catch (e) { console.warn('Freesound error:', e); }
            return null;
        }

        function toggleAmbientPanel() {
            const player = document.getElementById('ambient-player');
            const arrow = document.getElementById('ambient-arrow');
            player.classList.toggle('collapsed');
            arrow.textContent = player.classList.contains('collapsed') ? '▲' : '▼';
        }

        async function selectGenre(genre) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('genre-' + genre).classList.add('active');
            ambientGenre = genre;
            stopAmbient();
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando...';
            document.getElementById('ambient-track-genre').textContent = freesoundApiKey ? 'buscando en Freesound...' : 'generador local';
            // Clear cache for this genre so we get a fresh random track
            delete _lastFreesoundResults[genre];
            await playAmbient(genre);
        }

        async function playAmbient(genre) {
            const g = genre || ambientGenre;

            // Try Freesound first if key is available
            if (freesoundApiKey) {
                const track = await buscarEnFreesound(g, null);
                if (track) {
                    freesoundAudio = new Audio(track.url);
                    freesoundAudio.loop = true;
                    freesoundAudio.volume = ambientVolume;
                    freesoundAudio.crossOrigin = 'anonymous';
                    freesoundAudio.play().then(() => {
                        ambientPlaying = true;
                        document.getElementById('ambient-play-btn').textContent = '⏸';
                        document.getElementById('ambient-eq').classList.add('playing');
                        document.getElementById('ambient-track-name').textContent = track.name;
                        document.getElementById('ambient-track-genre').textContent = '♪ Freesound CC0';
                        document.getElementById('ambient-player').classList.add('ambient-playing');
                    }).catch(() => playAmbientLocal(g));
                    return;
                }
            }
            // Fallback: procedural
            playAmbientLocal(g);
        }

        function playAmbientLocal(genre) {
            const ctx = getAudioCtx();
            if (ctx.state === 'suspended') ctx.resume();
            ambientGainNode = ctx.createGain();
            ambientGainNode.gain.value = ambientVolume;
            ambientGainNode.connect(ctx.destination);
            const generator = GENRE_GENERATORS[genre || ambientGenre];
            if (!generator) return;
            ambientNodes = generator(ctx, ambientGainNode);
            ambientPlaying = true;
            document.getElementById('ambient-play-btn').textContent = '⏸';
            document.getElementById('ambient-eq').classList.add('playing');
            document.getElementById('ambient-track-name').textContent = GENRE_LABELS[genre];
            document.getElementById('ambient-track-genre').textContent = '♪ generado localmente';
            document.getElementById('ambient-player').classList.add('ambient-playing');
        }

        function stopAmbient() {
            // Stop Freesound audio
            if (freesoundAudio) {
                freesoundAudio.pause();
                freesoundAudio.src = '';
                freesoundAudio = null;
            }
            // Stop procedural nodes
            ambientNodes.forEach(n => {
                try { if (n.osc) n.osc.stop(); } catch (e) { }
                try { if (n.src) n.src.stop(); } catch (e) { }
                if (n.interval) clearInterval(n.interval);
            });
            ambientNodes = [];
            if (ambientGainNode) {
                try { ambientGainNode.disconnect(); } catch (e) { }
                ambientGainNode = null;
            }
            ambientPlaying = false;
            document.getElementById('ambient-play-btn').textContent = '▶';
            document.getElementById('ambient-eq').classList.remove('playing');
            document.getElementById('ambient-player').classList.remove('ambient-playing');
        }

        function toggleAmbientPlay() {
            if (!ambientGenre) {
                document.getElementById('ambient-track-name').textContent = '← Elige un género primero';
                return;
            }
            if (ambientPlaying) {
                // Pausar sin destruir el audio actual
                if (freesoundAudio && !freesoundAudio.paused) freesoundAudio.pause();
                ambientPlaying = false;
                const playBtn = document.getElementById('ambient-play-btn');
                if (playBtn) playBtn.textContent = '▶';
                document.getElementById('ambient-player').classList.remove('ambient-playing');
            } else {
                // Reanudar el audio existente; solo cargar uno nuevo si no hay nada
                if (freesoundAudio && freesoundAudio.src) {
                    freesoundAudio.play().catch(() => { });
                    ambientPlaying = true;
                    const playBtn = document.getElementById('ambient-play-btn');
                    if (playBtn) playBtn.textContent = '⏸';
                    document.getElementById('ambient-player').classList.add('ambient-playing');
                } else {
                    playAmbient(ambientGenre);
                }
            }
        }

        async function siguienteTrack() {
            if (!ambientGenre) return;
            stopAmbient();
            // Force new search (clear single-item cache)
            if (_lastFreesoundResults[ambientGenre]) {
                // Rotate: remove first item and re-search if empty
                _lastFreesoundResults[ambientGenre].shift();
                if (_lastFreesoundResults[ambientGenre].length === 0) {
                    delete _lastFreesoundResults[ambientGenre];
                }
            }
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando siguiente...';
            await playAmbient(ambientGenre);
        }

        function setAmbientVolume(val) {
            ambientVolume = val / 100;
            document.getElementById('ambient-vol-val').textContent = val + '%';
            if (ambientGainNode) ambientGainNode.gain.value = ambientVolume;
            if (freesoundAudio) freesoundAudio.volume = ambientVolume;
        }

        // detectarGeneroLocal reemplazado por analizarTextoDetallado arriba

        async function detectarGeneroConIA() {
            const texto = document.getElementById('texto-contenido').textContent.trim();
            if (!texto || texto.length < 100) {
                document.getElementById('ambient-track-name').textContent = 'Carga un capítulo primero';
                return;
            }

            const btn = document.getElementById('btn-detect-genre');
            btn.textContent = '⏳ Analizando...';
            btn.disabled = true;

            // Análisis local rico
            const analysis = analizarTextoDetallado(texto);
            const { genre, secondary, confidence, intensity, isPaced, scores } = analysis;

            // Mostrar top 3 en consola para debug
            const top3 = Object.entries(scores).sort((a, b) => b[1] - a[1]).slice(0, 3);
            console.log('🎵 Análisis de texto:', top3.map(([g, s]) => `${g}:${s.toFixed(2)}`).join(', '), '| intensidad:', intensity.toFixed(2), '| ritmo:', isPaced ? 'rápido' : 'lento');

            // Seleccionar género con subtono
            await selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced);

            btn.textContent = '✨ Detectar género del texto';
            btn.disabled = false;
        }

        async function selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('genre-' + genre);
            if (btn) btn.classList.add('active');
            ambientGenre = genre;
            stopAmbient();

            // Descripción de confianza
            const confLabel = confidence > 2 ? 'muy claro' : confidence > 1 ? 'probable' : 'leve';
            const rhythmLabel = isPaced ? 'ritmo rápido' : 'ritmo pausado';
            document.getElementById('ambient-track-name').textContent = '⏳ Buscando en Freesound...';
            document.getElementById('ambient-track-genre').textContent = `${GENRE_LABELS[genre]} · ${confLabel} · ${rhythmLabel}`;

            await playAmbient(genre);
        }
    </script>

    <script>
        // roundRect polyfill for browsers that don't support it
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                r = Math.min(r, w / 2, h / 2);
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
                return this;
            };
        }
    </script>
    <!-- ─── GRABACIÓN / VIDEO ─── -->
    <!-- video overlay -->
    <div id="video-overlay">
        <button id="video-close" onclick="cerrarvideo()">✕</button>
        <!-- Fondo IA: dos divs para crossfade via CSS, detrás del canvas -->
        <!-- Contenedor compartido: imagen de fondo + canvas alineados -->
        <div id="ai-bg-wrap" style="
            position:relative;
            width:min(900px,95vw);
            height:min(506px,53vw);
            flex-shrink:0;
        ">
            <div id="ai-bg-a" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <div id="ai-bg-b" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <!-- Overlay oscuro encima de la imagen para que el texto sea legible -->
            <div id="ai-bg-overlay" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background:rgba(8,7,6,0);
                transition:background 1s ease;
                pointer-events:none;
            "></div>
            <canvas id="video-canvas" width="1280" height="720" style="position:absolute;inset:0;width:100%;height:100%;z-index:1;background:transparent;border-radius:12px;"></canvas>

            <!-- Overlay de progreso de traducción: centrado sobre la pantalla del visor -->
            <div id="video-translation-progress" style="
                display:none;
                position:absolute;
                inset:0;
                z-index:10;
                flex-direction:column;
                align-items:center;
                justify-content:center;
                gap:10px;
                border-radius:12px;
                background:rgba(8,7,6,0.78);
                backdrop-filter:blur(3px);
            ">
                <span id="ktl-label" style="font-family:'DM Mono',monospace;font-size:0.82rem;color:var(--accent2);font-style:italic;letter-spacing:0.04em;">
                    Procesando capítulo...
                </span>
                <!-- Barra principal unificada -->
                <div style="width:62%;height:5px;background:var(--border);border-radius:4px;overflow:hidden;position:relative;">
                    <div id="ktl-fill" style="height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent2));border-radius:4px;transition:width 0.5s ease;"></div>
                </div>
                <!-- Indicadores de fases -->
                <div style="width:62%;display:flex;justify-content:space-between;font-family:'DM Mono',monospace;font-size:0.6rem;color:var(--text-dim);margin-top:-4px;">
                    <span id="ktl-f1" style="transition:color 0.3s;">① Traducción</span>
                    <span id="ktl-f2" style="transition:color 0.3s;">② Revisión</span>
                    <span id="ktl-f3" style="transition:color 0.3s;">③ Optimización</span>
                </div>
                <span id="ktl-pct" style="font-size:0.72rem;color:var(--text-muted);font-family:'DM Mono',monospace;">0%</span>
            </div>

            <!-- Panel lateral de índice de capítulos -->
            <div id="video-index-panel">
                <div id="video-index-header">📖 Capítulos</div>
                <input id="video-index-search" type="text" placeholder="Buscar capítulo..." oninput="filtrarIndicevideo(this.value)">
                <div id="video-index-list"></div>
            </div>
        </div>

        <!-- Barra de progreso tipo YouTube -->
        <div id="video-progress-wrap">
            <div id="video-seek-tooltip">...</div>
            <div id="video-progress-track"
                 onmouseenter="videoProgressHover(true)"
                 onmouseleave="videoProgressHover(false)"
                 onmousemove="videoProgressMouseMove(event)"
                 onclick="videoProgressSeek(event)">
                <div id="video-progress-fill">
                    <div id="video-progress-thumb"></div>
                </div>
            </div>
            <div id="video-progress-time">
                <span id="kp-chapter" style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:55%;opacity:0.7;">—</span>
                <span id="kp-current">0 / 0</span>
            </div>
        </div>

        <!-- Barra inferior principal -->
        <div class="video-bar">
            <!-- Izquierda: controles de música reordenados -->
            <div style="display:flex;align-items:center;gap:4px;flex-shrink:0;">
                <button class="kbtn kbtn-music" onclick="videoMusicaPrev()" title="Pista anterior">&#9664;</button>
                <button class="kbtn kbtn-music" id="kbtn-ambient-playpause" onclick="videoToggleAmbient()" title="Play/Pause música" style="font-size:0.7rem;padding:4px 6px;">&#9654;</button>
                <button class="kbtn kbtn-music" onclick="videoMusicaSiguiente()" title="Pista siguiente">&#9654;</button>
                <span id="video-music-label" style="font-size:0.58rem;color:var(--text-dim);font-family:'DM Mono',monospace;max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-left:4px;">♪</span>
                <button class="kbtn kbtn-music" id="kbtn-ambient-mute" onclick="toggleAmbientMute()" title="Silenciar/Activar música" style="font-size:0.75rem;padding:3px 6px;margin-left:2px;">🔊</button>
                <input type="range" id="kol-music-vol" min="0" max="100" value="15" step="5"
                       style="width:50px;accent-color:var(--accent2);cursor:pointer;vertical-align:middle;margin-left:4px;"
                       oninput="setAmbientVolume(this.value); document.getElementById('kol-music-pct').textContent=this.value+'%'">
                <span id="kol-music-pct" style="font-size:0.6rem;color:var(--text-dim);min-width:26px;">15%</span>
            </div>

            <!-- Centro: nav capítulos + play -->
            <div class="video-playbar">
                <button class="kbtn kbtn-nav" id="kbtn-prev" onclick="videoCapituloAnterior()" title="Capítulo anterior">&#9664;&#9664;</button>
                <button class="kbtn kbtn-play" id="kbtn-playpause" onclick="videoTogglePlay()" title="Play / Pausa">&#9654;</button>
                <button class="kbtn kbtn-nav" id="kbtn-next" onclick="videoCapituloSiguiente()" title="Capítulo siguiente">&#9654;&#9654;</button>
            </div>

            <!-- Derecha: volumen TTS + IA + exportar + fullscreen -->
            <div class="video-controls">
                <div style="display:flex;align-items:center;gap:3px;" title="Volumen voz">
                    <span style="font-size:0.7rem;">🗣</span>
                    <input type="range" id="kol-tts-vol" min="0" max="100" value="100" step="5"
                           style="width:55px;accent-color:var(--accent);cursor:pointer;vertical-align:middle;"
                           oninput="setTTSVolume(this.value); document.getElementById('kol-tts-pct').textContent=this.value+'%'">
                    <span id="kol-tts-pct" style="font-size:0.6rem;color:var(--text-dim);min-width:26px;">100%</span>
                </div>
                <button id="btn-toggle-ai-img" onclick="toggleAIImages()" title="Imágenes IA de fondo">🖼 IA</button>
                <button id="btn-toggle-index" onclick="togglevideoIndex()" title="Índice de capítulos">☰</button>
                <button id="btn-export-video" onclick="exportarVideo()" title="Exportar video">⬇</button>
                <button id="btn-cancel-export" onclick="cancelarExportacion()" style="display:none;" title="Cancelar exportación">✕</button>
                <button id="btn-fullscreen" onclick="toggleFullscreen()" title="Pantalla completa">⛶</button>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════
        // GRABACIÓN DE AUDIO (TTS + Música)
        // ═══════════════════════════════════════

        let mediaRecorder = null;
        let grabacionChunks = [];
        let grabando = false;
        let destinationNode = null;
        let audioCtxGrab = null;

        async function toggleGrabacion() {
            if (grabando) {
                detenerGrabacion();
            } else {
                iniciarGrabacion();
            }
        }

        async function iniciarGrabacion() {
            try {
                // Crear AudioContext compartido para mezclar TTS + música
                audioCtxGrab = getAudioCtx();

                const dest = audioCtxGrab.createMediaStreamDestination();
                destinationNode = dest;

                // Conectar música ambiental al stream de grabación
                if (ambientGainNode) ambientGainNode.connect(dest);

                // Para TTS del navegador necesitamos capturar el audio del sistema
                // Usamos un approach mixto: capturamos pantalla con audio del sistema
                let stream;
                try {
                    stream = await navigator.mediaDevices.getDisplayMedia({
                        video: false,
                        audio: { systemAudio: 'include' }
                    });
                    // Mezclar con la música del AudioContext
                    const sysSource = audioCtxGrab.createMediaStreamSource(stream);
                    sysSource.connect(dest);
                } catch (e) {
                    // Fallback: solo audio del AudioContext (música sin TTS si no hay permiso)
                    stream = dest.stream;
                    mostrarNotificacion('⚠ Solo se grabará la música (permite audio del sistema para incluir voz)');
                }

                // Combinar streams
                const tracks = [...dest.stream.getTracks()];
                if (stream && stream.getAudioTracks) {
                    stream.getAudioTracks().forEach(t => tracks.push(t));
                }
                const combinedStream = new MediaStream(tracks);

                grabacionChunks = [];
                mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'audio/webm' });
                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) grabacionChunks.push(e.data); };
                mediaRecorder.onstop = descargarAudio;
                mediaRecorder.start(100);

                grabando = true;
                const btn = document.getElementById('btn-rec-audio');
                btn.classList.add('recording');
                btn.querySelector('#rec-dot').textContent = '⏹';
                btn.childNodes[1].textContent = ' Detener grabación';
                mostrarNotificacion('🔴 Grabando...');

            } catch (e) {
                console.error('Error al iniciar grabación:', e);
                mostrarNotificacion('⚠ Error al iniciar grabación');
            }
        }

        function detenerGrabacion() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            grabando = false;
            const btn = document.getElementById('btn-rec-audio');
            btn.classList.remove('recording');
            btn.querySelector('#rec-dot').textContent = '⏺';
            btn.childNodes[1].textContent = ' Grabar audio';
            mostrarNotificacion('💾 Procesando audio...');
        }

        function descargarAudio() {
            const blob = new Blob(grabacionChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const capitulo = document.getElementById('current-chapter-title').textContent || 'lectura';
            a.download = `${capitulo.replace(/[^a-zA-Z0-9]/g, '_')}_audio.webm`;
            a.click();
            URL.revokeObjectURL(url);
            mostrarNotificacion('✓ Audio descargado');
        }

        // ═══════════════════════════════════════
        // video / VISTA SPOTIFY
        // ═══════════════════════════════════════

        let videoAnimFrame = null;
        let videoCanvas = null;
        let videoCtx = null;
        let videoRecorder = null;
        let videoChunks = [];
        let videoActive = false;

        const video_BG = '#0a0908';
        const video_TEXT_DIM = '#5a5248';
        const video_TEXT = '#e8e0d0';
        const video_HIGHLIGHT = '#c8a96e';
        const video_SECONDARY = 'rgba(200,169,110,0.3)';

        function abrirvideo() {
            const overlay = document.getElementById('video-overlay');
            overlay.classList.add('active');
            videoCanvas = document.getElementById('video-canvas');
            videoCtx = videoCanvas.getContext('2d');
            videoActive = true;
            // Ocultar el panel principal para que no se filtre detrás del overlay
            const mainPanel = document.querySelector('.main-panel');
            if (mainPanel) mainPanel.style.visibility = 'hidden';

            const capitulo = document.getElementById('current-chapter-title').textContent || 'Capítulo';


            // Reiniciar sistema de imágenes IA para el nuevo capítulo
            aiSlotSolicitado = {};
            aiCurrentSlot = -1;
            aiActivePanel = 'a';
            aiSlotActivo = false;
            aiLoadingSlot = null;
            document.getElementById('ai-bg-a').style.opacity = '0';
            document.getElementById('ai-bg-b').style.opacity = '0';
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
            if (aiImagesEnabled) {
                solicitarImagenParaSlot(0);
                solicitarImagenParaSlot(1);
            }

            rendervideoFrame();
            // Poblar el índice de capítulos y el título junto al contador
            poblarIndicevideo();
            const capEl = document.getElementById('kp-chapter');
            if (capEl) capEl.textContent = document.getElementById('current-chapter-title')?.textContent || '';
            _syncAmbientBtn();
            // Sincronizar sliders de volumen con los valores actuales
            setTimeout(() => document.dispatchEvent(new Event('videoOpened')), 100);
        }

        function cerrarvideo() {
            videoActive = false;
            document.getElementById('video-overlay').classList.remove('active');
            if (videoAnimFrame) cancelAnimationFrame(videoAnimFrame);
            if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop();
            // Restaurar visibilidad del panel principal
            const mainPanel = document.querySelector('.main-panel');
            if (mainPanel) mainPanel.style.visibility = '';
        }

        // Cerrar modo video con tecla Escape
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && videoActive) {
                cerrarvideo();
            }
        });

        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let line = '';
            for (const word of words) {
                const test = line ? line + ' ' + word : word;
                if (ctx.measureText(test).width > maxWidth && line) {
                    lines.push(line);
                    line = word;
                } else {
                    line = test;
                }
            }
            if (line) lines.push(line);
            return lines;
        }

        // Measures lines height for a text block
        function measureTextBlock(ctx, text, maxW, lineH) {
            return wrapText(ctx, text, maxW).length * lineH;
        }

        function drawvideoScene(ctx, W, H, current, total) {
            // Background: sólido si no hay imágenes IA, transparente si las hay
            if (aiImagesEnabled && aiSlotActivo) {
                ctx.clearRect(0, 0, W, H);
                // Overlay de viñeta leve sobre la imagen CSS
                ctx.fillStyle = 'rgba(8,7,6,0.35)';
                ctx.fillRect(0, 0, W, H);
            } else {
                ctx.fillStyle = video_BG;
                ctx.fillRect(0, 0, W, H);
            }

            // Vignette
            const vignette = ctx.createRadialGradient(W / 2, H / 2, H * 0.2, W / 2, H / 2, H * 0.85);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.65)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, W, H);

            // Header eliminado del canvas — título y contador se muestran bajo la barra de progreso exterior

            if (!sentences || total === 0) {
                ctx.fillStyle = video_TEXT_DIM;
                ctx.font = 'italic 26px "Georgia", serif';
                ctx.textAlign = 'center';
                ctx.fillText('Inicia la reproducción para ver el video', W / 2, H / 2);
                return;
            }

            const MAX_W = W * 0.78;
            const CX = W / 2;

            // ── Layout dinámico: calcular alturas reales antes de dibujar ──
            const PREV_SIZE = 22;
            const CUR_SIZE = 36;
            const NEXT_SIZE = 20;
            const PREV_LH = 32;
            const CUR_LH = 52;
            const NEXT_LH = 30;
            const GAP = 28; // espacio entre bloques

            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            const curLines = wrapText(ctx, sentences[current] || '', MAX_W);
            const curBlockH = curLines.length * CUR_LH;

            ctx.font = `${PREV_SIZE}px "Georgia", serif`;
            const prevLines = current > 0 ? wrapText(ctx, sentences[current - 1], MAX_W) : [];
            const prevBlockH = prevLines.length * PREV_LH;

            ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
            const nextLines = current < total - 1 ? wrapText(ctx, sentences[current + 1], MAX_W) : [];
            const nextBlockH = nextLines.length * NEXT_LH;

            // Área usable: todo el canvas (sin header ni footer en canvas)
            const USABLE_TOP = 28;
            const USABLE_BOT = H - 28;
            const USABLE_H = USABLE_BOT - USABLE_TOP;

            const totalH = prevBlockH + (prevLines.length ? GAP : 0)
                + curBlockH
                + (nextLines.length ? GAP : 0)
                + nextBlockH;

            // Start Y so the whole layout is vertically centered
            let startY = USABLE_TOP + (USABLE_H - totalH) / 2;
            startY = Math.max(startY, USABLE_TOP + 10);

            let drawY = startY;

            // Draw previous (dim, above)
            if (prevLines.length) {
                ctx.font = `${PREV_SIZE}px "Georgia", serif`;
                ctx.fillStyle = video_TEXT_DIM;
                ctx.textAlign = 'center';
                prevLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * PREV_LH);
                });
                drawY += prevBlockH + GAP;
            }

            // Draw current (highlighted, glow)
            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            ctx.textAlign = 'center';
            ctx.shadowColor = video_HIGHLIGHT;
            ctx.shadowBlur = 18;
            ctx.fillStyle = video_HIGHLIGHT;
            curLines.forEach((l, i) => {
                ctx.fillText(l, CX, drawY + i * CUR_LH);
            });
            ctx.shadowBlur = 0;
            drawY += curBlockH + GAP;

            // Draw next (very dim, below)
            if (nextLines.length) {
                ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
                ctx.fillStyle = 'rgba(200,169,110,0.22)';
                ctx.textAlign = 'center';
                nextLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * NEXT_LH);
                });
            }

            // Indicador de carga de imagen IA
            if (aiImagesEnabled && aiLoadingSlot !== null) {
                ctx.font = '11px "Courier New", monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(126,184,154,0.45)';
                ctx.fillText('✦ generando imagen con IA...', W - 18, H - 16);
            }
        }

        function rendervideoFrame() {
            if (!videoActive) return;
            drawvideoScene(videoCtx, videoCanvas.width, videoCanvas.height,
                currentSentenceIndex, sentences.length);
            videoAnimFrame = requestAnimationFrame(rendervideoFrame);
        }

        // ── Generación de video en segundo plano (sin grabar en tiempo real) ──
        // Dibuja cada frame del video a velocidad acelerada y los codifica
        let exportandoVideo = false;

        async function exportarVideo() {
            if (!sentences || sentences.length === 0) {
                mostrarNotificacion('Cargá y reproducí un capítulo primero');
                return;
            }
            if (exportandoVideo) { mostrarNotificacion('Ya hay una exportación en curso...'); return; }

            exportandoVideo = true;

            // Asegurar que el video esté abierto (necesitamos el canvas)
            if (!videoActive) abrirvideo();

            const W = videoCanvas.width;
            const H = videoCanvas.height;
            const FPS = 24;
            // Estimar duración: promedio de 3.5 segundos por oración
            const SEC_PER_SENTENCE = 3.5;
            const totalSec = sentences.length * SEC_PER_SENTENCE;
            const totalFrames = Math.ceil(totalSec * FPS);

            mostrarNotificacion(`⏳ Generando ${sentences.length} escenas... (${Math.ceil(totalSec)}s de video)`);


            // Usar un canvas offscreen para no interferir con la vista live
            const offCanvas = document.createElement('canvas');
            offCanvas.width = W; offCanvas.height = H;
            const offCtx = offCanvas.getContext('2d');

            // Capturar el stream del offscreen canvas
            const stream = offCanvas.captureStream(FPS);

            // Agregar audio ambiental al stream si está disponible
            if (ambientGainNode) {
                try {
                    const actx = getAudioCtx();
                    const audioDest = actx.createMediaStreamDestination();
                    ambientGainNode.connect(audioDest);
                    audioDest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                } catch (e) { }
            }

            videoChunks = [];
            const mimeType = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm']
                .find(m => MediaRecorder.isTypeSupported(m)) || 'video/webm';

            videoRecorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 });
            videoRecorder.ondataavailable = e => { if (e.data.size > 0) videoChunks.push(e.data); };
            videoRecorder.onstop = () => {
                const blob = new Blob(videoChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const cap = (document.getElementById('current-chapter-title').textContent || 'lectura').trim();
                a.download = `${cap.replace(/[^a-zA-Z0-9áéíóúñ ]/g, '_')}_video.webm`;
                a.click();
                URL.revokeObjectURL(url);
                exportandoVideo = false;
                document.getElementById('btn-export-video').style.display = 'inline';
                document.getElementById('btn-cancel-export').style.display = 'none';
                mostrarNotificacion('✓ Video generado y descargado');

            };

            videoRecorder.start();
            document.getElementById('btn-export-video').style.display = 'none';
            document.getElementById('btn-cancel-export').style.display = 'inline';

            // Renderizar frame a frame en segundo plano a mayor velocidad
            // ~4 frames por oración = transición suave sin que dure 30 min
            const FRAMES_PER_SENTENCE = FPS * SEC_PER_SENTENCE;
            let frameIdx = 0;

            const renderNext = () => {
                if (!exportandoVideo) { videoRecorder.stop(); return; }

                const sentenceIdx = Math.min(Math.floor(frameIdx / FRAMES_PER_SENTENCE), sentences.length - 1);
                const frameInSentence = frameIdx % FRAMES_PER_SENTENCE;
                const total = sentences.length;

                drawvideoScene(offCtx, W, H, sentenceIdx, total);

                // Transición suave: fade en los primeros/últimos frames de la oración
                if (frameInSentence < 8) {
                    const alpha = frameInSentence / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.7})`;
                    offCtx.fillRect(0, 0, W, H);
                } else if (frameInSentence > FRAMES_PER_SENTENCE - 8) {
                    const alpha = (FRAMES_PER_SENTENCE - frameInSentence) / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.5})`;
                    offCtx.fillRect(0, 0, W, H);
                }

                frameIdx++;

                // Progreso
                if (frameIdx % (FPS * 2) === 0) {
                    const pct = Math.round((frameIdx / totalFrames) * 100);

                }

                if (frameIdx >= totalFrames) {
                    // Último frame — pausa un momento y termina
                    setTimeout(() => videoRecorder.stop(), 300);
                    return;
                }

                // Usar setTimeout(0) para no bloquear el UI, pero ir rápido
                setTimeout(renderNext, 1000 / FPS / 4); // 4x más rápido que tiempo real
            };

            renderNext();
        }

        function cancelarExportacion() {
            exportandoVideo = false;
            if (videoRecorder && videoRecorder.state !== 'inactive') videoRecorder.stop();
            mostrarNotificacion('Exportación cancelada');
        }

        // ═══════════════════════════════════════
        // SISTEMA DE IMÁGENES IA — Claude + Pollinations.AI (model=flux)
        // ═══════════════════════════════════════

        let aiImagesEnabled = false;
        let aiSlotActivo = false;
        let aiLoadingSlot = null;
        let aiCurrentSlot = -1;
        let aiActivePanel = 'a';

        // Cambiar imagen cada ~280 chars acumulados (≈ 2-3 párrafos extensos)
        const AI_CHARS_PER_IMAGE = 280;
        let aiSlotSolicitado = {};
        let aiSentenceToSlot = [];   // idx oración → número de slot

        // Construir el mapa de slots basado en acumulación de chars reales
        function buildAiSlotMap() {
            aiSentenceToSlot = [];
            if (!sentences || sentences.length === 0) return;
            let slot = 0, chars = 0;
            for (let i = 0; i < sentences.length; i++) {
                aiSentenceToSlot[i] = slot;
                chars += sentences[i].length;
                if (chars >= AI_CHARS_PER_IMAGE) { slot++; chars = 0; }
            }
        }

        function getSlotForSentence(idx) {
            return (aiSentenceToSlot && aiSentenceToSlot[idx] !== undefined)
                ? aiSentenceToSlot[idx]
                : Math.floor(idx / 8);
        }

        // Fragmento de texto para un slot
        function extraerFragmentoParaSlot(slot) {
            if (!sentences || sentences.length === 0) return '';
            const idxs = aiSentenceToSlot
                .map((s, i) => s === slot ? i : -1)
                .filter(i => i >= 0);
            if (idxs.length === 0) return sentences.slice(0, 8).join(' ');
            // Incluir un poco de contexto previo para mejor coherencia
            const start = Math.max(0, idxs[0] - 3);
            const end = idxs[idxs.length - 1] + 1;
            return sentences.slice(start, end).join(' ');
        }

        // ── Detección automática del universo/libro ──
        let aiDetectedUniverse = null;

        const AI_UNIVERSES = {
            'shadow slave': 'Shadow Slave webnovel',
            'esclavo de las sombras': 'Shadow Slave webnovel',
            'forgotten shore': 'Shadow Slave webnovel',
            'guiltythree': 'Shadow Slave webnovel',
        };

        // Estilos base por universo detectado
        const AI_UNIVERSE_STYLES = {
            'Shadow Slave webnovel':
                'photorealistic dark fantasy, cinematic lighting, sharp focus, detailed stone and shadow environments, nightmarish eldritch corruption on physical surfaces, golden divine light cutting through darkness, realistic materials (worn stone, dark water, cracked obsidian), 8k render, no text no watermark',
        };

        const AI_DEFAULT_STYLE = 'photorealistic cinematic scene, detailed environment, dramatic lighting, sharp focus, 8k, no text no watermark, no abstract art';

        function detectarUniverso() {
            const fuentes = [
                document.getElementById('file-name')?.textContent || '',
                document.getElementById('current-chapter-title')?.textContent || '',
                (sentences || []).slice(0, 30).join(' ')
            ].join(' ').toLowerCase();

            aiDetectedUniverse = null;
            for (const [key, val] of Object.entries(AI_UNIVERSES)) {
                if (fuentes.includes(key)) {
                    aiDetectedUniverse = val;
                    console.log(`📚 Universo detectado: ${val}`);
                    mostrarNotificacion(`📚 Estilo visual: ${val}`);
                    break;
                }
            }
        }

        function getStyleTag() {
            if (aiDetectedUniverse && AI_UNIVERSE_STYLES[aiDetectedUniverse]) {
                return AI_UNIVERSE_STYLES[aiDetectedUniverse];
            }
            return AI_DEFAULT_STYLE;
        }

        function toggleAIImages() {
            aiImagesEnabled = !aiImagesEnabled;
            const btn = document.getElementById('btn-toggle-ai-img');
            if (aiImagesEnabled) {
                btn.classList.add('ai-active');
                btn.textContent = '🖼 IA ON';
                detectarUniverso();
                buildAiSlotMap();
                mostrarNotificacion('🖼 Imágenes IA activadas');
                aiSlotSolicitado = {};
                aiCurrentSlot = -1;
                aiActivePanel = 'a';
                const slot = getSlotForSentence(typeof currentSentenceIndex !== 'undefined' ? currentSentenceIndex : 0);
                solicitarImagenParaSlot(slot);
                setTimeout(() => solicitarImagenParaSlot(slot + 1), 800);
                setTimeout(() => solicitarImagenParaSlot(slot + 2), 1600);
            } else {
                btn.classList.remove('ai-active');
                btn.textContent = '🖼 IA Imágenes';
                document.getElementById('ai-bg-a').style.opacity = '0';
                document.getElementById('ai-bg-b').style.opacity = '0';
                document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
                aiSlotActivo = false;
                mostrarNotificacion('Imágenes IA desactivadas');
            }
        }

        // ── Cache de prompts ──
        const aiPromptCache = {};

        // Genera el prompt visual usando Pollinations GET API (sin CORS, sin key, sin POST)
        async function generarPromptConClaude(fragmento) {
            const cacheKey = fragmento.slice(0, 100);
            if (aiPromptCache[cacheKey]) return aiPromptCache[cacheKey];

            const styleTag = getStyleTag();
            const universeHint = aiDetectedUniverse
                ? `From webnovel "${aiDetectedUniverse}", match its visual style.`
                : '';

            // System prompt mejorado: escenas concretas, no abstractas
            const systemPrompt = `You are a cinematic scene prompt writer for AI image generation. ${universeHint} Given a fiction passage, write ONE English image generation prompt (max 70 words). Rules: describe a SPECIFIC concrete location with physical details (floor material, walls, sky, furniture, vegetation, etc.); include lighting direction and time of day; reference characters only as silhouettes or roles (e.g. "a lone figure in armor"); use PHOTOREALISTIC style, NOT abstract or symbolic; end with: "${styleTag}". Output ONLY the prompt, no preamble.`;

            // Texto del pasaje
            const pasaje = fragmento.slice(0, 350).replace(/"/g, "'");

            // Helper: detectar si el texto es el aviso de deprecación u otro error
            function esRespuestaInvalida(txt) {
                return !txt || txt.length < 20 ||
                    txt.includes('IMPORTANT NOTICE') ||
                    txt.includes('deprecated') ||
                    txt.includes('DEPRECATED') ||
                    txt.includes('please update') ||
                    txt.includes('Please update') ||
                    txt.toUpperCase().includes('NOTICE');
            }

            // Intentar con Pollinations (timeout corto para no bloquear)
            try {
                const ctrl = new AbortController();
                const timer = setTimeout(() => ctrl.abort(), 6000);
                const res = await fetch('https://text.pollinations.ai/openai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'mistral',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: pasaje }
                        ],
                        private: true,
                        seed: Math.floor(Math.random() * 9999)
                    }),
                    signal: ctrl.signal
                });
                clearTimeout(timer);
                if (res.ok) {
                    const data = await res.json();
                    let prompt = (data?.choices?.[0]?.message?.content || '').trim();
                    prompt = prompt.split('\n')[0].trim();
                    if (!esRespuestaInvalida(prompt)) {
                        aiPromptCache[cacheKey] = prompt;
                        console.log('Prompt (Pollinations/mistral):', prompt.slice(0, 80));
                        return prompt;
                    }
                }
            } catch (e) { /* timeout o error — usar prompt local */ }

            // Prompt local: extracción semántica sin LLM
            const promptLocal = construirPromptDirecto(fragmento, styleTag);
            aiPromptCache[cacheKey] = promptLocal;
            console.log('Prompt (local):', promptLocal.slice(0, 80));
            return promptLocal;
        }

        // Generador de prompts sin LLM — extrae entidades reales del texto
        function construirPromptDirecto(fragmento, styleTag) {
            const t = fragmento.toLowerCase();
            const parts = [];

            // — ESCENARIO concreto —
            if (/laboratorio|lab|experiment|científico|scientist/.test(t)) parts.push('underground science laboratory with metal tables, blinking monitors, tangled cables, concrete walls, harsh fluorescent overhead light');
            else if (/hospital|enfermería|nurse|médico|doctor|clínica/.test(t)) parts.push('hospital corridor with white tiled floor, rows of empty beds behind glass, sterile pale light from ceiling strips');
            else if (/prisión|celda|prison|jail|dungeon|calabozo/.test(t)) parts.push('stone dungeon cell with iron-bar door, straw on the floor, single torch on damp wall, dripping water');
            else if (/mansión|manor|palacio|palace|salón|hall/.test(t)) parts.push('grand manor hall with marble floor, high painted ceiling, dusty chandeliers, tall arched windows letting in grey light');
            else if (/bosque|selva|forest|jungle|árbol|tree/.test(t)) parts.push('dense ancient forest floor covered in moss and roots, shafts of green light filtering through a high forest canopy');
            else if (/ciudad|city|calle|street|edificio|building|urbano/.test(t)) parts.push('rain-soaked city street at night, puddles reflecting neon signs, towering concrete buildings with lit windows, narrow alley');
            else if (/castillo|fortress|torre|tower|muralla|castle/.test(t)) parts.push('castle ramparts at dusk, crumbling stone battlements, iron gate, orange sky behind distant mountains');
            else if (/cueva|cave|cavern|túnel|tunnel|underground/.test(t)) parts.push('vast underground cavern with stalactites, glowing blue fungi on wet stone walls, shallow dark water on the floor');
            else if (/desierto|wasteland|arena|sand|desert/.test(t)) parts.push('cracked desert plain under a blood-orange sky, bleached ruins half-buried in sand, no vegetation');
            else if (/mar|ocean|sea|costa|coast|playa|beach|puerto/.test(t)) parts.push('rocky ocean coastline during a storm, huge waves crashing on black cliffs, dark overcast sky, sea spray in the air');
            else if (/montaña|mountain|cumbre|peak|cliff|acantilado/.test(t)) parts.push('high mountain ridge shrouded in cloud, jagged grey rock face, snow patches, sheer drop into fog below');
            else if (/templo|temple|shrine|sanctuario|altar/.test(t)) parts.push('ancient stone temple interior, moss on carved columns, dusty sunlight beams through a collapsed ceiling, stone altar ahead');
            else if (/mercado|market|plaza|tavern|taberna|inn/.test(t)) parts.push('medieval cobblestone market square with wooden stalls, torches on iron poles, people gathered in wool cloaks');
            else if (/nave|spaceship|space|cosmos|espacio|galaxy/.test(t)) parts.push('interior of a derelict spaceship, exposed wiring on metal walls, emergency red lighting, stars visible through cracked viewport');
            else if (/habitación|cuarto|room|bedroom|dormitorio|estudio/.test(t)) parts.push('small stone room with a wooden table, candlelight casting warm shadows, simple bed against the wall, low ceiling');
            else parts.push('vast open landscape under dramatic sky, crumbled stone ruins in the middle distance, sparse dead trees, desolate');

            // — ACCIÓN / TENSIÓN concreta —
            if (/batalla|combate|fight|battle|lucha|clash|guerra|war/.test(t)) parts.push('aftermath of a battle, broken weapons on the ground, smoke rising, torn banners');
            else if (/huir|escape|chase|perseguir|run|correr/.test(t)) parts.push('someone fleeing through the scene, motion blur, urgent');
            else if (/ritual|ceremony|spell|hechizo|magia|magic/.test(t)) parts.push('ritual circle on the floor glowing faintly, candles arranged in a pattern');
            else if (/muerte|death|dead|matar|kill|sangre|blood/.test(t)) parts.push('ominous stillness, dark stain on the ground, scattered objects');
            else if (/silencio|quiet|alone|soledad|lonely/.test(t)) parts.push('a lone figure standing still in the distance');

            // — HORA Y LUZ directa —
            if (/amanecer|dawn|sunrise|alba/.test(t)) parts.push('early morning, cold pale blue and gold light on the horizon');
            else if (/atardecer|sunset|dusk|crepúsculo/.test(t)) parts.push('late afternoon, deep amber and orange light, long shadows on the ground');
            else if (/noche|night|midnight|medianoche|oscuridad/.test(t)) parts.push('night scene, moonlight casting silver shadows, deep dark sky');
            else if (/lluvia|rain|storm|tormenta|thunder|trueno/.test(t)) parts.push('heavy rain, water running on surfaces, lightning flash in background');
            else if (/fuego|fire|llama|flame|antorcha|torch/.test(t)) parts.push('warm firelight from below, orange and red flickering on walls');
            else parts.push('overcast daylight, soft diffused shadows, cool grey tones');

            return parts.join(', ') + ', ' + styleTag;
        }

        // URL de Pollinations — model=flux, parámetros documentados
        function pollinationsUrl(prompt, seed) {
            const encoded = encodeURIComponent(prompt);
            return `https://image.pollinations.ai/prompt/${encoded}?model=flux&width=1280&height=720&seed=${seed}&nologo=true&enhance=true&private=true`;
        }

        // ═══════════════════════════════════════
        // GENERADOR DE FONDOS PROCEDURAL (Canvas 2D)
        // Sin APIs externas — 100% local, instantáneo
        // ═══════════════════════════════════════

        // Paletas de colores por tipo de escena (derivadas del prompt construido localmente)
        const SCENE_PALETTES = {
            forest: { sky: ['#0a0f0a', '#0d1a0e', '#081208'], mid: ['#1a2e1a', '#0f2010'], fog: '#1a2a1a', stars: false },
            city: { sky: ['#050810', '#080c18', '#060a14'], mid: ['#0a1020', '#151c2e'], fog: '#0d1525', stars: true, neon: true },
            dungeon: { sky: ['#080608', '#100a08', '#0a0608'], mid: ['#1a1008', '#120c06'], fog: '#100808', stars: false },
            desert: { sky: ['#1a0a04', '#200c06', '#180a04'], mid: ['#2a1008', '#1e0c06'], fog: '#200a06', stars: false },
            ocean: { sky: ['#040810', '#06101a', '#040c16'], mid: ['#081428', '#0a1830'], fog: '#060e1e', stars: true },
            castle: { sky: ['#08060c', '#100810', '#0c060a'], mid: ['#180a18', '#140810'], fog: '#0e060c', stars: true },
            cave: { sky: ['#040408', '#060610', '#040408'], mid: ['#080820', '#060618'], fog: '#040412', stars: false, glow: true },
            temple: { sky: ['#0a0806', '#120e08', '#0e0a04'], mid: ['#1e160a', '#180e06'], fog: '#140c06', stars: false },
            space: { sky: ['#020206', '#04040c', '#020208'], mid: ['#06040e', '#080614'], fog: '#040410', stars: true, nebula: true },
            hospital: { sky: ['#080c0a', '#0a100c', '#060a08'], mid: ['#0e1410', '#0c120e'], fog: '#0a1008', stars: false },
            mansion: { sky: ['#080608', '#0e0a0c', '#0a0808'], mid: ['#160e12', '#120c10'], fog: '#100a0e', stars: false },
            default: { sky: ['#060608', '#080810', '#060608'], mid: ['#0c0c14', '#0a0a10'], fog: '#080810', stars: true },
        };

        // Detectar tipo de escena desde el prompt textual
        function detectarTipoEscena(prompt) {
            const t = prompt.toLowerCase();
            if (/forest|bosque|jungle|selva|tree|árbol|gnarled|ancient dark/.test(t)) return 'forest';
            if (/city|ciudad|urban|neon|asphalt|building|edificio|dystopian/.test(t)) return 'city';
            if (/dungeon|celda|prison|jail|stone|calabozo/.test(t)) return 'dungeon';
            if (/desert|wasteland|desierto|sand|arena|scorched/.test(t)) return 'desert';
            if (/ocean|sea|mar|coast|costa|wave|cliff/.test(t)) return 'ocean';
            if (/castle|fortress|castillo|battlement|raven/.test(t)) return 'castle';
            if (/cave|cavern|cueva|stalactite|bioluminescent|underground/.test(t)) return 'cave';
            if (/temple|altar|shrine|templo|pillar/.test(t)) return 'temple';
            if (/space|cosmos|nebula|starship|galaxy|espacio/.test(t)) return 'space';
            if (/hospital|clinic|corridor|fluorescent/.test(t)) return 'hospital';
            if (/mansion|manor|palace|palacio|hall|grand/.test(t)) return 'mansion';
            return 'default';
        }

        // Dibuja el fondo procedural en el div usando un canvas temporal
        function dibujarFondoProcedural(slot, prompt) {
            if (!aiImagesEnabled) return;

            const tipo = detectarTipoEscena(prompt);
            const pal = SCENE_PALETTES[tipo] || SCENE_PALETTES.default;
            const seed = slot * 113 + 7;
            const rng = (n => { let s = seed + n; return () => { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; }; })(0);

            // Crear canvas offscreen
            const W = 1280, H = 720;
            const cv = document.createElement('canvas');
            cv.width = W; cv.height = H;
            const c = cv.getContext('2d');

            // — Gradiente de cielo —
            const skyGrad = c.createLinearGradient(0, 0, 0, H * 0.65);
            skyGrad.addColorStop(0, pal.sky[0]);
            skyGrad.addColorStop(0.5, pal.sky[1]);
            skyGrad.addColorStop(1, pal.sky[2] || pal.sky[1]);
            c.fillStyle = skyGrad;
            c.fillRect(0, 0, W, H);

            // — Estrellas —
            if (pal.stars) {
                for (let i = 0; i < 180; i++) {
                    const x = rng() * W, y = rng() * H * 0.6;
                    const r = rng() * 1.2 + 0.3;
                    const alpha = rng() * 0.7 + 0.3;
                    c.beginPath();
                    c.arc(x, y, r, 0, Math.PI * 2);
                    c.fillStyle = `rgba(255,245,230,${alpha})`;
                    c.fill();
                }
            }

            // — Nebulosa (espacio) —
            if (pal.nebula) {
                for (let i = 0; i < 3; i++) {
                    const nx = rng() * W, ny = rng() * H * 0.5;
                    const nr = 80 + rng() * 120;
                    const colors = ['rgba(80,40,120,', 'rgba(40,60,120,', 'rgba(100,30,80,'];
                    const ng = c.createRadialGradient(nx, ny, 0, nx, ny, nr);
                    ng.addColorStop(0, colors[i % 3] + '0.18)');
                    ng.addColorStop(1, colors[i % 3] + '0)');
                    c.fillStyle = ng;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Luces de neón (ciudad) —
            if (pal.neon) {
                const neonColors = ['rgba(0,200,255,', 'rgba(255,50,150,', 'rgba(80,255,180,', 'rgba(255,180,0,'];
                for (let i = 0; i < 5; i++) {
                    const nx = rng() * W, ny = H * 0.4 + rng() * H * 0.3;
                    const nr = 30 + rng() * 60;
                    const col = neonColors[Math.floor(rng() * neonColors.length)];
                    const ng = c.createRadialGradient(nx, ny, 0, nx, ny, nr);
                    ng.addColorStop(0, col + '0.12)');
                    ng.addColorStop(1, col + '0)');
                    c.fillStyle = ng;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Brillo bioluminiscente (cueva) —
            if (pal.glow) {
                for (let i = 0; i < 8; i++) {
                    const gx = rng() * W, gy = H * 0.3 + rng() * H * 0.5;
                    const gr = 15 + rng() * 40;
                    const glowColors = ['rgba(80,180,255,', 'rgba(100,255,200,', 'rgba(160,100,255,'];
                    const col = glowColors[Math.floor(rng() * glowColors.length)];
                    const gg = c.createRadialGradient(gx, gy, 0, gx, gy, gr);
                    gg.addColorStop(0, col + '0.25)');
                    gg.addColorStop(1, col + '0)');
                    c.fillStyle = gg;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Siluetas de fondo (elementos medios) —
            const numShapes = 6 + Math.floor(rng() * 5);
            for (let i = 0; i < numShapes; i++) {
                const x = (i / numShapes) * W + (rng() - 0.5) * (W / numShapes);
                const baseH = H * (0.3 + rng() * 0.3);
                const w = W / numShapes * (0.6 + rng() * 0.8);
                const col = pal.mid[Math.floor(rng() * pal.mid.length)];

                if (tipo === 'forest') {
                    // Árboles
                    c.fillStyle = col;
                    c.beginPath();
                    c.moveTo(x, H);
                    c.lineTo(x - w * 0.5, baseH);
                    c.lineTo(x - w * 0.25, baseH + H * 0.08);
                    c.lineTo(x - w * 0.45, baseH - H * 0.1);
                    c.lineTo(x, baseH - H * 0.18);
                    c.lineTo(x + w * 0.45, baseH - H * 0.1);
                    c.lineTo(x + w * 0.25, baseH + H * 0.08);
                    c.lineTo(x + w * 0.5, baseH);
                    c.closePath();
                    c.fill();
                } else if (tipo === 'city') {
                    // Rascacielos
                    const bW = w * 0.5 + rng() * w * 0.4;
                    const bH = baseH + rng() * H * 0.2;
                    c.fillStyle = col;
                    c.fillRect(x - bW / 2, bH, bW, H - bH);
                    // Ventanas
                    c.fillStyle = rng() > 0.7 ? 'rgba(255,220,100,0.15)' : 'rgba(100,180,255,0.08)';
                    for (let wy = bH + 8; wy < H - 10; wy += 14) {
                        for (let wx = x - bW / 2 + 5; wx < x + bW / 2 - 5; wx += 10) {
                            if (rng() > 0.4) c.fillRect(wx, wy, 5, 7);
                        }
                    }
                } else if (tipo === 'castle' || tipo === 'mansion') {
                    // Torres
                    const tW = w * 0.4;
                    c.fillStyle = col;
                    c.fillRect(x - tW / 2, baseH, tW, H - baseH);
                    // Almenas
                    for (let m = x - tW / 2; m < x + tW / 2; m += tW / 3) {
                        c.fillRect(m, baseH - H * 0.05, tW / 4, H * 0.05);
                    }
                } else {
                    // Forma genérica: colina/roca
                    c.fillStyle = col;
                    c.beginPath();
                    c.moveTo(x - w * 0.7, H);
                    c.quadraticCurveTo(x, baseH, x + w * 0.7, H);
                    c.closePath();
                    c.fill();
                }
            }

            // — Niebla / bruma en el suelo —
            const fogGrad = c.createLinearGradient(0, H * 0.65, 0, H);
            fogGrad.addColorStop(0, pal.fog + '00');
            fogGrad.addColorStop(0.4, pal.fog + 'aa');
            fogGrad.addColorStop(1, pal.fog + 'ff');
            c.fillStyle = fogGrad;
            c.fillRect(0, H * 0.55, W, H * 0.45);

            // — Viñeta dramática en los bordes —
            const vig = c.createRadialGradient(W / 2, H / 2, H * 0.2, W / 2, H / 2, H * 0.9);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.72)');
            c.fillStyle = vig;
            c.fillRect(0, 0, W, H);

            // Convertir a data URL y mostrar como fondo
            const dataUrl = cv.toDataURL('image/jpeg', 0.88);
            mostrarImagenEnPanel(slot, dataUrl);
            console.log(`🎨 Fondo procedural generado — slot ${slot} (${tipo})`);
        }

        async function cargarImagenConFallback(prompt, seed, slot) {
            // Generación local instantánea — sin APIs externas, sin CORS, sin queue
            dibujarFondoProcedural(slot, prompt);
        }

        async function solicitarImagenParaSlot(slot) {
            if (slot < 0 || aiSlotSolicitado[slot]) return;
            aiSlotSolicitado[slot] = true;
            if (aiLoadingSlot === null) aiLoadingSlot = slot;

            const fragmento = extraerFragmentoParaSlot(slot);
            if (!fragmento) { if (aiLoadingSlot === slot) aiLoadingSlot = null; return; }

            console.log(`🧠 Generando prompt — slot ${slot}`);
            const prompt = await generarPromptConClaude(fragmento);
            const seed = slot * 113 + 7;
            cargarImagenConFallback(prompt, seed, slot);
        }

        function mostrarImagenEnPanel(slot, url) {
            if (!aiImagesEnabled) return;

            const panelAct = aiActivePanel === 'a' ? 'ai-bg-a' : 'ai-bg-b';
            const panelPrev = aiActivePanel === 'a' ? 'ai-bg-b' : 'ai-bg-a';
            const divAct = document.getElementById(panelAct);
            const divPrev = document.getElementById(panelPrev);

            if (slot === aiCurrentSlot) return;

            divAct.style.backgroundImage = `url("${url}")`;
            divAct.style.opacity = '1';
            divPrev.style.opacity = '0';
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0.48)';
            aiActivePanel = aiActivePanel === 'a' ? 'b' : 'a';
            aiCurrentSlot = slot;
            aiSlotActivo = true;
        }

        // Se llama en cada cambio de oración desde main.js
        function actualizarSlideAI(sentenceIdx) {
            if (!aiImagesEnabled) return;

            const slotActual = getSlotForSentence(sentenceIdx);
            solicitarImagenParaSlot(slotActual);

            // Pre-cargar slots siguientes con delay escalonado para no saturar APIs
            // Slot+1: empezar cuando slot actual ya está en cola (800ms)
            // Slot+2: solo si los anteriores ya están procesando (1600ms)
            setTimeout(() => solicitarImagenParaSlot(slotActual + 1), 800);
            setTimeout(() => solicitarImagenParaSlot(slotActual + 2), 1600);
        }

        // ═══════════════════════════════════════
        // CONTROLES DE MODO VIDEO (play/pause + nav capítulos)
        // ═══════════════════════════════════════

        function videoTogglePlay() {
            const btn = document.getElementById('kbtn-playpause');
            if (!isReading || isPaused) {
                // Si nunca se inició o está pausado → iniciar/reanudar
                if (!isReading) {
                    iniciarTTS();
                } else {
                    reanudarTTS();
                    // Reanudar audio ambiental si estaba sonando antes de la pausa
                    if (typeof freesoundAudio !== 'undefined' && freesoundAudio && freesoundAudio.paused) {
                        freesoundAudio.play().catch(() => { });
                    }
                }
                btn.innerHTML = '⏸'; // pausa
                btn.classList.remove('paused');
            } else {
                pausarTTS();
                // Pausar también el audio ambiental
                if (typeof freesoundAudio !== 'undefined' && freesoundAudio && !freesoundAudio.paused) {
                    freesoundAudio.pause();
                }
                btn.innerHTML = '&#9654;'; // play
                btn.classList.add('paused');
            }
        }

        // Sincronizar el ícono del botón cuando el TTS se detiene/pausa desde afuera
        const _origDetenerTTS = window.detenerTTS;
        window.detenerTTS = function () {
            if (typeof _origDetenerTTS === 'function') _origDetenerTTS();
            const btn = document.getElementById('kbtn-playpause');
            if (btn) { btn.innerHTML = '&#9654;'; btn.classList.remove('paused'); }
        };

        function _getChapterOptions() {
            return Array.from(document.getElementById('chapters').options)
                .filter(o => !o.disabled && o.value);
        }

        // Obtiene el texto real de un capítulo (sin cargarlo en pantalla)
        async function _getChapterText(ruta) {
            if (!ruta || typeof archivosHTML === 'undefined' || !archivosHTML[ruta]) return '';
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(archivosHTML[ruta], 'text/html');
                const body = doc.body.cloneNode(true);
                body.querySelectorAll('script, style, nav, header, footer').forEach(el => el.remove());
                let texto = '';
                body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, div').forEach(el => {
                    const t = el.innerText ? el.innerText.trim() : '';
                    if (t.length > 0) texto += t + ' ';
                });
                return texto.trim();
            } catch { return ''; }
        }

        async function videoNavegar(direccion) {
            const sel = document.getElementById('chapters');
            const opts = _getChapterOptions();
            let idx = opts.findIndex(o => o.value === sel.value);
            if (idx === -1) return;

            const MAX_SKIP = 20;
            let intentos = 0;

            while (intentos < MAX_SKIP) {
                idx += direccion;
                if (idx < 0) { mostrarNotificacion('Ya estás en el primer capítulo'); return; }
                if (idx >= opts.length) { mostrarNotificacion('Ya estás en el último capítulo'); return; }

                const texto = await _getChapterText(opts[idx].value);
                if (texto.length > 30) break;
                console.log(`Capítulo sin texto: ${opts[idx].text}, saltando...`);
                intentos++;
            }

            if (intentos >= MAX_SKIP) { mostrarNotificacion('No se encontró capítulo con contenido'); return; }

            // Actualizar selector
            if (typeof _cargandoProgramaticamente !== 'undefined') window._cargandoProgramaticamente = true;
            sel.value = opts[idx].value;
            window._cargandoProgramaticamente = false;

            // Actualizar título en el visor inmediatamente
            const optSel = opts[idx];
            if (optSel) {
                const titleEl = document.getElementById('current-chapter-title');
                if (titleEl) titleEl.textContent = optSel.textContent;
                const capEl = document.getElementById('kp-chapter');
                if (capEl) capEl.textContent = optSel.textContent;
            }

            detenerTTS();
            actualizarIndicevideo();
            window._navegacionIntencionada = true;
            await cargarCapitulo(opts[idx].value);
        }

        function videoCapituloAnterior() { videoNavegar(-1); }
        function videoCapituloSiguiente() { videoNavegar(1); }

        // ═══════════════════════════════════════
        // PANEL DE ÍNDICE DE CAPÍTULOS EN MODO VIDEO
        // ═══════════════════════════════════════

        function togglevideoIndex() {
            const panel = document.getElementById('video-index-panel');
            const btn = document.getElementById('btn-toggle-index');
            panel.classList.toggle('open');
            btn.style.color = panel.classList.contains('open') ? 'var(--accent)' : '';
        }

        function poblarIndicevideo() {
            const lista = document.getElementById('video-index-list');
            if (!lista) return;
            const opts = _getChapterOptions();
            lista.innerHTML = '';
            opts.forEach((opt, i) => {
                const item = document.createElement('div');
                item.className = 'video-index-item';
                item.dataset.value = opt.value;
                item.textContent = opt.text || `Capítulo ${i + 1}`;
                item.title = opt.text;
                item.onclick = () => {
                    window._cargandoProgramaticamente = true;
                    document.getElementById('chapters').value = opt.value;
                    window._cargandoProgramaticamente = false;
                    detenerTTS();
                    actualizarIndicevideo();
                    // Mostrar botón Aplicar si hay procesamiento configurado
                    const hayProcesamiento = (typeof traduccionAutomatica !== 'undefined' && traduccionAutomatica)
                        || (typeof ttsHumanizerActivo !== 'undefined' && ttsHumanizerActivo);
                    if (hayProcesamiento) {
                        const row = document.getElementById('aplicar-row');
                        const hint = document.getElementById('aplicar-hint');
                        if (row) row.style.display = 'block';
                        if (hint) hint.textContent = 'Nuevo capítulo — presiona Aplicar para procesar';
                        if (typeof _configPendiente !== 'undefined') window._configPendiente = true;
                    }
                    cargarCapitulo(opt.value);
                };
                lista.appendChild(item);
            });
            actualizarIndicevideo();
        }

        function actualizarIndicevideo() {
            const sel = document.getElementById('chapters');
            if (!sel) return;
            document.querySelectorAll('.video-index-item').forEach(item => {
                item.classList.toggle('active', item.dataset.value === sel.value);
            });
            // Scroll al item activo
            const active = document.querySelector('.video-index-item.active');
            if (active) active.scrollIntoView({ block: 'nearest' });
        }

        function filtrarIndicevideo(q) {
            const lower = q.toLowerCase();
            document.querySelectorAll('.video-index-item').forEach(item => {
                item.style.display = item.textContent.toLowerCase().includes(lower) ? '' : 'none';
            });
        }

        // Poblar índice cuando se carguen los capítulos y al abrir el modo video
        const _chaptersObserverIdx = new MutationObserver(() => poblarIndicevideo());
        _chaptersObserverIdx.observe(document.getElementById('chapters'), { childList: true });

        // Hook: actualizar item activo cuando cambia el selector de capítulos
        document.getElementById('chapters').addEventListener('change', () => actualizarIndicevideo());


        // ═══════════════════════════════════════
        // CONTROLES DE MÚSICA DESDE MODO VIDEO
        // ═══════════════════════════════════════

        const GENRE_ORDER = ['mystery', 'suspense', 'drama', 'action', 'fantasy', 'romance', 'lofi', 'nature'];

        function _genreIdx() {
            return ambientGenre ? GENRE_ORDER.indexOf(ambientGenre) : -1;
        }

        async function videoMusicaSiguiente() {
            const idx = _genreIdx();
            const next = GENRE_ORDER[(idx + 1) % GENRE_ORDER.length];
            await selectGenre(next);
            _actualizarMusicLabel();
        }

        async function videoMusicaPrev() {
            const idx = _genreIdx();
            const prev = GENRE_ORDER[(idx - 1 + GENRE_ORDER.length) % GENRE_ORDER.length];
            await selectGenre(prev);
            _actualizarMusicLabel();
        }

        function videoToggleAmbient() {
            if (typeof toggleAmbientPlay === 'function') toggleAmbientPlay();
            _syncAmbientBtn();
        }

        function _syncAmbientBtn() {
            const btn = document.getElementById('kbtn-ambient-playpause');
            if (!btn) return;
            // ambientPlaying viene del scope de audio ambiental
            const playing = typeof ambientPlaying !== 'undefined' ? ambientPlaying : true;
            btn.innerHTML = playing ? '⏸' : '&#9654;';
            btn.title = playing ? 'Pausar música' : 'Reproducir música';
        }

        function _actualizarMusicLabel() {
            const lbl = document.getElementById('video-music-label');
            if (!lbl) return;
            const trackName = document.getElementById('ambient-track-name');
            lbl.textContent = trackName ? trackName.textContent : (ambientGenre || '♪');
            _syncAmbientBtn(); // también sincronizar el botón
        }

        // Sincronizar label de música cuando cambia el track
        const _origAmbientTrackName = Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
        setInterval(_actualizarMusicLabel, 2000); // sync pasivo cada 2s

        // ═══════════════════════════════════════
        // BUSCADOR DE CAPÍTULOS
        // ═══════════════════════════════════════

        // Guardar todas las opciones originales una vez cargado el EPUB
        let _todasLasOpciones = [];

        // Observer para capturar las opciones cuando se populan
        const _chaptersObserver = new MutationObserver(() => {
            const opts = _getChapterOptions();
            if (opts.length > 0) _todasLasOpciones = opts.map(o => ({ value: o.value, text: o.textContent }));
        });
        _chaptersObserver.observe(document.getElementById('chapters'), { childList: true });

        function filtrarCapitulos(query) {
            const sel = document.getElementById('chapters');
            const q = query.trim().toLowerCase();

            // Si no hay snapshot aún, tomarlo ahora
            if (_todasLasOpciones.length === 0) {
                _todasLasOpciones = _getChapterOptions().map(o => ({ value: o.value, text: o.textContent }));
            }

            // Restaurar todas las opciones y luego ocultar las que no coinciden
            // (los <option> no tienen display, así que se re-renderizan)
            const valorActual = sel.value;
            window._cargandoProgramaticamente = true;
            sel.innerHTML = '';

            const filtradas = q
                ? _todasLasOpciones.filter(o => o.text.toLowerCase().includes(q))
                : _todasLasOpciones;

            if (filtradas.length === 0) {
                const empty = document.createElement('option');
                empty.disabled = true;
                empty.textContent = '— sin resultados —';
                sel.appendChild(empty);
                window._cargandoProgramaticamente = false;
                return;
            }

            filtradas.forEach(({ value, text }) => {
                const opt = document.createElement('option');
                opt.value = value;
                opt.textContent = text;
                if (value === valorActual) opt.selected = true;
                sel.appendChild(opt);
            });
            window._cargandoProgramaticamente = false;
        }

        // ═══════════════════════════════════════
        // PANTALLA COMPLETA
        // ═══════════════════════════════════════
        function toggleFullscreen() {
            const btn = document.getElementById('btn-fullscreen');
            if (!document.fullscreenElement) {
                // Fullscreen en documentElement para evitar congelamiento del navegador
                document.documentElement.requestFullscreen().then(() => {
                    btn.innerHTML = '&#x29C9;';
                    btn.title = 'Salir de pantalla completa';
                }).catch(e => console.warn('Fullscreen error:', e.message));
            } else {
                document.exitFullscreen().catch(() => { });
            }
        }
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('btn-fullscreen');
            if (!btn) return;
            if (!document.fullscreenElement) {
                btn.textContent = '⛶';
                btn.title = 'Pantalla completa';
            }
        });

        // ═══════════════════════════════════════
        // VOLUMEN TTS INDEPENDIENTE
        // ═══════════════════════════════════════
        function setTTSVolume(val) {
            const v = parseFloat(val) / 100;
            // Aplicar al audio local (XTTS API)
            if (typeof audioActual !== 'undefined' && audioActual) {
                audioActual.volume = v;
            }
            // Sincronizar con el control de volumen principal del sidebar
            const mainVol = document.getElementById('volume-control');
            if (mainVol) {
                mainVol.value = val;
                const lbl = document.getElementById('volume-value');
                if (lbl) lbl.textContent = val;
            }
        }
        // Sincronizar sliders al abrir el modo video
        document.addEventListener('videoOpened', () => {
            const vol = document.getElementById('volume-control');
            if (vol) {
                const v = vol.value;
                const ttsSlider = document.getElementById('kol-tts-vol');
                const ttsPct = document.getElementById('kol-tts-pct');
                if (ttsSlider) ttsSlider.value = v;
                if (ttsPct) ttsPct.textContent = v + '%';
            }
            const ambVol = document.getElementById('ambient-volume');
            if (ambVol) {
                const av = ambVol.value;
                const musicSlider = document.getElementById('kol-music-vol');
                const musicPct = document.getElementById('kol-music-pct');
                if (musicSlider) musicSlider.value = av;
                if (musicPct) musicPct.textContent = av + '%';
            }
        });

        // ═══════════════════════════════════════
        // AUTO-SIGUIENTE PISTA DE MÚSICA
        // ═══════════════════════════════════════
        async function _onTrackEnded() {
            console.log('🎵 Pista terminada — cargando siguiente...');
            if (typeof ambientGenre !== 'undefined' && ambientGenre) {
                await siguienteTrack();
            }
        }
        // Vigilar freesoundAudio para enganchar el evento 'ended'
        let _lastHookedAudio = null;
        setInterval(() => {
            if (typeof freesoundAudio !== 'undefined' && freesoundAudio && freesoundAudio !== _lastHookedAudio) {
                _lastHookedAudio = freesoundAudio;
                freesoundAudio.loop = false;  // Desactivar loop para que dispare 'ended'
                freesoundAudio.addEventListener('ended', _onTrackEnded);
                console.log('🎵 Auto-next enganchado al track actual');
            }
        }, 1000);

    </script>

    <script>
        // ═══════════════════════════════════════════════════════
        // BARRA DE PROGRESO TIPO YOUTUBE EN video
        // ═══════════════════════════════════════════════════════

        // Actualizar barra de progreso del video
        function updatevideoProgress() {
            if (typeof sentences === 'undefined' || sentences.length === 0) return;
            const total = sentences.length;
            const current = (typeof currentSentenceIndex !== 'undefined') ? currentSentenceIndex : 0;
            const pct = ((current + 1) / total) * 100;

            document.getElementById('video-progress-fill').style.width = pct + '%';
            document.getElementById('kp-current').textContent = `Frase ${current + 1} / ${total}`;
            // Actualizar título de capítulo junto al contador
            const capEl = document.getElementById('kp-chapter');
            if (capEl) {
                const titulo = document.getElementById('current-chapter-title')?.textContent || '';
                capEl.textContent = titulo;
            }
        }

        // Hover: mostrar/ocultar thumb
        function videoProgressHover(entering) {
            const track = document.getElementById('video-progress-track');
            if (!entering) {
                document.getElementById('video-seek-tooltip').classList.remove('visible');
            }
        }

        // Mouse move: mostrar tooltip con preview del texto
        function videoProgressMouseMove(e) {
            if (typeof sentences === 'undefined' || sentences.length === 0) return;

            const track = document.getElementById('video-progress-track');
            const tooltip = document.getElementById('video-seek-tooltip');
            const rect = track.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const idx = Math.floor(pct * sentences.length);
            const clampedIdx = Math.min(idx, sentences.length - 1);

            // Truncar texto del tooltip
            let preview = sentences[clampedIdx] || '';
            if (preview.length > 120) preview = preview.slice(0, 117) + '...';

            tooltip.textContent = `[${clampedIdx + 1}/${sentences.length}]\n${preview}`;
            tooltip.classList.add('visible');

            // Posicionar el tooltip horizontalmente siguiendo el cursor
            const trackRelX = e.clientX - rect.left;
            const tooltipHalf = 110; // aproximado a la mitad del max-width
            let left = trackRelX;
            // Evitar que salga por los bordes
            left = Math.max(tooltipHalf, Math.min(rect.width - tooltipHalf, left));
            tooltip.style.left = left + 'px';
        }

        // Click en la barra: hacer seek a esa posición
        function videoProgressSeek(e) {
            if (typeof sentences === 'undefined' || sentences.length === 0) return;

            const track = document.getElementById('video-progress-track');
            const rect = track.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const idx = Math.min(Math.floor(pct * sentences.length), sentences.length - 1);

            document.getElementById('video-seek-tooltip').classList.remove('visible');

            // Llamar la función de seek existente del TTS
            if (typeof detenerTTSSinEstado === 'function') {
                detenerTTSSinEstado();
            } else if (typeof window.speechSynthesis !== 'undefined') {
                window.speechSynthesis.cancel();
            }
            if (typeof leerOracion === 'function') {
                leerOracion(idx);
            }
        }

        // Seek desde la barra de progreso del panel lateral (implementación)
        function seekTTS(e) {
            if (typeof sentences === 'undefined' || sentences.length === 0) return;
            const track = e.currentTarget;
            const rect = track.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const idx = Math.min(Math.floor(pct * sentences.length), sentences.length - 1);
            if (typeof window.speechSynthesis !== 'undefined') window.speechSynthesis.cancel();
            if (typeof leerOracion === 'function') leerOracion(idx);
        }

        // Hook: sobreescribir actualizarProgreso para también actualizar la barra del video
        const _origActualizarProgreso = typeof actualizarProgreso === 'function' ? actualizarProgreso : null;
        window.actualizarProgreso = function () {
            if (_origActualizarProgreso) _origActualizarProgreso();
            updatevideoProgress();
        };

        // ═══════════════════════════════════════════════════════
        // BARRA DE PROGRESO DE TRADUCCIÓN → solo en overlay video
        // ═══════════════════════════════════════════════════════

        // Observar cambios en el texto-contenido para detectar el mensaje de "Traduciendo"
        // y redirigir al overlay del video (el reading-area ya no tiene barra propia)
        let _tcObserverActivo = true;
        const _tcObserver = new MutationObserver(() => {
            if (!_tcObserverActivo) return;
            const tc = document.getElementById('texto-contenido');
            if (!tc) return;
            const txt = tc.textContent.trim();
            // Solo actuar si el texto es ÚNICAMENTE el mensaje de traducción (no el texto final)
            if (txt === 'Traduciendo capítulo...' || (txt.startsWith('Traduciendo') && txt.length < 50)) {
                _tcObserverActivo = false;
                tc.innerHTML = '';
                _tcObserverActivo = true;
                const kWrap = document.getElementById('video-translation-progress');
                if (kWrap) kWrap.style.display = 'flex';
            }
        });
        const _tcEl = document.getElementById('texto-contenido');
        if (_tcEl) _tcObserver.observe(_tcEl, { childList: true, subtree: true, characterData: true });

    </script>

    <script>
        // ═══════════════════════════════════════════════════════
        // SUBIR ELEMENTO DE MÚSICA CUANDO HAY BARRA DE PROCESAMIENTO
        // ═══════════════════════════════════════════════════════
        (function () {
            const processingBar = document.getElementById('main-processing-bar');
            const ambientPlayer = document.getElementById('ambient-player');
            const progressWrap = document.querySelector('.progress-wrap');
            if (!processingBar) return;

            const observer = new MutationObserver(() => {
                const visible = processingBar.style.display !== 'none' && processingBar.style.display !== '';
                if (ambientPlayer) ambientPlayer.classList.toggle('processing-raised', visible);
                if (progressWrap) progressWrap.classList.toggle('processing-hidden', visible);
            });
            observer.observe(processingBar, { attributes: true, attributeFilter: ['style'] });
        })();

        (function () {
            var _t = null;

            function _overlayVisible() {
                var o = document.getElementById('video-overlay');
                return !!(o && o.classList.contains('active'));
            }

            function hideControls() {
                var bar = document.querySelector('.video-bar');
                var wrap = document.getElementById('video-progress-wrap');
                if (bar) { bar.style.opacity = '0'; bar.style.pointerEvents = 'none'; }
                if (wrap) { wrap.style.opacity = '0.3'; wrap.style.pointerEvents = ''; }
            }

            function showControls() {
                var bar = document.querySelector('.video-bar');
                var wrap = document.getElementById('video-progress-wrap');
                if (bar) { bar.style.opacity = '1'; bar.style.pointerEvents = ''; }
                if (wrap) { wrap.style.opacity = '1'; wrap.style.pointerEvents = ''; }
                if (_t) clearTimeout(_t);
                // Siempre ocultar tras 3s si el overlay está activo — sin chequear si está reproduciendo
                _t = setTimeout(function () {
                    if (_overlayVisible()) hideControls();
                }, 3000);
            }

            window.videoControlsShow = showControls;

            // Cualquier movimiento de mouse en el documento muestra los controles
            document.addEventListener('mousemove', function () {
                if (_overlayVisible()) showControls();
            });

            // Cualquier click también resetea el timer
            document.addEventListener('click', function () {
                if (_overlayVisible()) showControls();
            }, true);
        })();
    </script>

    <!-- ─── FOOTER ─── -->
    <footer class="app-footer">
        <span>© 2025 Lector EPUB</span>
        <span class="footer-sep">·</span>
        <span>Desarrollado por <strong style="color:var(--accent);">hpqode</strong></span>
        <span class="footer-sep">·</span>
        <a href="mailto:pitterbck@gmail.com" title="Contacto por email">pitterbck@gmail.com</a>
        <span class="footer-sep">·</span>
        <a href="https://wa.me/5493412282254" target="_blank" rel="noopener" title="WhatsApp">WhatsApp +54 341 228-2254</a>
    </footer>

    <script>
        // ─── TOOLTIP BARRA DE PROGRESO PRINCIPAL ───
        function mainProgressMouseMove(e) {
            if (typeof sentences === 'undefined' || sentences.length === 0) return;
            const track = document.getElementById('main-progress-track');
            const tooltip = document.getElementById('main-progress-tooltip');
            const rect = track.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const idx = Math.min(Math.floor(pct * sentences.length), sentences.length - 1);

            let preview = sentences[idx] || '';
            if (preview.length > 130) preview = preview.slice(0, 127) + '...';
            tooltip.textContent = `[${idx + 1}/${sentences.length}]\n${preview}`;
            tooltip.classList.add('visible');

            // Posicionar horizontalmente siguiendo el cursor, evitando bordes
            const relX = e.clientX - rect.left;
            const half = 120;
            const clamped = Math.max(half, Math.min(rect.width - half, relX));
            tooltip.style.left = clamped + 'px';
        }

        function mainProgressMouseLeave() {
            const tooltip = document.getElementById('main-progress-tooltip');
            if (tooltip) tooltip.classList.remove('visible');
        }
    </script>

    <!-- ─── MODAL REEMPLAZOS ─── -->
    <div id="modal-reemplazos">
        <div class="modal-box">
            <div class="modal-header">
                <span>📋 Reemplazos activos al cargar capítulo</span>
                <button onclick="cerrarModalReemplazos()" title="Cerrar">✕</button>
            </div>
            <div class="modal-body" id="modal-reemplazos-body">
                <div class="modal-empty">No hay reemplazos guardados.</div>
            </div>
        </div>
    </div>

    <script>
        // ─── MUTE MÚSICA AMBIENTAL ───
        let _ambientMuted = false;
        let _ambientVolBeforeMute = null;

        function toggleAmbientMute() {
            const btn = document.getElementById('kbtn-ambient-mute');
            if (_ambientMuted) {
                // Restaurar volumen
                const vol = _ambientVolBeforeMute !== null ? _ambientVolBeforeMute : 15;
                setAmbientVolume(vol);
                const sliders = [document.getElementById('ambient-volume'), document.getElementById('kol-music-vol')];
                sliders.forEach(s => { if (s) s.value = vol; });
                const pct = document.getElementById('kol-music-pct');
                const val = document.getElementById('ambient-vol-val');
                if (pct) pct.textContent = vol + '%';
                if (val) val.textContent = vol + '%';
                _ambientMuted = false;
                if (btn) btn.textContent = '🔊';
            } else {
                // Guardar volumen actual y silenciar
                const slider = document.getElementById('kol-music-vol');
                _ambientVolBeforeMute = slider ? parseInt(slider.value) : 15;
                setAmbientVolume(0);
                _ambientMuted = true;
                if (btn) btn.textContent = '🔇';
            }
        }

        // ─── MODAL DE REEMPLAZOS ───
        function abrirModalReemplazos() {
            const datos = JSON.parse(localStorage.getItem('reemplazos_custom') || '{}');
            const body = document.getElementById('modal-reemplazos-body');
            const modal = document.getElementById('modal-reemplazos');
            if (Object.keys(datos).length === 0) {
                body.innerHTML = '<div class="modal-empty">No hay reemplazos guardados.</div>';
            } else {
                body.innerHTML = Object.entries(datos).map(([k, v]) =>
                    `<div class="modal-row">
                                        <span class="from">${k}</span>
                                        <span class="arrow">→</span>
                                        <span class="to">${v}</span>
                                        <button class="del-btn" onclick="eliminarReemplazo(${JSON.stringify(k)})" title="Eliminar">✕</button>
                                    </div>`
                ).join('');
            }
            modal.classList.add('open');
        }

        function cerrarModalReemplazos() {
            document.getElementById('modal-reemplazos').classList.remove('open');
        }

        function eliminarReemplazo(clave) {
            const datos = JSON.parse(localStorage.getItem('reemplazos_custom') || '{}');
            delete datos[clave];
            localStorage.setItem('reemplazos_custom', JSON.stringify(datos));
            if (typeof reemplazosAutomaticos !== 'undefined') delete reemplazosAutomaticos[clave];
            // Invalidar cache BG para que el próximo capítulo se re-procese sin este reemplazo
            if (typeof _capCache !== 'undefined') Object.keys(_capCache).forEach(k => delete _capCache[k]);
            actualizarBotonLimpiarReemplazos();
            abrirModalReemplazos(); // refrescar
        }

        // Cerrar modal al hacer click fuera
        document.getElementById('modal-reemplazos').addEventListener('click', function (e) {
            if (e.target === this) cerrarModalReemplazos();
        });

        // Exponer para usar desde el sidebar
        window.abrirModalReemplazos = abrirModalReemplazos;
    </script>
</body>
</html>