<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lector EPUB con TTS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0f0e0c;
            --surface: #1a1814;
            --surface2: #242018;
            --border: #2e2a22;
            --accent: #c8a96e;
            --accent2: #7eb89a;
            --text: #e8e0d0;
            --text-muted: #8a8070;
            --text-dim: #5a5248;
            --sidebar-w: 300px;
        }

        body {
            font-family: 'DM Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* ─── MAIN CONTENT (LEFT 80%) ─── */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        .top-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

            .top-bar h1 {
                font-family: 'Lora', serif;
                font-size: 1.15rem;
                font-weight: 600;
                color: var(--accent);
                letter-spacing: 0.02em;
            }

            .top-bar .subtitle {
                font-size: 0.7rem;
                color: var(--text-muted);
                margin-left: auto;
            }

        .stats-bar {
            display: flex;
            gap: 24px;
            padding: 8px 28px;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .stat {
            font-size: 0.65rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 5px;
        }

            .stat strong {
                color: var(--accent);
                font-weight: 500;
            }

        /* Reading area */
        .reading-area {
            flex: 1;
            overflow-y: auto;
            padding: 48px 80px;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .reading-area::-webkit-scrollbar {
                width: 4px;
            }

            .reading-area::-webkit-scrollbar-track {
                background: transparent;
            }

            .reading-area::-webkit-scrollbar-thumb {
                background: var(--border);
                border-radius: 2px;
            }

        #texto-contenido {
            font-family: 'Lora', serif;
            font-size: 1.1rem;
            line-height: 1.85;
            color: var(--text);
            max-width: 680px;
            margin: 0 auto;
        }

            #texto-contenido p {
                margin-bottom: 1.2em;
            }

        /* Progress bar at bottom of reading area */
        .progress-wrap {
            flex-shrink: 0;
            padding: 0 28px 0;
            background: var(--surface);
            border-top: 1px solid var(--border);
        }

        .progress-track {
            height: 2px;
            background: var(--border);
            position: relative;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            width: 0%;
            transition: width 0.3s ease;
        }

        .tts-status-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        .tts-percent-badge {
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 0.6rem;
            color: var(--accent);
            font-weight: 500;
        }

        /* Editor panel (collapsible) */
        .editor-panel {
            flex-shrink: 0;
            background: var(--surface2);
            border-top: 1px solid var(--border);
            transition: max-height 0.3s ease;
            max-height: 0;
            overflow: hidden;
        }

            .editor-panel.open {
                max-height: 260px;
            }

        .editor-inner {
            padding: 16px 28px;
        }

        #editor-texto {
            width: 100%;
            height: 130px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.78rem;
            padding: 12px;
            resize: vertical;
            outline: none;
            margin-bottom: 10px;
        }

            #editor-texto:focus {
                border-color: var(--accent);
            }

        .editor-actions {
            display: flex;
            gap: 8px;
        }

        /* ─── SIDEBAR (RIGHT) ─── */
        .sidebar {
            width: var(--sidebar-w);
            flex-shrink: 0;
            background: var(--surface);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .sidebar::-webkit-scrollbar {
                width: 3px;
            }

            .sidebar::-webkit-scrollbar-thumb {
                background: var(--border);
            }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

            .sidebar-section:last-child {
                border-bottom: none;
            }

        .section-label {
            font-size: 0.6rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .section-label::after {
                content: '';
                flex: 1;
                height: 1px;
                background: var(--border);
            }

        /* File upload */
        .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 10px;
            background: var(--accent);
            color: var(--bg);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.72rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            transition: opacity 0.2s;
        }

            .file-label:hover {
                opacity: 0.85;
            }

        input[type="file"] {
            display: none;
        }

        #file-name {
            display: block;
            font-size: 0.62rem;
            color: var(--text-dim);
            margin-top: 6px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Chapter select */
        #chapters {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 4px;
            height: 110px;
            outline: none;
        }

            #chapters:focus {
                border-color: var(--accent);
            }

            #chapters option {
                padding: 4px 6px;
            }

                #chapters option:checked {
                    background: var(--accent);
                    color: var(--bg);
                }

        /* Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

            .toggle-row span {
                font-size: 0.68rem;
                color: var(--text-muted);
            }

        .toggle {
            position: relative;
            width: 36px;
            height: 19px;
        }

            .toggle input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .toggle-slider {
            position: absolute;
            inset: 0;
            background: var(--border);
            border-radius: 19px;
            cursor: pointer;
            transition: background 0.2s;
        }

            .toggle-slider::before {
                content: '';
                position: absolute;
                width: 13px;
                height: 13px;
                left: 3px;
                top: 3px;
                background: var(--text-muted);
                border-radius: 50%;
                transition: transform 0.2s, background 0.2s;
            }

        .toggle input:checked + .toggle-slider {
            background: var(--accent2);
        }

            .toggle input:checked + .toggle-slider::before {
                transform: translateX(17px);
                background: white;
            }

        #translation-status {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        /* Replace */
        .replace-pair {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* TTS Buttons */
        .tts-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        /* Sliders */
        .slider-row {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.62rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

            .slider-label span {
                color: var(--accent);
            }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--accent);
                cursor: pointer;
                transition: transform 0.15s;
            }

                input[type="range"]::-webkit-slider-thumb:hover {
                    transform: scale(1.3);
                }

        select#voice-select {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            padding: 6px 8px;
            outline: none;
            margin-bottom: 12px;
        }

            select#voice-select:focus {
                border-color: var(--accent);
            }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.68rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            transition: opacity 0.2s, transform 0.1s;
        }

            .btn:hover {
                opacity: 0.85;
            }

            .btn:active {
                transform: scale(0.97);
            }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn-secondary {
            background: var(--surface2);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .btn-success {
            background: var(--accent2);
            color: var(--bg);
        }

        .btn-tts {
            background: var(--surface2);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.65rem;
            padding: 7px 6px;
        }

            .btn-tts:disabled {
                opacity: 0.35;
                cursor: not-allowed;
                transform: none;
            }

            .btn-tts.active {
                background: var(--accent);
                color: var(--bg);
                border-color: var(--accent);
            }

        .btn-full {
            width: 100%;
        }

        /* Inputs */
        input[type="text"] {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 7px 10px;
            outline: none;
        }

            input[type="text"]:focus {
                border-color: var(--accent);
            }

            input[type="text"]::placeholder {
                color: var(--text-dim);
            }

        /* Notification */
        #notification {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.72rem;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

            #notification.show {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }

        /* Editor toggle button */
        .editor-toggle-btn {
            position: fixed;
            bottom: 24px;
            right: calc(var(--sidebar-w) + 24px);
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s;
        }

            .editor-toggle-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

        /* Scrollbar for reading area */
        .reading-area {
            scroll-behavior: smooth;
        }

        /* Highlight spoken word */
        .spoken {
            background: rgba(200, 169, 110, 0.18);
            border-radius: 2px;
        }

        /* TTS sentence highlight */
        .tts-sentence {
            border-radius: 3px;
            transition: background 0.25s ease, box-shadow 0.25s ease;
        }

            .tts-sentence.tts-active {
                background: rgba(200, 169, 110, 0.22);
                box-shadow: 0 0 0 2px rgba(200, 169, 110, 0.15);
                border-radius: 3px;
            }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .playing-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent2);
            animation: pulse 1s infinite;
            margin-right: 6px;
        }

        /* Responsive */
        @media (max-width: 700px) {
            :root {
                --sidebar-w: 240px;
            }

            .reading-area {
                padding: 32px 24px;
            }
        }

        /* ─── AMBIENT MUSIC PLAYER ─── */
        #ambient-player {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 260px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

            #ambient-player.collapsed .ambient-body {
                display: none;
            }

        .ambient-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            user-select: none;
        }

        .ambient-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.68rem;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .ambient-eq {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 12px;
        }

            .ambient-eq span {
                width: 3px;
                background: var(--accent2);
                border-radius: 1px;
                animation: none;
                height: 3px;
                transition: height 0.2s;
            }

            .ambient-eq.playing span:nth-child(1) {
                animation: eq1 0.8s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(2) {
                animation: eq2 0.6s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(3) {
                animation: eq3 1s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(4) {
                animation: eq2 0.7s ease-in-out infinite;
            }

        @keyframes eq1 {
            0%,100% {
                height: 3px
            }

            50% {
                height: 10px
            }
        }

        @keyframes eq2 {
            0%,100% {
                height: 6px
            }

            50% {
                height: 12px
            }
        }

        @keyframes eq3 {
            0%,100% {
                height: 9px
            }

            50% {
                height: 4px
            }
        }

        .ambient-collapse-btn {
            font-size: 0.6rem;
            color: var(--text-dim);
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
        }

        .ambient-body {
            padding: 14px;
        }

        .ambient-genres {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .genre-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 4px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.58rem;
            color: var(--text-muted);
            transition: all 0.2s;
        }

            .genre-btn:hover {
                border-color: var(--accent);
                color: var(--text);
            }

            .genre-btn.active {
                border-color: var(--accent2);
                background: rgba(126, 184, 154, 0.1);
                color: var(--accent2);
            }

            .genre-btn .genre-icon {
                font-size: 1rem;
            }

        .ambient-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .ambient-play-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--accent2);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--bg);
            flex-shrink: 0;
            transition: transform 0.15s, opacity 0.15s;
        }

            .ambient-play-btn:hover {
                transform: scale(1.1);
            }

        .ambient-track-info {
            flex: 1;
            overflow: hidden;
        }

        .ambient-track-name {
            font-size: 0.6rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ambient-track-genre {
            font-size: 0.55rem;
            color: var(--text-dim);
        }

        .ambient-vol-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ambient-vol-icon {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .ambient-vol-row input[type=range] {
            flex: 1;
            height: 3px;
        }

        .ambient-vol-val {
            font-size: 0.6rem;
            color: var(--text-dim);
            width: 26px;
            text-align: right;
        }


        /* ─── GRABACIÓN & VIDEO ─── */
        .rec-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--surface2);
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

            .rec-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

            .rec-btn.recording {
                border-color: #e05555;
                color: #e05555;
                animation: recpulse 1s infinite;
            }

        @keyframes recpulse {
            0%,100% {
                opacity: 1
            }

            50% {
                opacity: 0.5
            }
        }

        /* Spotify-style karaoke overlay */
        #karaoke-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 9, 8, 0.92);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

            #karaoke-overlay.active {
                display: flex;
            }

        #karaoke-canvas {
            border-radius: 12px;
            background: transparent;
        }

        #karaoke-close {
            position: absolute;
            top: 20px;
            right: 24px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.4rem;
            cursor: pointer;
            transition: color 0.2s;
        }

            #karaoke-close:hover {
                color: var(--text);
            }

        .karaoke-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
            width: min(900px, 95vw);
            position: relative;
        }

        /* En pantalla completa, el overlay cubre toda la pantalla */
        :fullscreen #karaoke-overlay,
        :-webkit-full-screen #karaoke-overlay {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            border-radius: 0 !important;
            max-width: none !important;
            justify-content: center;
        }

            :fullscreen #karaoke-overlay #ai-bg-wrap,
            :-webkit-full-screen #karaoke-overlay #ai-bg-wrap {
                width: 100vw !important;
                height: calc(100vh - 80px) !important;
                max-width: none !important;
                border-radius: 0 !important;
            }

        :fullscreen .karaoke-bar,
        :-webkit-full-screen .karaoke-bar {
            width: 95vw !important;
        }

        .karaoke-track {
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .karaoke-controls {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

            .karaoke-controls button {
                background: var(--surface2);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-muted);
                font-size: 0.65rem;
                font-family: 'DM Mono', monospace;
                padding: 6px 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

                .karaoke-controls button:hover {
                    border-color: var(--accent);
                    color: var(--accent);
                }

                .karaoke-controls button.ai-active {
                    border-color: var(--accent2);
                    color: var(--accent2);
                    background: rgba(126,184,154,0.1);
                }

        /* Barra de controles de reproducción centrada */
        .karaoke-playbar {
            display: flex;
            align-items: center;
            gap: 12px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .kbtn {
            border: none;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            transition: all 0.18s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kbtn-nav {
            background: rgba(255,255,255,0.06);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.65rem;
            padding: 8px 14px;
            letter-spacing: 0.02em;
        }

            .kbtn-nav:hover {
                background: rgba(200,169,110,0.12);
                border-color: var(--accent);
                color: var(--accent);
            }

        .kbtn-music {
            background: rgba(126,184,154,0.08);
            border: 1px solid rgba(126,184,154,0.2);
            border-radius: 6px;
            color: var(--accent2);
            font-size: 0.55rem;
            padding: 4px 8px;
        }

            .kbtn-music:hover {
                background: rgba(126,184,154,0.18);
                border-color: var(--accent2);
            }

        .kbtn-play {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent);
            color: var(--bg);
            font-size: 1.1rem;
            box-shadow: 0 0 20px rgba(200,169,110,0.3);
        }

            .kbtn-play:hover {
                transform: scale(1.08);
                box-shadow: 0 0 28px rgba(200,169,110,0.5);
            }

            .kbtn-play.paused {
                background: var(--accent2);
                box-shadow: 0 0 20px rgba(126,184,154,0.3);
            }
    </style>
</head>
<body>

    <div id="notification" class="notification"></div>

    <!-- ─── MAIN PANEL ─── -->
    <div class="main-panel">
        <div class="top-bar">
            <h1>📚 Lector EPUB</h1>
            <button class="rec-btn" id="btn-rec-audio" onclick="toggleGrabacion()" style="margin-left:16px;margin-bottom:0;">
                <span id="rec-dot">⏺</span> Grabar audio
            </button>
            <button class="rec-btn" onclick="abrirKaraoke()" style="margin-bottom:0;">
                🎬 Modo Video
            </button>
            <span class="subtitle" id="current-chapter-title">Ningún capítulo seleccionado</span>
        </div>

        <div class="stats-bar">
            <div class="stat">📝 Palabras: <strong id="contador-palabras">0</strong></div>
            <div class="stat">🔤 Chars: <strong id="contador-caracteres">0</strong></div>
            <div class="stat">📄 Párrafos: <strong id="contador-parrafos">0</strong></div>
            <div class="stat" id="tts-stat" style="margin-left:auto;">⏹️ <strong id="tts-status">Detenido</strong></div>
        </div>

        <div class="reading-area">
            <div id="texto-contenido" style="font-family:'Lora',serif;font-size:1.1rem;line-height:1.85;color:var(--text);max-width:680px;margin:0 auto;">
                <p style="color:var(--text-dim);font-style:italic;">Carga un archivo EPUB desde el panel lateral para comenzar a leer...</p>
            </div>
        </div>

        <div class="editor-panel" id="editor-panel">
            <div class="editor-inner">
                <div class="section-label">Editor de Texto</div>
                <textarea id="editor-texto" placeholder="Pega aquí tu texto o edita el contenido actual..."></textarea>
                <div class="editor-actions">
                    <button class="btn btn-success" onclick="aplicarTexto()">Aplicar</button>
                    <button class="btn btn-secondary" onclick="limpiarEditor()">Limpiar</button>
                    <button class="btn btn-secondary" onclick="copiarTexto()">Copiar</button>
                    <button class="btn btn-secondary" onclick="traducirTextoActual()" style="margin-left:auto;">Traducir</button>
                </div>
            </div>
        </div>

        <div class="progress-wrap">
            <div class="tts-status-bar">
                <span id="tts-status-label">⏹ Sin reproducción</span>
                <span class="tts-percent-badge" id="tts-percent" style="display:none;">0%</span>
            </div>
            <div class="progress-track" onclick="seekTTS(event)">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div style="height:8px;"></div>
        </div>
    </div>

    <button class="editor-toggle-btn" onclick="toggleEditor()" id="editor-toggle-btn">✏️ Editor</button>

    <!-- ─── SIDEBAR ─── -->
    <div class="sidebar">

        <!-- Cargar EPUB -->
        <div class="sidebar-section">
            <div class="section-label">Archivo</div>
            <label for="epub-file" class="file-label">📂 Seleccionar EPUB</label>
            <input type="file" id="epub-file" accept=".epub">
            <span id="file-name">Ningún archivo seleccionado</span>
        </div>

        <!-- Capítulos -->
        <div class="sidebar-section">
            <div class="section-label">Capítulos</div>
            <div id="chapter-selector">
                <input type="text" id="chapter-search" placeholder="🔍 Buscar capítulo..."
                       oninput="filtrarCapitulos(this.value)"
                       style="width:100%;margin-bottom:6px;font-size:0.68rem;padding:6px 10px;
                              background:var(--bg);border:1px solid var(--border);border-radius:4px;
                              color:var(--text);font-family:'DM Mono',monospace;outline:none;">
                <select id="chapters" size="6">
                    <option disabled>— sin capítulos —</option>
                </select>
            </div>
        </div>

        <!-- Traducción -->
        <div class="sidebar-section">
            <div class="section-label">Traducción</div>
            <div class="toggle-row">
                <span>Auto EN → ES</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-translate" onchange="toggleAutoTranslate()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div id="translation-status">Traducción desactivada</div>
            <div class="toggle-row" id="auto-play-row" style="margin-top:8px; display:none;">
                <span style="font-size:0.85rem; color:var(--text-dim);">▶ Reproducir al terminar</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-play-after-translate">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <!-- Reemplazar palabras -->
        <div class="sidebar-section">
            <div class="section-label collapsible-label" onclick="toggleReemplazar()" style="cursor:pointer;user-select:none;">
                Reemplazar <span id="reemplazar-arrow" style="margin-left:auto;font-size:0.7rem;color:var(--text-dim);">▶</span>
            </div>
            <div class="replace-pair" id="reemplazar-body" style="display:none;">
                <input type="text" id="palabra-buscar" placeholder="Buscar...">
                <input type="text" id="palabra-reemplazar" placeholder="Reemplazar con...">
                <button class="btn btn-primary" onclick="reemplazarPalabra()">Reemplazar</button>
            </div>
        </div>

        <!-- TTS Controles -->
        <div class="sidebar-section">
            <div class="section-label">Reproducción</div>
            <div class="tts-btn-grid">
                <button class="btn-tts btn" onclick="iniciarTTS()" id="btn-play">▶ Play</button>
                <button class="btn-tts btn" onclick="pausarTTS()" id="btn-pause" disabled>⏸ Pausa</button>
                <button class="btn-tts btn" onclick="reanudarTTS()" id="btn-resume" disabled>▶ Cont.</button>
                <button class="btn-tts btn" onclick="detenerTTS()" id="btn-stop" disabled>⏹ Stop</button>
            </div>

            <div class="section-label" style="margin-top:4px;">Voz</div>
            <select id="voice-select"></select>

            <div class="slider-row">
                <div class="slider-label">Velocidad <span id="rate-value">1.0</span>x</div>
                <input type="range" id="rate-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Tono <span id="pitch-value">1.0</span></div>
                <input type="range" id="pitch-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Volumen <span id="volume-value">100</span>%</div>
                <input type="range" id="volume-control" min="0" max="100" step="5" value="100">
            </div>
        </div>

    </div>

    <script src="js/main.js"></script>
    <script>
        // Reemplazar toggle
        function toggleReemplazar() {
            const body = document.getElementById('reemplazar-body');
            const arrow = document.getElementById('reemplazar-arrow');
            const open = body.style.display === 'none';
            body.style.display = open ? 'flex' : 'none';
            arrow.textContent = open ? '▼' : '▶';
        }

        // Editor toggle (UI only)
        function toggleEditor() {
            const panel = document.getElementById('editor-panel');
            const btn = document.getElementById('editor-toggle-btn');
            panel.classList.toggle('open');
            btn.textContent = panel.classList.contains('open') ? '✕ Cerrar Editor' : '✏️ Editor';
        }

        // Sync chapter title in top bar when chapter changes
        document.getElementById('chapters').addEventListener('change', function (e) {
            const opt = e.target.options[e.target.selectedIndex];
            if (opt) document.getElementById('current-chapter-title').textContent = opt.textContent;
        });

        // Patch actualizarEstadoTTS to also update the extra status elements in the new layout
        const _origActualizarEstadoTTS = actualizarEstadoTTS;
        // Wait for main.js to load first
        window.addEventListener('DOMContentLoaded', () => { });

        // Patch iniciarTTS: reconstruir slot map de IA y detectar universo al iniciar
        const _origIniciarTTS = iniciarTTS;
        window.iniciarTTS = function () {
            _origIniciarTTS.apply(this, arguments);
            // Tras iniciar, sentences ya fue reconstruido en main.js
            setTimeout(() => {
                if (typeof buildAiSlotMap === 'function') buildAiSlotMap();
                if (typeof detectarUniverso === 'function') detectarUniverso();
            }, 80);
        };
        iniciarTTS = window.iniciarTTS;
    </script>

    <!-- ─── AMBIENT MUSIC PLAYER ─── -->
    <div id="ambient-player" class="collapsed">
        <div class="ambient-header" onclick="toggleAmbientPanel()">
            <div class="ambient-header-left">
                <div class="ambient-eq" id="ambient-eq">
                    <span></span><span></span><span></span><span></span>
                </div>
                Música Ambiental
            </div>
            <button class="ambient-collapse-btn" id="ambient-arrow">▲</button>
        </div>
        <div class="ambient-body">

            <!-- API Key panel -->
            <div id="freesound-key-panel" style="margin-bottom:10px;">
                <div style="font-size:0.58rem;color:var(--text-dim);margin-bottom:4px;">
                    🎵 Freesound API Key <span style="color:var(--accent2)" id="key-status"></span>
                </div>
                <div style="display:flex;gap:6px;">
                    <input type="password" id="freesound-api-key" placeholder="Pegar API key..."
                           style="flex:1;background:var(--bg);border:1px solid var(--border);border-radius:4px;
                    color:var(--text);font-family:'DM Mono',monospace;font-size:0.62rem;padding:5px 8px;outline:none;">
                    <button onclick="guardarApiKey()"
                            style="background:var(--accent2);border:none;border-radius:4px;color:var(--bg);
                    font-family:'DM Mono',monospace;font-size:0.6rem;padding:5px 8px;cursor:pointer;">
                        OK
                    </button>
                </div>
                <div style="font-size:0.55rem;color:var(--text-dim);margin-top:3px;">
                    Sin key → generador procedural local
                </div>
            </div>

            <div class="ambient-genres">
                <button class="genre-btn" onclick="selectGenre('mystery')" id="genre-mystery">
                    <span class="genre-icon">🔍</span>Misterio
                </button>
                <button class="genre-btn" onclick="selectGenre('suspense')" id="genre-suspense">
                    <span class="genre-icon">😰</span>Suspenso
                </button>
                <button class="genre-btn" onclick="selectGenre('drama')" id="genre-drama">
                    <span class="genre-icon">🎭</span>Drama
                </button>
                <button class="genre-btn" onclick="selectGenre('action')" id="genre-action">
                    <span class="genre-icon">⚡</span>Acción
                </button>
                <button class="genre-btn" onclick="selectGenre('fantasy')" id="genre-fantasy">
                    <span class="genre-icon">🧙</span>Fantasía
                </button>
                <button class="genre-btn" onclick="selectGenre('romance')" id="genre-romance">
                    <span class="genre-icon">💫</span>Romance
                </button>
                <button class="genre-btn" onclick="selectGenre('lofi')" id="genre-lofi">
                    <span class="genre-icon">📚</span>Lo-Fi
                </button>
                <button class="genre-btn" onclick="selectGenre('nature')" id="genre-nature">
                    <span class="genre-icon">🌿</span>Naturaleza
                </button>
            </div>

            <button class="btn btn-secondary" onclick="detectarGeneroConIA()" id="btn-detect-genre"
                    style="width:100%;margin-bottom:10px;font-size:0.62rem;gap:6px;">
                ✨ Detectar género del texto
            </button>

            <div class="ambient-controls">
                <button class="ambient-play-btn" id="ambient-play-btn" onclick="toggleAmbientPlay()">▶</button>
                <div class="ambient-track-info">
                    <div class="ambient-track-name" id="ambient-track-name">Selecciona un género</div>
                    <div class="ambient-track-genre" id="ambient-track-genre">─</div>
                </div>
                <button onclick="siguienteTrack()" title="Siguiente track" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:0.9rem;padding:4px;transition:color 0.2s;" onmouseover="this.style.color='var(--accent)'" onmouseout="this.style.color='var(--text-dim)'">⏭</button>
            </div>

            <div class="ambient-vol-row">
                <span class="ambient-vol-icon">🎵</span>
                <input type="range" id="ambient-volume" min="0" max="100" value="20" oninput="setAmbientVolume(this.value)">
                <span class="ambient-vol-val" id="ambient-vol-val">20%</span>
            </div>
        </div>
    </div>

    <script>
        // ─── AMBIENT MUSIC ENGINE — Web Audio API Procedural Generation ───
        // Genera música ambiental 100% en el navegador sin URLs externas

        let ambientCtx = null;
        let ambientNodes = [];
        let ambientPlaying = false;
        let ambientGenre = null;
        let ambientGainNode = null;
        let ambientVolume = 0.20;

        function getAudioCtx() {
            if (!ambientCtx) ambientCtx = new (window.AudioContext || window.webkitAudioContext)();
            return ambientCtx;
        }

        // ── Generadores por género ──
        const GENRE_GENERATORS = {

            mystery: (ctx, gain) => {
                // Notas oscuras lentas + reverb simulado
                const notes = [130.81, 155.56, 174.61, 196.00, 220.00];
                const nodes = [];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain);
                    osc.start();
                    // Pulsa cada nota con tiempo diferente
                    const interval = setInterval(() => {
                        const now = ctx.currentTime;
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(0.08, now + 0.3);
                        g.gain.linearRampToValueAtTime(0, now + 2.5);
                    }, 3000 + i * 700);
                    nodes.push({ osc, interval });
                });
                // Rumble bajo
                const rumble = ctx.createOscillator();
                const rg = ctx.createGain();
                rumble.type = 'sine'; rumble.frequency.value = 55;
                rg.gain.value = 0.04;
                rumble.connect(rg); rg.connect(gain); rumble.start();
                nodes.push({ osc: rumble });
                return nodes;
            },

            suspense: (ctx, gain) => {
                const nodes = [];
                // Tremolo tense string simulation
                [220, 233, 246].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    const g = ctx.createGain();
                    osc.type = 'sawtooth'; osc.frequency.value = freq;
                    lfo.type = 'sine'; lfo.frequency.value = 6 + i;
                    lfoGain.gain.value = 0.03;
                    g.gain.value = 0.04;
                    lfo.connect(lfoGain); lfoGain.connect(g.gain);
                    osc.connect(g); g.connect(gain);
                    osc.start(); lfo.start();
                    nodes.push({ osc }, { osc: lfo });
                });
                // Heartbeat-like bass
                const bass = ctx.createOscillator();
                const bg = ctx.createGain();
                bass.type = 'sine'; bass.frequency.value = 80;
                bg.gain.value = 0;
                bass.connect(bg); bg.connect(gain); bass.start();
                const beat = setInterval(() => {
                    const now = ctx.currentTime;
                    bg.gain.setValueAtTime(0, now);
                    bg.gain.linearRampToValueAtTime(0.12, now + 0.05);
                    bg.gain.linearRampToValueAtTime(0, now + 0.3);
                    bg.gain.setValueAtTime(0, now + 0.5);
                    bg.gain.linearRampToValueAtTime(0.08, now + 0.55);
                    bg.gain.linearRampToValueAtTime(0, now + 0.8);
                }, 1800);
                nodes.push({ osc: bass, interval: beat });
                return nodes;
            },

            drama: (ctx, gain) => {
                const nodes = [];
                // Slow cinematic pads
                [[261.63, 0.06], [329.63, 0.04], [392.00, 0.03], [493.88, 0.025]].forEach(([freq, vol]) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    g.gain.value = vol;
                    osc.connect(g); g.connect(gain); osc.start();
                    nodes.push({ osc });
                });
                // Slow filter sweep
                const noise = ctx.createOscillator();
                const ng = ctx.createGain();
                noise.type = 'triangle'; noise.frequency.value = 110;
                ng.gain.value = 0.05;
                noise.connect(ng); ng.connect(gain); noise.start();
                nodes.push({ osc: noise });
                return nodes;
            },

            action: (ctx, gain) => {
                const nodes = [];
                // Aggressive rhythm + brass-like hits
                const bassOsc = ctx.createOscillator();
                const bg = ctx.createGain();
                bassOsc.type = 'square'; bassOsc.frequency.value = 110;
                bg.gain.value = 0;
                bassOsc.connect(bg); bg.connect(gain); bassOsc.start();
                let beat = 0;
                const rhythm = [1, 0, 1, 0, 1, 1, 0, 1];
                const interval = setInterval(() => {
                    if (rhythm[beat % rhythm.length]) {
                        const now = ctx.currentTime;
                        bg.gain.setValueAtTime(0.1, now);
                        bg.gain.linearRampToValueAtTime(0, now + 0.15);
                    }
                    beat++;
                }, 200);
                nodes.push({ osc: bassOsc, interval });
                // High tension strings
                [440, 554, 659].forEach(freq => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sawtooth'; o.frequency.value = freq;
                    g.gain.value = 0.025;
                    o.connect(g); g.connect(gain); o.start();
                    nodes.push({ osc: o });
                });
                return nodes;
            },

            fantasy: (ctx, gain) => {
                const nodes = [];
                // Magical harp-like arpeggios
                const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
                let noteIdx = 0;
                const playNote = () => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = scale[noteIdx % scale.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(0.07, now + 0.05);
                    g.gain.linearRampToValueAtTime(0, now + 1.2);
                    setTimeout(() => osc.stop(), 1500);
                    noteIdx++;
                };
                const interval = setInterval(playNote, 400);
                nodes.push({ interval });
                // Pad underneath
                const pad = ctx.createOscillator();
                const pg = ctx.createGain();
                pad.type = 'sine'; pad.frequency.value = 130.81;
                pg.gain.value = 0.03;
                pad.connect(pg); pg.connect(gain); pad.start();
                nodes.push({ osc: pad });
                return nodes;
            },

            romance: (ctx, gain) => {
                const nodes = [];
                // Warm, slow piano-like notes
                const melody = [261.63, 329.63, 392.00, 329.63, 261.63, 293.66, 349.23, 293.66];
                let idx = 0;
                const interval = setInterval(() => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = melody[idx % melody.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.linearRampToValueAtTime(0.08, now + 0.1);
                    g.gain.linearRampToValueAtTime(0, now + 1.8);
                    setTimeout(() => osc.stop(), 2000);
                    // Armonía
                    const osc2 = ctx.createOscillator();
                    const g2 = ctx.createGain();
                    osc2.type = 'sine'; osc2.frequency.value = melody[idx % melody.length] * 1.5;
                    g2.gain.value = 0;
                    osc2.connect(g2); g2.connect(gain); osc2.start();
                    g2.gain.linearRampToValueAtTime(0.04, now + 0.15);
                    g2.gain.linearRampToValueAtTime(0, now + 1.5);
                    setTimeout(() => osc2.stop(), 1800);
                    idx++;
                }, 800);
                nodes.push({ interval });
                return nodes;
            },

            lofi: (ctx, gain) => {
                const nodes = [];
                // Lo-fi: muffled chords + vinyl crackle simulation
                const chords = [[261.63, 329.63, 392.00], [246.94, 311.13, 369.99], [220.00, 277.18, 329.63]];
                let ci = 0;
                const interval = setInterval(() => {
                    chords[ci % chords.length].forEach(freq => {
                        const osc = ctx.createOscillator();
                        const g = ctx.createGain();
                        const filter = ctx.createBiquadFilter();
                        filter.type = 'lowpass'; filter.frequency.value = 800; // Muffled
                        osc.type = 'triangle'; osc.frequency.value = freq;
                        g.gain.value = 0;
                        osc.connect(filter); filter.connect(g); g.connect(gain); osc.start();
                        const now = ctx.currentTime;
                        g.gain.linearRampToValueAtTime(0.05, now + 0.1);
                        g.gain.linearRampToValueAtTime(0.04, now + 1.5);
                        g.gain.linearRampToValueAtTime(0, now + 2);
                        setTimeout(() => osc.stop(), 2200);
                    });
                    ci++;
                }, 2000);
                nodes.push({ interval });
                // Rain-like noise
                const bufferSize = ctx.sampleRate * 2;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.015;
                const src = ctx.createBufferSource();
                src.buffer = buffer; src.loop = true;
                const nf = ctx.createBiquadFilter();
                nf.type = 'bandpass'; nf.frequency.value = 2000;
                src.connect(nf); nf.connect(gain); src.start();
                nodes.push({ src });
                return nodes;
            },

            nature: (ctx, gain) => {
                const nodes = [];
                // Wind + birds simulation
                // Wind: filtered noise
                const bufferSize = ctx.sampleRate * 3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const wind = ctx.createBufferSource();
                wind.buffer = buffer; wind.loop = true;
                const wf = ctx.createBiquadFilter();
                wf.type = 'bandpass'; wf.frequency.value = 400; wf.Q.value = 0.5;
                const wg = ctx.createGain(); wg.gain.value = 0.08;
                wind.connect(wf); wf.connect(wg); wg.connect(gain); wind.start();
                nodes.push({ src: wind });
                // Bird chirps
                const chirp = () => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(2000 + Math.random() * 1000, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(2800 + Math.random() * 800, ctx.currentTime + 0.1);
                    g.gain.setValueAtTime(0, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 0.02);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.15);
                    o.connect(g); g.connect(gain); o.start();
                    setTimeout(() => o.stop(), 200);
                };
                const interval = setInterval(() => {
                    chirp();
                    if (Math.random() > 0.5) setTimeout(chirp, 150);
                }, 1500 + Math.random() * 3000);
                nodes.push({ interval });
                return nodes;
            }
        };

        const GENRE_LABELS = {
            mystery: 'Misterio oscuro', suspense: 'Suspenso tenso', drama: 'Drama cinematográfico',
            action: 'Acción intensa', fantasy: 'Fantasía mágica', romance: 'Romance suave',
            lofi: 'Lo-Fi + lluvia', nature: 'Naturaleza y viento'
        };

        // ── Freesound API key management ──
        let freesoundApiKey = localStorage.getItem('freesound_api_key') || 'JCXLtKvEpLo3DJTYy3pRIXEcEWMTLRWK3UEcJ5iD';

        function guardarApiKey() {
            const key = document.getElementById('freesound-api-key').value.trim();
            if (key) {
                freesoundApiKey = key;
                localStorage.setItem('freesound_api_key', key);
                document.getElementById('key-status').textContent = '✓ guardada';
                document.getElementById('freesound-api-key').value = '';
                setTimeout(() => document.getElementById('key-status').textContent = '', 2000);
            }
        }

        // Show key status on load
        window.addEventListener('DOMContentLoaded', () => {
            if (freesoundApiKey) {
                document.getElementById('key-status').textContent = '✓ configurada';
            }
        });

        // ── Freesound multi-query system con subtonos ──
        // Múltiples queries por género para mejor variedad y precisión
        const FREESOUND_QUERIES = {
            mystery: ['dark mystery ambient', 'noir detective atmosphere', 'eerie suspense drone', 'dark cinematic tension'],
            suspense: ['suspense thriller tension', 'psychological horror ambient', 'heartbeat tense atmosphere', 'chase scene cinematic'],
            drama: ['emotional piano ambient', 'cinematic sad orchestral', 'melancholy strings atmosphere', 'dramatic film score'],
            action: ['epic battle cinematic', 'intense action orchestral', 'war drums epic', 'adrenaline cinematic score'],
            fantasy: ['magical fantasy ambient', 'ethereal fantasy soundscape', 'enchanted forest music', 'epic fantasy orchestral'],
            romance: ['romantic piano soft', 'love theme gentle strings', 'tender romantic ambient', 'soft acoustic romance'],
            lofi: ['lofi hip hop chill', 'study music ambient beats', 'chill lofi background', 'jazzy lofi instrumental'],
            nature: ['forest nature ambient', 'rain birds peaceful', 'ocean waves relaxing', 'meditation nature sounds'],
            horror: ['horror dark ambient', 'scary atmosphere drone', 'creepy tension music', 'dark horror soundscape'],
            adventure: ['adventure epic journey', 'exploration cinematic', 'heroic adventure theme', 'discovery orchestral'],
        };

        // Análisis avanzado: detecta tono, intensidad y subtono del texto
        function analizarTextoDetallado(texto) {
            const lower = texto.toLowerCase().slice(0, 3000);
            const words = lower.split(/\s+/);
            const totalWords = words.length;

            // Función helper: cuenta ocurrencias por 1000 palabras (normalizado)
            const freq = (lista) => lista.reduce((s, w) => s + (lower.split(w).length - 1), 0) / totalWords * 1000;

            const scores = {
                mystery: freq(['misterio', 'enigma', 'sombra', 'oscuro', 'secreto', 'oculto', 'extraño', 'cadáver', 'crimen', 'investigar', 'pista', 'detecti', 'desapareció', 'cuerpo', 'asesino', 'veneno', 'conspiración']),
                suspense: freq(['tensión', 'peligro', 'trampa', 'amenaza', 'miedo', 'terror', 'acecho', 'perseguir', 'escapar', 'corazón', 'aceleró', 'tiempo', 'demasiado tarde', 'pistola', 'arma', 'disparó', 'huir', 'atrapado']),
                drama: freq(['llanto', 'lágrimas', 'dolor', 'sufrir', 'perder', 'traición', 'soledad', 'sacrificio', 'promesa', 'herida', 'culpa', 'perdón', 'familia', 'ruptura', 'pérdida', 'luto', 'desesperanza', 'fracasó']),
                action: freq(['combate', 'batalla', 'golpe', 'atacar', 'disparar', 'explotar', 'luchar', 'espada', 'victoria', 'enemigo', 'guerrero', 'sangre', 'herido', 'correr', 'saltar', 'velocidad', 'patada', 'puño', 'chocó']),
                fantasy: freq(['magia', 'hechizo', 'dragón', 'reino', 'elfo', 'mago', 'destino', 'profecía', 'criatura', 'portal', 'artefacto', 'encantamiento', 'espíritu', 'runa', 'hada', 'brujo', 'varita', 'conjuro', 'poción']),
                romance: freq(['amor', 'beso', 'mirada', 'suave', 'sentir', 'latir', 'ternura', 'abrazo', 'sonrisa', 'deseo', 'piel', 'suspirar', 'juntos', 'enamorar', 'cariño', 'corazón', 'acarició', 'besó', 'amaba']),
                lofi: freq(['estudiar', 'aprender', 'libro', 'notas', 'lección', 'conocimiento', 'teoría', 'análisis', 'investigación', 'datos', 'concepto', 'comprender', 'fórmula', 'clase', 'universidad', 'examen', 'trabajo']),
                nature: freq(['bosque', 'árbol', 'río', 'montaña', 'viento', 'lluvia', 'animal', 'campo', 'flor', 'tierra', 'cielo', 'amanecer', 'naturaleza', 'verde', 'agua', 'pájaro', 'mar', 'playa', 'selva', 'tormenta']),
                horror: freq(['horror', 'aterrador', 'monstruo', 'demonio', 'sangre', 'muerte', 'oscuridad', 'grito', 'pesadilla', 'fantasma', 'sombra', 'aparición', 'terror', 'carne', 'víscera', 'mutilado', 'cadáver', 'pudrir']),
                adventure: ['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'montaña', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio'].reduce ? freq(['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio']) : 0,
            };

            // Detectar intensidad general del texto
            const intensityWords = freq(['!', 'muy', 'enorme', 'increíble', 'absolutamente', 'completamente', 'jamás', 'nunca', 'siempre', 'desesperado', 'urgente']);
            const intensity = Math.min(intensityWords / 5, 1); // 0-1

            // Detectar ritmo (oraciones cortas = acción/suspenso, largas = drama/romance)
            const avgSentenceLen = lower.split(/[.!?]+/).filter(s => s.trim()).reduce((s, o) => s + o.split(' ').length, 0) / Math.max(lower.split(/[.!?]+/).length, 1);
            const isPaced = avgSentenceLen < 12; // oraciones cortas = más urgente

            // Ganador
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const winner = sorted[0][0];
            const runnerUp = sorted[1][0];
            const confidence = sorted[0][1] > 0 ? Math.min(sorted[0][1] / (sorted[1][1] + 0.1), 3) : 0;

            return { genre: winner, secondary: runnerUp, confidence, intensity, isPaced, scores };
        }

        let freesoundTrackUrl = null;
        let freesoundAudio = null;
        let _lastFreesoundResults = {};  // cache por género

        async function buscarEnFreesound(genre, subtono) {
            if (!freesoundApiKey) return null;

            // Elegir query: usar subtono si hay alta confianza, sino query principal
            const queries = FREESOUND_QUERIES[genre] || FREESOUND_QUERIES['mystery'];
            const queryStr = queries[Math.floor(Math.random() * queries.length)];

            // Cache: si ya tenemos resultados de este género, rotar entre ellos
            if (_lastFreesoundResults[genre] && _lastFreesoundResults[genre].length > 1) {
                const pool = _lastFreesoundResults[genre];
                const pick = pool[Math.floor(Math.random() * pool.length)];
                return pick;
            }

            const query = encodeURIComponent(queryStr);
            const url = `https://freesound.org/apiv2/search/text/?query=${query}&filter=duration:[60 TO 360]&fields=name,previews,duration,avg_rating&page_size=20&sort=rating_desc&token=${freesoundApiKey}`;

            try {
                const res = await fetch(url);
                if (!res.ok) {
                    if (res.status === 401) document.getElementById('key-status').textContent = '✗ key inválida';
                    return null;
                }
                const data = await res.json();
                if (data.results && data.results.length > 0) {
                    // Filtrar los mejores (rating > 3 o top 10)
                    const good = data.results
                        .filter(t => t.avg_rating >= 3 || data.results.indexOf(t) < 8)
                        .map(t => ({ url: t.previews['preview-hq-mp3'], name: t.name, duration: t.duration }));
                    _lastFreesoundResults[genre] = good;
                    return good[Math.floor(Math.random() * good.length)];
                }
            } catch (e) { console.warn('Freesound error:', e); }
            return null;
        }

        function toggleAmbientPanel() {
            const player = document.getElementById('ambient-player');
            const arrow = document.getElementById('ambient-arrow');
            player.classList.toggle('collapsed');
            arrow.textContent = player.classList.contains('collapsed') ? '▲' : '▼';
        }

        async function selectGenre(genre) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('genre-' + genre).classList.add('active');
            ambientGenre = genre;
            stopAmbient();
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando...';
            document.getElementById('ambient-track-genre').textContent = freesoundApiKey ? 'buscando en Freesound...' : 'generador local';
            // Clear cache for this genre so we get a fresh random track
            delete _lastFreesoundResults[genre];
            await playAmbient(genre);
        }

        async function playAmbient(genre) {
            const g = genre || ambientGenre;

            // Try Freesound first if key is available
            if (freesoundApiKey) {
                const track = await buscarEnFreesound(g, null);
                if (track) {
                    freesoundAudio = new Audio(track.url);
                    freesoundAudio.loop = true;
                    freesoundAudio.volume = ambientVolume;
                    freesoundAudio.crossOrigin = 'anonymous';
                    freesoundAudio.play().then(() => {
                        ambientPlaying = true;
                        document.getElementById('ambient-play-btn').textContent = '⏸';
                        document.getElementById('ambient-eq').classList.add('playing');
                        document.getElementById('ambient-track-name').textContent = track.name;
                        document.getElementById('ambient-track-genre').textContent = '♪ Freesound CC0';
                    }).catch(() => playAmbientLocal(g));
                    return;
                }
            }
            // Fallback: procedural
            playAmbientLocal(g);
        }

        function playAmbientLocal(genre) {
            const ctx = getAudioCtx();
            if (ctx.state === 'suspended') ctx.resume();
            ambientGainNode = ctx.createGain();
            ambientGainNode.gain.value = ambientVolume;
            ambientGainNode.connect(ctx.destination);
            const generator = GENRE_GENERATORS[genre || ambientGenre];
            if (!generator) return;
            ambientNodes = generator(ctx, ambientGainNode);
            ambientPlaying = true;
            document.getElementById('ambient-play-btn').textContent = '⏸';
            document.getElementById('ambient-eq').classList.add('playing');
            document.getElementById('ambient-track-name').textContent = GENRE_LABELS[genre];
            document.getElementById('ambient-track-genre').textContent = '♪ generado localmente';
        }

        function stopAmbient() {
            // Stop Freesound audio
            if (freesoundAudio) {
                freesoundAudio.pause();
                freesoundAudio.src = '';
                freesoundAudio = null;
            }
            // Stop procedural nodes
            ambientNodes.forEach(n => {
                try { if (n.osc) n.osc.stop(); } catch (e) { }
                try { if (n.src) n.src.stop(); } catch (e) { }
                if (n.interval) clearInterval(n.interval);
            });
            ambientNodes = [];
            if (ambientGainNode) {
                try { ambientGainNode.disconnect(); } catch (e) { }
                ambientGainNode = null;
            }
            ambientPlaying = false;
            document.getElementById('ambient-play-btn').textContent = '▶';
            document.getElementById('ambient-eq').classList.remove('playing');
        }

        function toggleAmbientPlay() {
            if (!ambientGenre) {
                document.getElementById('ambient-track-name').textContent = '← Elige un género primero';
                return;
            }
            if (ambientPlaying) { stopAmbient(); } else { playAmbient(ambientGenre); }
        }

        async function siguienteTrack() {
            if (!ambientGenre) return;
            stopAmbient();
            // Force new search (clear single-item cache)
            if (_lastFreesoundResults[ambientGenre]) {
                // Rotate: remove first item and re-search if empty
                _lastFreesoundResults[ambientGenre].shift();
                if (_lastFreesoundResults[ambientGenre].length === 0) {
                    delete _lastFreesoundResults[ambientGenre];
                }
            }
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando siguiente...';
            await playAmbient(ambientGenre);
        }

        function setAmbientVolume(val) {
            ambientVolume = val / 100;
            document.getElementById('ambient-vol-val').textContent = val + '%';
            if (ambientGainNode) ambientGainNode.gain.value = ambientVolume;
            if (freesoundAudio) freesoundAudio.volume = ambientVolume;
        }

        // detectarGeneroLocal reemplazado por analizarTextoDetallado arriba

        async function detectarGeneroConIA() {
            const texto = document.getElementById('texto-contenido').textContent.trim();
            if (!texto || texto.length < 100) {
                document.getElementById('ambient-track-name').textContent = 'Carga un capítulo primero';
                return;
            }

            const btn = document.getElementById('btn-detect-genre');
            btn.textContent = '⏳ Analizando...';
            btn.disabled = true;

            // Análisis local rico
            const analysis = analizarTextoDetallado(texto);
            const { genre, secondary, confidence, intensity, isPaced, scores } = analysis;

            // Mostrar top 3 en consola para debug
            const top3 = Object.entries(scores).sort((a, b) => b[1] - a[1]).slice(0, 3);
            console.log('🎵 Análisis de texto:', top3.map(([g, s]) => `${g}:${s.toFixed(2)}`).join(', '), '| intensidad:', intensity.toFixed(2), '| ritmo:', isPaced ? 'rápido' : 'lento');

            // Seleccionar género con subtono
            await selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced);

            btn.textContent = '✨ Detectar género del texto';
            btn.disabled = false;
        }

        async function selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('genre-' + genre);
            if (btn) btn.classList.add('active');
            ambientGenre = genre;
            stopAmbient();

            // Descripción de confianza
            const confLabel = confidence > 2 ? 'muy claro' : confidence > 1 ? 'probable' : 'leve';
            const rhythmLabel = isPaced ? 'ritmo rápido' : 'ritmo pausado';
            document.getElementById('ambient-track-name').textContent = '⏳ Buscando en Freesound...';
            document.getElementById('ambient-track-genre').textContent = `${GENRE_LABELS[genre]} · ${confLabel} · ${rhythmLabel}`;

            await playAmbient(genre);
        }
    </script>

    <script>
        // roundRect polyfill for browsers that don't support it
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                r = Math.min(r, w / 2, h / 2);
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
                return this;
            };
        }
    </script>
    <!-- ─── GRABACIÓN / VIDEO ─── -->
    <!-- Karaoke overlay -->
    <div id="karaoke-overlay">
        <button id="karaoke-close" onclick="cerrarKaraoke()">✕</button>
        <!-- Fondo IA: dos divs para crossfade via CSS, detrás del canvas -->
        <!-- Contenedor compartido: imagen de fondo + canvas alineados -->
        <div id="ai-bg-wrap" style="
            position:relative;
            width:min(900px,95vw);
            height:min(506px,53vw);
            flex-shrink:0;
        ">
            <div id="ai-bg-a" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <div id="ai-bg-b" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <!-- Overlay oscuro encima de la imagen para que el texto sea legible -->
            <div id="ai-bg-overlay" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background:rgba(8,7,6,0);
                transition:background 1s ease;
                pointer-events:none;
            "></div>
            <canvas id="karaoke-canvas" width="1280" height="720" style="position:absolute;inset:0;width:100%;height:100%;z-index:1;background:transparent;border-radius:12px;"></canvas>
        </div>

        <!-- Barra inferior principal -->
        <div class="karaoke-bar">
            <!-- Izquierda: controles de música + volumen música -->
            <div style="display:flex;align-items:center;gap:4px;flex-shrink:0;">
                <button class="kbtn kbtn-music" onclick="karaokeMusicaPrev()" title="Pista anterior">&#9664;</button>
                <span id="karaoke-music-label" style="font-size:0.58rem;color:var(--text-dim);font-family:'DM Mono',monospace;max-width:90px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">♪</span>
                <button class="kbtn kbtn-music" onclick="karaokeMusicaSiguiente()" title="Pista siguiente">&#9654;</button>
                <!-- Volumen música justo a la derecha -->
                <input type="range" id="kol-music-vol" min="0" max="100" value="20" step="5"
                       style="width:55px;accent-color:var(--accent2);cursor:pointer;vertical-align:middle;margin-left:6px;"
                       oninput="setAmbientVolume(this.value); document.getElementById('kol-music-pct').textContent=this.value+'%'">
                <span id="kol-music-pct" style="font-size:0.6rem;color:var(--text-dim);min-width:26px;">20%</span>
            </div>

            <!-- Centro: nav capítulos + play -->
            <div class="karaoke-playbar">
                <button class="kbtn kbtn-nav" id="kbtn-prev" onclick="karaokeCapituloAnterior()" title="Capítulo anterior">&#9664;&#9664;</button>
                <button class="kbtn kbtn-play" id="kbtn-playpause" onclick="karaokeTogglePlay()" title="Play / Pausa">&#9654;</button>
                <button class="kbtn kbtn-nav" id="kbtn-next" onclick="karaokeCapituloSiguiente()" title="Capítulo siguiente">&#9654;&#9654;</button>
            </div>

            <!-- Derecha: volumen TTS + IA + exportar + fullscreen -->
            <div class="karaoke-controls">
                <!-- 🗣 Volumen TTS -->
                <div style="display:flex;align-items:center;gap:3px;" title="Volumen voz">
                    <span style="font-size:0.7rem;">🗣</span>
                    <input type="range" id="kol-tts-vol" min="0" max="100" value="100" step="5"
                           style="width:55px;accent-color:var(--accent);cursor:pointer;vertical-align:middle;"
                           oninput="setTTSVolume(this.value); document.getElementById('kol-tts-pct').textContent=this.value+'%'">
                    <span id="kol-tts-pct" style="font-size:0.6rem;color:var(--text-dim);min-width:26px;">100%</span>
                </div>
                <button id="btn-toggle-ai-img" onclick="toggleAIImages()" title="Imágenes IA de fondo">🖼 IA</button>
                <button id="btn-export-video" onclick="exportarVideo()" title="Exportar video">⬇</button>
                <button id="btn-cancel-export" onclick="cancelarExportacion()" style="display:none;" title="Cancelar exportación">✕</button>
                <button id="btn-fullscreen" onclick="toggleFullscreen()" title="Pantalla completa">⛶</button>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════
        // GRABACIÓN DE AUDIO (TTS + Música)
        // ═══════════════════════════════════════

        let mediaRecorder = null;
        let grabacionChunks = [];
        let grabando = false;
        let destinationNode = null;
        let audioCtxGrab = null;

        async function toggleGrabacion() {
            if (grabando) {
                detenerGrabacion();
            } else {
                iniciarGrabacion();
            }
        }

        async function iniciarGrabacion() {
            try {
                // Crear AudioContext compartido para mezclar TTS + música
                audioCtxGrab = getAudioCtx();

                const dest = audioCtxGrab.createMediaStreamDestination();
                destinationNode = dest;

                // Conectar música ambiental al stream de grabación
                if (ambientGainNode) ambientGainNode.connect(dest);

                // Para TTS del navegador necesitamos capturar el audio del sistema
                // Usamos un approach mixto: capturamos pantalla con audio del sistema
                let stream;
                try {
                    stream = await navigator.mediaDevices.getDisplayMedia({
                        video: false,
                        audio: { systemAudio: 'include' }
                    });
                    // Mezclar con la música del AudioContext
                    const sysSource = audioCtxGrab.createMediaStreamSource(stream);
                    sysSource.connect(dest);
                } catch (e) {
                    // Fallback: solo audio del AudioContext (música sin TTS si no hay permiso)
                    stream = dest.stream;
                    mostrarNotificacion('⚠ Solo se grabará la música (permite audio del sistema para incluir voz)');
                }

                // Combinar streams
                const tracks = [...dest.stream.getTracks()];
                if (stream && stream.getAudioTracks) {
                    stream.getAudioTracks().forEach(t => tracks.push(t));
                }
                const combinedStream = new MediaStream(tracks);

                grabacionChunks = [];
                mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'audio/webm' });
                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) grabacionChunks.push(e.data); };
                mediaRecorder.onstop = descargarAudio;
                mediaRecorder.start(100);

                grabando = true;
                const btn = document.getElementById('btn-rec-audio');
                btn.classList.add('recording');
                btn.querySelector('#rec-dot').textContent = '⏹';
                btn.childNodes[1].textContent = ' Detener grabación';
                mostrarNotificacion('🔴 Grabando...');

            } catch (e) {
                console.error('Error al iniciar grabación:', e);
                mostrarNotificacion('⚠ Error al iniciar grabación');
            }
        }

        function detenerGrabacion() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            grabando = false;
            const btn = document.getElementById('btn-rec-audio');
            btn.classList.remove('recording');
            btn.querySelector('#rec-dot').textContent = '⏺';
            btn.childNodes[1].textContent = ' Grabar audio';
            mostrarNotificacion('💾 Procesando audio...');
        }

        function descargarAudio() {
            const blob = new Blob(grabacionChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const capitulo = document.getElementById('current-chapter-title').textContent || 'lectura';
            a.download = `${capitulo.replace(/[^a-zA-Z0-9]/g, '_')}_audio.webm`;
            a.click();
            URL.revokeObjectURL(url);
            mostrarNotificacion('✓ Audio descargado');
        }

        // ═══════════════════════════════════════
        // KARAOKE / VISTA SPOTIFY
        // ═══════════════════════════════════════

        let karaokeAnimFrame = null;
        let karaokeCanvas = null;
        let karaokeCtx = null;
        let karaokeRecorder = null;
        let karaokeChunks = [];
        let karaokeActive = false;

        const KARAOKE_BG = '#0a0908';
        const KARAOKE_TEXT_DIM = '#5a5248';
        const KARAOKE_TEXT = '#e8e0d0';
        const KARAOKE_HIGHLIGHT = '#c8a96e';
        const KARAOKE_SECONDARY = 'rgba(200,169,110,0.3)';

        function abrirKaraoke() {
            const overlay = document.getElementById('karaoke-overlay');
            overlay.classList.add('active');
            karaokeCanvas = document.getElementById('karaoke-canvas');
            karaokeCtx = karaokeCanvas.getContext('2d');
            karaokeActive = true;

            const capitulo = document.getElementById('current-chapter-title').textContent || 'Capítulo';


            // Reiniciar sistema de imágenes IA para el nuevo capítulo
            aiSlotSolicitado = {};
            aiCurrentSlot = -1;
            aiActivePanel = 'a';
            aiSlotActivo = false;
            aiLoadingSlot = null;
            Object.keys(_aiSlotUrl).forEach(k => delete _aiSlotUrl[k]);
            _aiQueue.length = 0;
            document.getElementById('ai-bg-a').style.opacity = '0';
            document.getElementById('ai-bg-b').style.opacity = '0';
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
            if (aiImagesEnabled) {
                solicitarImagenParaSlot(0);
                solicitarImagenParaSlot(1);
            }

            renderKaraokeFrame();
            // Sincronizar sliders de volumen con los valores actuales
            setTimeout(() => document.dispatchEvent(new Event('karaokeOpened')), 100);
        }

        function cerrarKaraoke() {
            karaokeActive = false;
            document.getElementById('karaoke-overlay').classList.remove('active');
            if (karaokeAnimFrame) cancelAnimationFrame(karaokeAnimFrame);
            if (karaokeRecorder && karaokeRecorder.state !== 'inactive') karaokeRecorder.stop();
        }

        // Cerrar modo video con tecla Escape
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && karaokeActive) {
                cerrarKaraoke();
            }
        });

        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let line = '';
            for (const word of words) {
                const test = line ? line + ' ' + word : word;
                if (ctx.measureText(test).width > maxWidth && line) {
                    lines.push(line);
                    line = word;
                } else {
                    line = test;
                }
            }
            if (line) lines.push(line);
            return lines;
        }

        // Measures lines height for a text block
        function measureTextBlock(ctx, text, maxW, lineH) {
            return wrapText(ctx, text, maxW).length * lineH;
        }

        function drawKaraokeScene(ctx, W, H, current, total) {
            // Background: sólido si no hay imágenes IA, transparente si las hay
            if (aiImagesEnabled && aiSlotActivo) {
                ctx.clearRect(0, 0, W, H);
                // Overlay de viñeta leve sobre la imagen CSS
                ctx.fillStyle = 'rgba(8,7,6,0.35)';
                ctx.fillRect(0, 0, W, H);
            } else {
                ctx.fillStyle = KARAOKE_BG;
                ctx.fillRect(0, 0, W, H);
            }

            // Vignette
            const vignette = ctx.createRadialGradient(W / 2, H / 2, H * 0.2, W / 2, H / 2, H * 0.85);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.65)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, W, H);

            // Header: chapter title + counter
            ctx.font = '15px "Courier New", monospace';
            ctx.fillStyle = KARAOKE_TEXT_DIM;
            ctx.textAlign = 'left';
            ctx.fillText(document.getElementById('current-chapter-title').textContent, W * 0.1, 36);
            ctx.textAlign = 'right';
            ctx.fillText(`${current + 1} / ${total}`, W * 0.9, 36);

            if (!sentences || total === 0) {
                ctx.fillStyle = KARAOKE_TEXT_DIM;
                ctx.font = 'italic 26px "Georgia", serif';
                ctx.textAlign = 'center';
                ctx.fillText('Inicia la reproducción para ver el karaoke', W / 2, H / 2);
                return;
            }

            const MAX_W = W * 0.78;
            const CX = W / 2;

            // ── Layout dinámico: calcular alturas reales antes de dibujar ──
            const PREV_SIZE = 22;
            const CUR_SIZE = 36;
            const NEXT_SIZE = 20;
            const PREV_LH = 32;
            const CUR_LH = 52;
            const NEXT_LH = 30;
            const GAP = 28; // espacio entre bloques

            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            const curLines = wrapText(ctx, sentences[current] || '', MAX_W);
            const curBlockH = curLines.length * CUR_LH;

            ctx.font = `${PREV_SIZE}px "Georgia", serif`;
            const prevLines = current > 0 ? wrapText(ctx, sentences[current - 1], MAX_W) : [];
            const prevBlockH = prevLines.length * PREV_LH;

            ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
            const nextLines = current < total - 1 ? wrapText(ctx, sentences[current + 1], MAX_W) : [];
            const nextBlockH = nextLines.length * NEXT_LH;

            // Center the current block, then place prev above and next below
            const USABLE_TOP = 60;
            const USABLE_BOT = H - 60;
            const USABLE_H = USABLE_BOT - USABLE_TOP;

            const totalH = prevBlockH + (prevLines.length ? GAP : 0)
                + curBlockH
                + (nextLines.length ? GAP : 0)
                + nextBlockH;

            // Start Y so the whole layout is vertically centered
            let startY = USABLE_TOP + (USABLE_H - totalH) / 2;
            startY = Math.max(startY, USABLE_TOP + 10);

            let drawY = startY;

            // Draw previous (dim, above)
            if (prevLines.length) {
                ctx.font = `${PREV_SIZE}px "Georgia", serif`;
                ctx.fillStyle = KARAOKE_TEXT_DIM;
                ctx.textAlign = 'center';
                prevLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * PREV_LH);
                });
                drawY += prevBlockH + GAP;
            }

            // Draw current (highlighted, glow)
            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            ctx.textAlign = 'center';
            ctx.shadowColor = KARAOKE_HIGHLIGHT;
            ctx.shadowBlur = 18;
            ctx.fillStyle = KARAOKE_HIGHLIGHT;
            curLines.forEach((l, i) => {
                ctx.fillText(l, CX, drawY + i * CUR_LH);
            });
            ctx.shadowBlur = 0;
            drawY += curBlockH + GAP;

            // Draw next (very dim, below)
            if (nextLines.length) {
                ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
                ctx.fillStyle = 'rgba(200,169,110,0.22)';
                ctx.textAlign = 'center';
                nextLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * NEXT_LH);
                });
            }

            // Progress bar
            const prog = total > 1 ? (current / (total - 1)) : 1;
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.beginPath(); ctx.roundRect(W * 0.1, H - 38, W * 0.8, 3, 2); ctx.fill();
            ctx.fillStyle = KARAOKE_HIGHLIGHT;
            ctx.beginPath(); ctx.roundRect(W * 0.1, H - 38, W * 0.8 * prog, 3, 2); ctx.fill();

            // Music indicator
            if (ambientPlaying) {
                ctx.font = '16px monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(126,184,154,0.45)';
                ctx.fillText('♪', W * 0.1, H - 16);
            }

            // Indicador de carga de imagen IA
            if (aiImagesEnabled && aiLoadingSlot !== null) {
                ctx.font = '11px "Courier New", monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(126,184,154,0.45)';
                ctx.fillText('✦ generando imagen con IA...', W * 0.9, H - 16);
            }
        }

        function renderKaraokeFrame() {
            if (!karaokeActive) return;
            drawKaraokeScene(karaokeCtx, karaokeCanvas.width, karaokeCanvas.height,
                currentSentenceIndex, sentences.length);
            karaokeAnimFrame = requestAnimationFrame(renderKaraokeFrame);
        }

        // ── Generación de video en segundo plano (sin grabar en tiempo real) ──
        // Dibuja cada frame del karaoke a velocidad acelerada y los codifica
        let exportandoVideo = false;

        async function exportarVideo() {
            if (!sentences || sentences.length === 0) {
                mostrarNotificacion('Cargá y reproducí un capítulo primero');
                return;
            }
            if (exportandoVideo) { mostrarNotificacion('Ya hay una exportación en curso...'); return; }

            exportandoVideo = true;

            // Asegurar que el karaoke esté abierto (necesitamos el canvas)
            if (!karaokeActive) abrirKaraoke();

            const W = karaokeCanvas.width;
            const H = karaokeCanvas.height;
            const FPS = 24;
            // Estimar duración: promedio de 3.5 segundos por oración
            const SEC_PER_SENTENCE = 3.5;
            const totalSec = sentences.length * SEC_PER_SENTENCE;
            const totalFrames = Math.ceil(totalSec * FPS);

            mostrarNotificacion(`⏳ Generando ${sentences.length} escenas... (${Math.ceil(totalSec)}s de video)`);


            // Usar un canvas offscreen para no interferir con la vista live
            const offCanvas = document.createElement('canvas');
            offCanvas.width = W; offCanvas.height = H;
            const offCtx = offCanvas.getContext('2d');

            // Capturar el stream del offscreen canvas
            const stream = offCanvas.captureStream(FPS);

            // Agregar audio ambiental al stream si está disponible
            if (ambientGainNode) {
                try {
                    const actx = getAudioCtx();
                    const audioDest = actx.createMediaStreamDestination();
                    ambientGainNode.connect(audioDest);
                    audioDest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                } catch (e) { }
            }

            karaokeChunks = [];
            const mimeType = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm']
                .find(m => MediaRecorder.isTypeSupported(m)) || 'video/webm';

            karaokeRecorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 });
            karaokeRecorder.ondataavailable = e => { if (e.data.size > 0) karaokeChunks.push(e.data); };
            karaokeRecorder.onstop = () => {
                const blob = new Blob(karaokeChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const cap = (document.getElementById('current-chapter-title').textContent || 'lectura').trim();
                a.download = `${cap.replace(/[^a-zA-Z0-9áéíóúñ ]/g, '_')}_karaoke.webm`;
                a.click();
                URL.revokeObjectURL(url);
                exportandoVideo = false;
                document.getElementById('btn-export-video').style.display = 'inline';
                document.getElementById('btn-cancel-export').style.display = 'none';
                mostrarNotificacion('✓ Video generado y descargado');

            };

            karaokeRecorder.start();
            document.getElementById('btn-export-video').style.display = 'none';
            document.getElementById('btn-cancel-export').style.display = 'inline';

            // Renderizar frame a frame en segundo plano a mayor velocidad
            // ~4 frames por oración = transición suave sin que dure 30 min
            const FRAMES_PER_SENTENCE = FPS * SEC_PER_SENTENCE;
            let frameIdx = 0;

            const renderNext = () => {
                if (!exportandoVideo) { karaokeRecorder.stop(); return; }

                const sentenceIdx = Math.min(Math.floor(frameIdx / FRAMES_PER_SENTENCE), sentences.length - 1);
                const frameInSentence = frameIdx % FRAMES_PER_SENTENCE;
                const total = sentences.length;

                drawKaraokeScene(offCtx, W, H, sentenceIdx, total);

                // Transición suave: fade en los primeros/últimos frames de la oración
                if (frameInSentence < 8) {
                    const alpha = frameInSentence / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.7})`;
                    offCtx.fillRect(0, 0, W, H);
                } else if (frameInSentence > FRAMES_PER_SENTENCE - 8) {
                    const alpha = (FRAMES_PER_SENTENCE - frameInSentence) / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.5})`;
                    offCtx.fillRect(0, 0, W, H);
                }

                frameIdx++;

                // Progreso
                if (frameIdx % (FPS * 2) === 0) {
                    const pct = Math.round((frameIdx / totalFrames) * 100);

                }

                if (frameIdx >= totalFrames) {
                    // Último frame — pausa un momento y termina
                    setTimeout(() => karaokeRecorder.stop(), 300);
                    return;
                }

                // Usar setTimeout(0) para no bloquear el UI, pero ir rápido
                setTimeout(renderNext, 1000 / FPS / 4); // 4x más rápido que tiempo real
            };

            renderNext();
        }

        function cancelarExportacion() {
            exportandoVideo = false;
            if (karaokeRecorder && karaokeRecorder.state !== 'inactive') karaokeRecorder.stop();
            mostrarNotificacion('Exportación cancelada');
        }

        // ═══════════════════════════════════════
        // SISTEMA DE IMÁGENES IA — Claude + Pollinations.AI (model=flux)
        // ═══════════════════════════════════════

        let aiImagesEnabled = false;
        let aiSlotActivo = false;
        let aiLoadingSlot = null;
        let aiCurrentSlot = -1;
        let aiActivePanel = 'a';

        // Cambiar imagen cada ~280 chars acumulados (≈ 2-3 párrafos extensos)
        const AI_CHARS_PER_IMAGE = 280;
        let aiSlotSolicitado = {};
        let aiSentenceToSlot = [];   // idx oración → número de slot

        // Construir el mapa de slots basado en acumulación de chars reales
        function buildAiSlotMap() {
            aiSentenceToSlot = [];
            if (!sentences || sentences.length === 0) return;
            let slot = 0, chars = 0;
            for (let i = 0; i < sentences.length; i++) {
                aiSentenceToSlot[i] = slot;
                chars += sentences[i].length;
                if (chars >= AI_CHARS_PER_IMAGE) { slot++; chars = 0; }
            }
        }

        function getSlotForSentence(idx) {
            return (aiSentenceToSlot && aiSentenceToSlot[idx] !== undefined)
                ? aiSentenceToSlot[idx]
                : Math.floor(idx / 8);
        }

        // Fragmento de texto para un slot
        function extraerFragmentoParaSlot(slot) {
            if (!sentences || sentences.length === 0) return '';
            const idxs = aiSentenceToSlot
                .map((s, i) => s === slot ? i : -1)
                .filter(i => i >= 0);
            if (idxs.length === 0) return sentences.slice(0, 8).join(' ');
            // Incluir un poco de contexto previo para mejor coherencia
            const start = Math.max(0, idxs[0] - 3);
            const end = idxs[idxs.length - 1] + 1;
            return sentences.slice(start, end).join(' ');
        }

        // ── Detección automática del universo/libro ──
        let aiDetectedUniverse = null;

        const AI_UNIVERSES = {
            'shadow slave': 'Shadow Slave webnovel',
            'esclavo de las sombras': 'Shadow Slave webnovel',
            'forgotten shore': 'Shadow Slave webnovel',
            'guiltythree': 'Shadow Slave webnovel',
        };

        // Estilos base por universo detectado
        const AI_UNIVERSE_STYLES = {
            'Shadow Slave webnovel':
                'dark fantasy concept art, Shadow Slave webnovel visual style, ruined ancient citadel consumed by eldritch darkness, nightmare realm with shattered obsidian sky, bioluminescent corruption spreading across crumbling stone, golden divine light cutting through ash and shadow, nightmare creatures with multiple eyes, Dark Souls meets Diablo aesthetic, high-detail atmospheric digital painting, no text no watermark',
        };

        const AI_DEFAULT_STYLE = 'cinematic dark fantasy digital painting, dramatic chiaroscuro lighting, atmospheric depth, no text no watermark';

        function detectarUniverso() {
            const fuentes = [
                document.getElementById('file-name')?.textContent || '',
                document.getElementById('current-chapter-title')?.textContent || '',
                (sentences || []).slice(0, 30).join(' ')
            ].join(' ').toLowerCase();

            aiDetectedUniverse = null;
            for (const [key, val] of Object.entries(AI_UNIVERSES)) {
                if (fuentes.includes(key)) {
                    aiDetectedUniverse = val;
                    console.log(`📚 Universo detectado: ${val}`);
                    mostrarNotificacion(`📚 Estilo visual: ${val}`);
                    break;
                }
            }
        }

        function getStyleTag() {
            if (aiDetectedUniverse && AI_UNIVERSE_STYLES[aiDetectedUniverse]) {
                return AI_UNIVERSE_STYLES[aiDetectedUniverse];
            }
            return AI_DEFAULT_STYLE;
        }

        function toggleAIImages() {
            aiImagesEnabled = !aiImagesEnabled;
            const btn = document.getElementById('btn-toggle-ai-img');
            if (aiImagesEnabled) {
                btn.classList.add('ai-active');
                btn.textContent = '🖼 IA ON';
                detectarUniverso();
                buildAiSlotMap();
                mostrarNotificacion('🖼 Imágenes IA activadas');
                aiSlotSolicitado = {};
                aiCurrentSlot = -1;
                aiActivePanel = 'a';
                const slot = getSlotForSentence(typeof currentSentenceIndex !== 'undefined' ? currentSentenceIndex : 0);
                solicitarImagenParaSlot(slot);
                setTimeout(() => solicitarImagenParaSlot(slot + 1), 800);
                setTimeout(() => solicitarImagenParaSlot(slot + 2), 1600);
            } else {
                btn.classList.remove('ai-active');
                btn.textContent = '🖼 IA Imágenes';
                document.getElementById('ai-bg-a').style.opacity = '0';
                document.getElementById('ai-bg-b').style.opacity = '0';
                document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
                aiSlotActivo = false;
                mostrarNotificacion('Imágenes IA desactivadas');
            }
        }

        // ── Cache de prompts ──
        const aiPromptCache = {};

        // Genera el prompt visual usando Pollinations GET API (sin CORS, sin key, sin POST)
        async function generarPromptConClaude(fragmento) {
            const cacheKey = fragmento.slice(0, 100);
            if (aiPromptCache[cacheKey]) return aiPromptCache[cacheKey];

            const styleTag = getStyleTag();
            const universeHint = aiDetectedUniverse
                ? `From webnovel "${aiDetectedUniverse}", match its visual style.`
                : '';

            // System prompt compacto
            const systemPrompt = `You are an image prompt generator. ${universeHint} Given a fiction passage, output ONLY an English image generation prompt (max 60 words): describe the specific environment, mood, lighting, time of day; never name characters, describe by silhouette or role only; always end with: "${styleTag}". No preamble.`;

            // Texto del pasaje
            const pasaje = fragmento.slice(0, 350).replace(/"/g, "'");

            // Helper: detectar si el texto es el aviso de deprecación u otro error
            function esRespuestaInvalida(txt) {
                return !txt || txt.length < 20 ||
                    txt.includes('IMPORTANT NOTICE') ||
                    txt.includes('deprecated') ||
                    txt.includes('DEPRECATED') ||
                    txt.includes('please update') ||
                    txt.includes('Please update') ||
                    txt.toUpperCase().includes('NOTICE');
            }

            // Intentar con Pollinations (timeout corto para no bloquear)
            try {
                const ctrl = new AbortController();
                const timer = setTimeout(() => ctrl.abort(), 6000);
                const res = await fetch('https://text.pollinations.ai/openai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'mistral',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: pasaje }
                        ],
                        private: true,
                        seed: Math.floor(Math.random() * 9999)
                    }),
                    signal: ctrl.signal
                });
                clearTimeout(timer);
                if (res.ok) {
                    const data = await res.json();
                    let prompt = (data?.choices?.[0]?.message?.content || '').trim();
                    prompt = prompt.split('\n')[0].trim();
                    if (!esRespuestaInvalida(prompt)) {
                        aiPromptCache[cacheKey] = prompt;
                        console.log('Prompt (Pollinations/mistral):', prompt.slice(0, 80));
                        return prompt;
                    }
                }
            } catch (e) { /* timeout o error — usar prompt local */ }

            // Prompt local: extracción semántica sin LLM
            const promptLocal = construirPromptDirecto(fragmento, styleTag);
            aiPromptCache[cacheKey] = promptLocal;
            console.log('Prompt (local):', promptLocal.slice(0, 80));
            return promptLocal;
        }

        // Generador de prompts sin LLM — extrae entidades reales del texto
        function construirPromptDirecto(fragmento, styleTag) {
            const t = fragmento.toLowerCase();
            const parts = [];

            // — ESCENARIO —
            if (/laboratorio|lab|experiment|científico|scientist/.test(t)) parts.push('underground science laboratory, flickering monitors, cables everywhere');
            else if (/hospital|enfermería|nurse|médico|doctor|clínica/.test(t)) parts.push('abandoned hospital corridor, flickering fluorescent lights, sterile decay');
            else if (/prisión|celda|prison|jail|dungeon|calabozo/.test(t)) parts.push('stone dungeon cell, iron bars, dripping walls');
            else if (/mansión|manor|palacio|palace|salón|hall/.test(t)) parts.push('grand decaying mansion interior, ornate but crumbling');
            else if (/bosque|selva|forest|jungle|árbol|tree/.test(t)) parts.push('ancient dark forest, gnarled roots, fog between trees');
            else if (/ciudad|city|calle|street|edificio|building|urbano/.test(t)) parts.push('dystopian urban sprawl, neon reflections on wet asphalt, towering structures');
            else if (/castillo|fortress|torre|tower|muralla|castle/.test(t)) parts.push('ancient stone fortress at dusk, crumbling battlements, ravens circling');
            else if (/cueva|cave|cavern|túnel|tunnel|underground/.test(t)) parts.push('vast underground cavern, bioluminescent fungi, stalactites');
            else if (/desierto|wasteland|arena|sand|desert/.test(t)) parts.push('scorched wasteland under blood-red sky, cracked earth, ruins in distance');
            else if (/mar|ocean|sea|costa|coast|playa|beach|puerto/.test(t)) parts.push('storm-lashed ocean coast, massive waves, jagged cliffs');
            else if (/montaña|mountain|cumbre|peak|cliff|acantilado/.test(t)) parts.push('treacherous mountain peaks shrouded in mist, sheer drop below');
            else if (/templo|temple|shrine|sanctuario|altar/.test(t)) parts.push('ancient temple interior, moss-covered stone pillars, shafts of divine light');
            else if (/mercado|market|plaza|tavern|taberna|inn/.test(t)) parts.push('crowded medieval marketplace, torchlit stalls, cobblestone streets');
            else if (/nave|spaceship|space|cosmos|espacio|galaxy/.test(t)) parts.push('deep space void, distant nebula, derelict starship hull');
            else parts.push('vast desolate realm, broken landscape, oppressive silence');

            // — ACCIÓN / TENSIÓN —
            if (/batalla|combate|fight|battle|lucha|clash|guerra|war/.test(t)) parts.push('mid-battle chaos, dust and sparks');
            else if (/huir|escape|chase|perseguir|run|correr/.test(t)) parts.push('desperate chase, motion blur, panic in the air');
            else if (/ritual|ceremony|spell|hechizo|magia|magic/.test(t)) parts.push('arcane ritual in progress, glowing sigils, dark energy swirling');
            else if (/muerte|death|dead|matar|kill|sangre|blood/.test(t)) parts.push('aftermath of violence, ominous stillness');
            else if (/reunión|meeting|gather|consejo|council/.test(t)) parts.push('tense gathering of shadowed figures');
            else if (/silencio|quiet|alone|soledad|lonely/.test(t)) parts.push('solitary figure in vast emptiness');

            // — HORA Y LUZ —
            if (/amanecer|dawn|sunrise|alba/.test(t)) parts.push('cold dawn light breaking through clouds');
            else if (/atardecer|sunset|dusk|crepúsculo/.test(t)) parts.push('deep amber sunset casting long shadows');
            else if (/noche|night|midnight|medianoche|oscuridad/.test(t)) parts.push('moonless night, only distant stars');
            else if (/mediodía|noon|midday|sol|bright|sunlight/.test(t)) parts.push('harsh midday sun, deep shadows');
            else if (/lluvia|rain|storm|tormenta|thunder|trueno/.test(t)) parts.push('driving rain, lightning illuminating the scene');
            else if (/niebla|fog|mist|neblina/.test(t)) parts.push('thick fog, diffused ghostly light');
            else if (/fuego|fire|llama|flame|antorcha|torch/.test(t)) parts.push('dramatic firelight, dancing orange shadows');
            else parts.push('dim atmospheric light, deep chiaroscuro');

            // — PERSONAJES (por rol, nunca por nombre) —
            if (/guerrero|warrior|knight|caballero|soldier|soldado/.test(t)) parts.push('armored silhouette in foreground');
            else if (/mago|wizard|sorcerer|brujo|mage/.test(t)) parts.push('robed figure wreathed in magical energy');
            else if (/asesino|assassin|rogue|ladrón|thief/.test(t)) parts.push('cloaked figure in deep shadow');
            else if (/monstruo|monster|beast|bestia|creature|criatura/.test(t)) parts.push('massive terrifying creature emerging from darkness');
            else if (/rey|king|queen|reina|emperor|emperador/.test(t)) parts.push('commanding royal silhouette on throne');

            // — MOOD —
            if (/esperanza|hope|victory|victoria|triumph/.test(t)) parts.push('faint hopeful glimmer amid darkness');
            else if (/terror|horror|miedo|dread|fear/.test(t)) parts.push('oppressive dread, wrongness in the air');
            else if (/misterio|mystery|secret|secreto/.test(t)) parts.push('mysterious and unsettling atmosphere');
            else parts.push('cinematic epic atmosphere');

            return parts.join(', ') + ', ' + styleTag;
        }

        // URL de Pollinations — model=flux, parámetros documentados
        function pollinationsUrl(prompt, seed) {
            const encoded = encodeURIComponent(prompt);
            return `https://image.pollinations.ai/prompt/${encoded}?model=flux&width=1280&height=720&seed=${seed}&nologo=true&private=true`;
        }

        // ═══════════════════════════════════════
        // GENERADOR DE FONDOS PROCEDURAL (Canvas 2D)
        // Sin APIs externas — 100% local, instantáneo
        // ═══════════════════════════════════════

        // Paletas de colores por tipo de escena (derivadas del prompt construido localmente)
        const SCENE_PALETTES = {
            forest: { sky: ['#0a0f0a', '#0d1a0e', '#081208'], mid: ['#1a2e1a', '#0f2010'], fog: '#1a2a1a', stars: false },
            city: { sky: ['#050810', '#080c18', '#060a14'], mid: ['#0a1020', '#151c2e'], fog: '#0d1525', stars: true, neon: true },
            dungeon: { sky: ['#080608', '#100a08', '#0a0608'], mid: ['#1a1008', '#120c06'], fog: '#100808', stars: false },
            desert: { sky: ['#1a0a04', '#200c06', '#180a04'], mid: ['#2a1008', '#1e0c06'], fog: '#200a06', stars: false },
            ocean: { sky: ['#040810', '#06101a', '#040c16'], mid: ['#081428', '#0a1830'], fog: '#060e1e', stars: true },
            castle: { sky: ['#08060c', '#100810', '#0c060a'], mid: ['#180a18', '#140810'], fog: '#0e060c', stars: true },
            cave: { sky: ['#040408', '#060610', '#040408'], mid: ['#080820', '#060618'], fog: '#040412', stars: false, glow: true },
            temple: { sky: ['#0a0806', '#120e08', '#0e0a04'], mid: ['#1e160a', '#180e06'], fog: '#140c06', stars: false },
            space: { sky: ['#020206', '#04040c', '#020208'], mid: ['#06040e', '#080614'], fog: '#040410', stars: true, nebula: true },
            hospital: { sky: ['#080c0a', '#0a100c', '#060a08'], mid: ['#0e1410', '#0c120e'], fog: '#0a1008', stars: false },
            mansion: { sky: ['#080608', '#0e0a0c', '#0a0808'], mid: ['#160e12', '#120c10'], fog: '#100a0e', stars: false },
            default: { sky: ['#060608', '#080810', '#060608'], mid: ['#0c0c14', '#0a0a10'], fog: '#080810', stars: true },
        };

        // Detectar tipo de escena desde el prompt textual
        function detectarTipoEscena(prompt) {
            const t = prompt.toLowerCase();
            if (/forest|bosque|jungle|selva|tree|árbol|gnarled|ancient dark/.test(t)) return 'forest';
            if (/city|ciudad|urban|neon|asphalt|building|edificio|dystopian/.test(t)) return 'city';
            if (/dungeon|celda|prison|jail|stone|calabozo/.test(t)) return 'dungeon';
            if (/desert|wasteland|desierto|sand|arena|scorched/.test(t)) return 'desert';
            if (/ocean|sea|mar|coast|costa|wave|cliff/.test(t)) return 'ocean';
            if (/castle|fortress|castillo|battlement|raven/.test(t)) return 'castle';
            if (/cave|cavern|cueva|stalactite|bioluminescent|underground/.test(t)) return 'cave';
            if (/temple|altar|shrine|templo|pillar/.test(t)) return 'temple';
            if (/space|cosmos|nebula|starship|galaxy|espacio/.test(t)) return 'space';
            if (/hospital|clinic|corridor|fluorescent/.test(t)) return 'hospital';
            if (/mansion|manor|palace|palacio|hall|grand/.test(t)) return 'mansion';
            return 'default';
        }

        // Dibuja el fondo procedural en el div usando un canvas temporal
        function dibujarFondoProcedural(slot, prompt) {
            if (!aiImagesEnabled) return;

            const tipo = detectarTipoEscena(prompt);
            const pal = SCENE_PALETTES[tipo] || SCENE_PALETTES.default;
            const seed = slot * 113 + 7;
            const rng = (n => { let s = seed + n; return () => { s = (s * 16807 + 0) % 2147483647; return (s - 1) / 2147483646; }; })(0);

            // Crear canvas offscreen
            const W = 1280, H = 720;
            const cv = document.createElement('canvas');
            cv.width = W; cv.height = H;
            const c = cv.getContext('2d');

            // — Gradiente de cielo —
            const skyGrad = c.createLinearGradient(0, 0, 0, H * 0.65);
            skyGrad.addColorStop(0, pal.sky[0]);
            skyGrad.addColorStop(0.5, pal.sky[1]);
            skyGrad.addColorStop(1, pal.sky[2] || pal.sky[1]);
            c.fillStyle = skyGrad;
            c.fillRect(0, 0, W, H);

            // — Estrellas —
            if (pal.stars) {
                for (let i = 0; i < 180; i++) {
                    const x = rng() * W, y = rng() * H * 0.6;
                    const r = rng() * 1.2 + 0.3;
                    const alpha = rng() * 0.7 + 0.3;
                    c.beginPath();
                    c.arc(x, y, r, 0, Math.PI * 2);
                    c.fillStyle = `rgba(255,245,230,${alpha})`;
                    c.fill();
                }
            }

            // — Nebulosa (espacio) —
            if (pal.nebula) {
                for (let i = 0; i < 3; i++) {
                    const nx = rng() * W, ny = rng() * H * 0.5;
                    const nr = 80 + rng() * 120;
                    const colors = ['rgba(80,40,120,', 'rgba(40,60,120,', 'rgba(100,30,80,'];
                    const ng = c.createRadialGradient(nx, ny, 0, nx, ny, nr);
                    ng.addColorStop(0, colors[i % 3] + '0.18)');
                    ng.addColorStop(1, colors[i % 3] + '0)');
                    c.fillStyle = ng;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Luces de neón (ciudad) —
            if (pal.neon) {
                const neonColors = ['rgba(0,200,255,', 'rgba(255,50,150,', 'rgba(80,255,180,', 'rgba(255,180,0,'];
                for (let i = 0; i < 5; i++) {
                    const nx = rng() * W, ny = H * 0.4 + rng() * H * 0.3;
                    const nr = 30 + rng() * 60;
                    const col = neonColors[Math.floor(rng() * neonColors.length)];
                    const ng = c.createRadialGradient(nx, ny, 0, nx, ny, nr);
                    ng.addColorStop(0, col + '0.12)');
                    ng.addColorStop(1, col + '0)');
                    c.fillStyle = ng;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Brillo bioluminiscente (cueva) —
            if (pal.glow) {
                for (let i = 0; i < 8; i++) {
                    const gx = rng() * W, gy = H * 0.3 + rng() * H * 0.5;
                    const gr = 15 + rng() * 40;
                    const glowColors = ['rgba(80,180,255,', 'rgba(100,255,200,', 'rgba(160,100,255,'];
                    const col = glowColors[Math.floor(rng() * glowColors.length)];
                    const gg = c.createRadialGradient(gx, gy, 0, gx, gy, gr);
                    gg.addColorStop(0, col + '0.25)');
                    gg.addColorStop(1, col + '0)');
                    c.fillStyle = gg;
                    c.fillRect(0, 0, W, H);
                }
            }

            // — Siluetas de fondo (elementos medios) —
            const numShapes = 6 + Math.floor(rng() * 5);
            for (let i = 0; i < numShapes; i++) {
                const x = (i / numShapes) * W + (rng() - 0.5) * (W / numShapes);
                const baseH = H * (0.3 + rng() * 0.3);
                const w = W / numShapes * (0.6 + rng() * 0.8);
                const col = pal.mid[Math.floor(rng() * pal.mid.length)];

                if (tipo === 'forest') {
                    // Árboles
                    c.fillStyle = col;
                    c.beginPath();
                    c.moveTo(x, H);
                    c.lineTo(x - w * 0.5, baseH);
                    c.lineTo(x - w * 0.25, baseH + H * 0.08);
                    c.lineTo(x - w * 0.45, baseH - H * 0.1);
                    c.lineTo(x, baseH - H * 0.18);
                    c.lineTo(x + w * 0.45, baseH - H * 0.1);
                    c.lineTo(x + w * 0.25, baseH + H * 0.08);
                    c.lineTo(x + w * 0.5, baseH);
                    c.closePath();
                    c.fill();
                } else if (tipo === 'city') {
                    // Rascacielos
                    const bW = w * 0.5 + rng() * w * 0.4;
                    const bH = baseH + rng() * H * 0.2;
                    c.fillStyle = col;
                    c.fillRect(x - bW / 2, bH, bW, H - bH);
                    // Ventanas
                    c.fillStyle = rng() > 0.7 ? 'rgba(255,220,100,0.15)' : 'rgba(100,180,255,0.08)';
                    for (let wy = bH + 8; wy < H - 10; wy += 14) {
                        for (let wx = x - bW / 2 + 5; wx < x + bW / 2 - 5; wx += 10) {
                            if (rng() > 0.4) c.fillRect(wx, wy, 5, 7);
                        }
                    }
                } else if (tipo === 'castle' || tipo === 'mansion') {
                    // Torres
                    const tW = w * 0.4;
                    c.fillStyle = col;
                    c.fillRect(x - tW / 2, baseH, tW, H - baseH);
                    // Almenas
                    for (let m = x - tW / 2; m < x + tW / 2; m += tW / 3) {
                        c.fillRect(m, baseH - H * 0.05, tW / 4, H * 0.05);
                    }
                } else {
                    // Forma genérica: colina/roca
                    c.fillStyle = col;
                    c.beginPath();
                    c.moveTo(x - w * 0.7, H);
                    c.quadraticCurveTo(x, baseH, x + w * 0.7, H);
                    c.closePath();
                    c.fill();
                }
            }

            // — Niebla / bruma en el suelo —
            const fogGrad = c.createLinearGradient(0, H * 0.65, 0, H);
            fogGrad.addColorStop(0, pal.fog + '00');
            fogGrad.addColorStop(0.4, pal.fog + 'aa');
            fogGrad.addColorStop(1, pal.fog + 'ff');
            c.fillStyle = fogGrad;
            c.fillRect(0, H * 0.55, W, H * 0.45);

            // — Viñeta dramática en los bordes —
            const vig = c.createRadialGradient(W / 2, H / 2, H * 0.2, W / 2, H / 2, H * 0.9);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.72)');
            c.fillStyle = vig;
            c.fillRect(0, 0, W, H);

            // Convertir a data URL y mostrar como fondo
            const dataUrl = cv.toDataURL('image/jpeg', 0.88);
            mostrarImagenEnPanel(slot, dataUrl);
            console.log(`🎨 Fondo procedural generado — slot ${slot} (${tipo})`);
        }

        // Cola de slots pendientes para respetar el rate-limit de Pollinations (~1 req/15s anon)
        const _aiQueue = [];
        let _aiQueueRunning = false;

        async function _processAiQueue() {
            if (_aiQueueRunning) return;
            _aiQueueRunning = true;
            while (_aiQueue.length > 0) {
                const { prompt, seed, slot } = _aiQueue.shift();
                await _cargarPollinations(prompt, seed, slot);
                // Pollinations pide ~1 req/15s en tier anónimo; 12s = margen seguro
                if (_aiQueue.length > 0) await new Promise(r => setTimeout(r, 12000));
            }
            _aiQueueRunning = false;
        }

        async function _cargarPollinations(prompt, seed, slot) {
            if (!aiImagesEnabled) return;
            const url = pollinationsUrl(prompt, seed);
            console.log(`🖼 Cargando Pollinations — slot ${slot}:`, prompt.slice(0, 60));

            // Mostrar fondo procedural inmediatamente mientras espera
            dibujarFondoProcedural(slot, prompt);

            return new Promise((resolve) => {
                const img = new Image();
                const timeout = setTimeout(() => {
                    console.warn(`⚠ Timeout Pollinations slot ${slot} — manteniendo procedural`);
                    resolve();
                }, 55000); // 55s timeout

                img.onload = () => {
                    clearTimeout(timeout);
                    if (!aiImagesEnabled) { resolve(); return; }
                    // Reemplazar el fondo procedural con la imagen real (force=true)
                    mostrarImagenEnPanel(slot, url, true);
                    console.log(`✅ Imagen Pollinations cargada — slot ${slot}`);
                    resolve();
                };

                img.onerror = () => {
                    clearTimeout(timeout);
                    console.warn(`❌ Error Pollinations slot ${slot} — manteniendo procedural`);
                    resolve();
                };

                img.src = url;
            });
        }

        async function cargarImagenConFallback(prompt, seed, slot) {
            // Encolar para respetar rate-limit; procedural aparece inmediatamente
            _aiQueue.push({ prompt, seed, slot });
            _processAiQueue();
        }

        async function solicitarImagenParaSlot(slot) {
            if (slot < 0 || aiSlotSolicitado[slot]) return;
            aiSlotSolicitado[slot] = true;
            if (aiLoadingSlot === null) aiLoadingSlot = slot;

            const fragmento = extraerFragmentoParaSlot(slot);
            if (!fragmento) { if (aiLoadingSlot === slot) aiLoadingSlot = null; return; }

            console.log(`🧠 Generando prompt — slot ${slot}`);
            const prompt = await generarPromptConClaude(fragmento);
            const seed = slot * 113 + 7;
            cargarImagenConFallback(prompt, seed, slot);
        }

        // Guarda la URL actual mostrada por slot para detectar upgrade procedural→Pollinations
        const _aiSlotUrl = {};

        function mostrarImagenEnPanel(slot, url, force) {
            if (!aiImagesEnabled) return;

            // Si el slot ya está activo con la MISMA url, no hacer nada
            if (_aiSlotUrl[slot] === url) return;

            // Si es un slot distinto al activo Y no es force (upgrade Pollinations), ignorar slots muy viejos
            if (slot !== aiCurrentSlot && !force && slot < aiCurrentSlot - 1) return;

            const esMismoSlot = (slot === aiCurrentSlot);

            const panelAct = aiActivePanel === 'a' ? 'ai-bg-a' : 'ai-bg-b';
            const panelPrev = aiActivePanel === 'a' ? 'ai-bg-b' : 'ai-bg-a';
            const divAct = document.getElementById(panelAct);
            const divPrev = document.getElementById(panelPrev);

            if (esMismoSlot) {
                // Upgrade en el panel activo sin crossfade (ya está visible)
                divAct.style.backgroundImage = `url("${url}")`;
            } else {
                // Nuevo slot: crossfade al panel inactivo
                divPrev.style.backgroundImage = `url("${url}")`;
                divPrev.style.opacity = '1';
                divAct.style.opacity = '0';
                aiActivePanel = aiActivePanel === 'a' ? 'b' : 'a';
                aiCurrentSlot = slot;
            }

            _aiSlotUrl[slot] = url;
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0.48)';
            aiSlotActivo = true;
        }

        // Se llama en cada cambio de oración desde main.js
        function actualizarSlideAI(sentenceIdx) {
            if (!aiImagesEnabled) return;

            const slotActual = getSlotForSentence(sentenceIdx);
            solicitarImagenParaSlot(slotActual);

            // Pre-cargar slots siguientes con delay escalonado para no saturar APIs
            // Slot+1: empezar cuando slot actual ya está en cola (800ms)
            // Slot+2: solo si los anteriores ya están procesando (1600ms)
            setTimeout(() => solicitarImagenParaSlot(slotActual + 1), 800);
            setTimeout(() => solicitarImagenParaSlot(slotActual + 2), 1600);
        }

        // ═══════════════════════════════════════
        // CONTROLES DE MODO VIDEO (play/pause + nav capítulos)
        // ═══════════════════════════════════════

        function karaokeTogglePlay() {
            const btn = document.getElementById('kbtn-playpause');
            if (!isReading || isPaused) {
                // Si nunca se inició o está pausado → iniciar/reanudar
                if (!isReading) {
                    iniciarTTS();
                } else {
                    reanudarTTS();
                }
                btn.innerHTML = '&#9646;&#9646;'; // pausa
                btn.classList.remove('paused');
            } else {
                pausarTTS();
                btn.innerHTML = '&#9654;'; // play
                btn.classList.add('paused');
            }
        }

        // Sincronizar el ícono del botón cuando el TTS se detiene/pausa desde afuera
        const _origDetenerTTS = window.detenerTTS;
        window.detenerTTS = function () {
            if (typeof _origDetenerTTS === 'function') _origDetenerTTS();
            const btn = document.getElementById('kbtn-playpause');
            if (btn) { btn.innerHTML = '&#9654;'; btn.classList.remove('paused'); }
        };

        function _getChapterOptions() {
            return Array.from(document.getElementById('chapters').options)
                .filter(o => !o.disabled && o.value);
        }

        function karaokeCapituloAnterior() {
            const sel = document.getElementById('chapters');
            const opts = _getChapterOptions();
            const idx = opts.findIndex(o => o.value === sel.value);
            if (idx > 0) {
                sel.value = opts[idx - 1].value;
                sel.dispatchEvent(new Event('change'));
                // Reiniciar TTS con el nuevo capítulo
                setTimeout(() => { detenerTTS(); iniciarTTS(); }, 300);
            } else {
                mostrarNotificacion('Ya estás en el primer capítulo');
            }
        }

        function karaokeCapituloSiguiente() {
            const sel = document.getElementById('chapters');
            const opts = _getChapterOptions();
            const idx = opts.findIndex(o => o.value === sel.value);
            if (idx < opts.length - 1) {
                sel.value = opts[idx + 1].value;
                sel.dispatchEvent(new Event('change'));
                setTimeout(() => { detenerTTS(); iniciarTTS(); }, 300);
            } else {
                mostrarNotificacion('Ya estás en el último capítulo');
            }
        }

        // ═══════════════════════════════════════
        // CONTROLES DE MÚSICA DESDE MODO VIDEO
        // ═══════════════════════════════════════

        const GENRE_ORDER = ['mystery', 'suspense', 'drama', 'action', 'fantasy', 'romance', 'lofi', 'nature'];

        function _genreIdx() {
            return ambientGenre ? GENRE_ORDER.indexOf(ambientGenre) : -1;
        }

        async function karaokeMusicaSiguiente() {
            const idx = _genreIdx();
            const next = GENRE_ORDER[(idx + 1) % GENRE_ORDER.length];
            await selectGenre(next);
            _actualizarMusicLabel();
        }

        async function karaokeMusicaPrev() {
            const idx = _genreIdx();
            const prev = GENRE_ORDER[(idx - 1 + GENRE_ORDER.length) % GENRE_ORDER.length];
            await selectGenre(prev);
            _actualizarMusicLabel();
        }

        function _actualizarMusicLabel() {
            const lbl = document.getElementById('karaoke-music-label');
            if (!lbl) return;
            const trackName = document.getElementById('ambient-track-name');
            lbl.textContent = trackName ? trackName.textContent : (ambientGenre || '♪');
        }

        // Sincronizar label de música cuando cambia el track
        const _origAmbientTrackName = Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
        setInterval(_actualizarMusicLabel, 2000); // sync pasivo cada 2s

        // ═══════════════════════════════════════
        // BUSCADOR DE CAPÍTULOS
        // ═══════════════════════════════════════

        // Guardar todas las opciones originales una vez cargado el EPUB
        let _todasLasOpciones = [];

        // Observer para capturar las opciones cuando se populan
        const _chaptersObserver = new MutationObserver(() => {
            const opts = _getChapterOptions();
            if (opts.length > 0) _todasLasOpciones = opts.map(o => ({ value: o.value, text: o.textContent }));
        });
        _chaptersObserver.observe(document.getElementById('chapters'), { childList: true });

        function filtrarCapitulos(query) {
            const sel = document.getElementById('chapters');
            const q = query.trim().toLowerCase();

            // Si no hay snapshot aún, tomarlo ahora
            if (_todasLasOpciones.length === 0) {
                _todasLasOpciones = _getChapterOptions().map(o => ({ value: o.value, text: o.textContent }));
            }

            // Restaurar todas las opciones y luego ocultar las que no coinciden
            // (los <option> no tienen display, así que se re-renderizan)
            const valorActual = sel.value;
            sel.innerHTML = '';

            const filtradas = q
                ? _todasLasOpciones.filter(o => o.text.toLowerCase().includes(q))
                : _todasLasOpciones;

            if (filtradas.length === 0) {
                const empty = document.createElement('option');
                empty.disabled = true;
                empty.textContent = '— sin resultados —';
                sel.appendChild(empty);
                return;
            }

            filtradas.forEach(({ value, text }) => {
                const opt = document.createElement('option');
                opt.value = value;
                opt.textContent = text;
                if (value === valorActual) opt.selected = true;
                sel.appendChild(opt);
            });
        }

        // ═══════════════════════════════════════
        // PANTALLA COMPLETA
        // ═══════════════════════════════════════
        function toggleFullscreen() {
            const btn = document.getElementById('btn-fullscreen');
            if (!document.fullscreenElement) {
                // Fullscreen en documentElement para evitar congelamiento del navegador
                document.documentElement.requestFullscreen().then(() => {
                    btn.textContent = '✕FS';
                    btn.title = 'Salir de pantalla completa';
                }).catch(e => console.warn('Fullscreen error:', e.message));
            } else {
                document.exitFullscreen().catch(() => { });
            }
        }
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('btn-fullscreen');
            if (!btn) return;
            if (!document.fullscreenElement) {
                btn.textContent = '⛶';
                btn.title = 'Pantalla completa';
            }
        });

        // ═══════════════════════════════════════
        // VOLUMEN TTS INDEPENDIENTE
        // ═══════════════════════════════════════
        function setTTSVolume(val) {
            const v = parseFloat(val) / 100;
            // Aplicar al audio local (XTTS API)
            if (typeof audioActual !== 'undefined' && audioActual) {
                audioActual.volume = v;
            }
            // Sincronizar con el control de volumen principal del sidebar
            const mainVol = document.getElementById('volume-control');
            if (mainVol) {
                mainVol.value = val;
                const lbl = document.getElementById('volume-value');
                if (lbl) lbl.textContent = val;
            }
        }
        // Sincronizar sliders al abrir el modo video
        document.addEventListener('karaokeOpened', () => {
            const vol = document.getElementById('volume-control');
            if (vol) {
                const v = vol.value;
                const ttsSlider = document.getElementById('kol-tts-vol');
                const ttsPct = document.getElementById('kol-tts-pct');
                if (ttsSlider) ttsSlider.value = v;
                if (ttsPct) ttsPct.textContent = v + '%';
            }
            const ambVol = document.getElementById('ambient-volume');
            if (ambVol) {
                const av = ambVol.value;
                const musicSlider = document.getElementById('kol-music-vol');
                const musicPct = document.getElementById('kol-music-pct');
                if (musicSlider) musicSlider.value = av;
                if (musicPct) musicPct.textContent = av + '%';
            }
        });

        // ═══════════════════════════════════════
        // AUTO-SIGUIENTE PISTA DE MÚSICA
        // ═══════════════════════════════════════
        async function _onTrackEnded() {
            console.log('🎵 Pista terminada — cargando siguiente...');
            if (typeof ambientGenre !== 'undefined' && ambientGenre) {
                await siguienteTrack();
            }
        }
        // Vigilar freesoundAudio para enganchar el evento 'ended'
        let _lastHookedAudio = null;
        setInterval(() => {
            if (typeof freesoundAudio !== 'undefined' && freesoundAudio && freesoundAudio !== _lastHookedAudio) {
                _lastHookedAudio = freesoundAudio;
                freesoundAudio.loop = false;  // Desactivar loop para que dispare 'ended'
                freesoundAudio.addEventListener('ended', _onTrackEnded);
                console.log('🎵 Auto-next enganchado al track actual');
            }
        }, 1000);

    </script>

</body>
</html>