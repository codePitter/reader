<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lector EPUB con TTS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://js.puter.com/v2/"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0f0e0c;
            --surface: #1a1814;
            --surface2: #242018;
            --border: #2e2a22;
            --accent: #c8a96e;
            --accent2: #7eb89a;
            --text: #e8e0d0;
            --text-muted: #8a8070;
            --text-dim: #5a5248;
            --sidebar-w: 300px;
        }

        body {
            font-family: 'DM Mono', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* ─── MAIN CONTENT (LEFT 80%) ─── */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-right: 1px solid var(--border);
        }

        .top-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 28px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

            .top-bar h1 {
                font-family: 'Lora', serif;
                font-size: 1.15rem;
                font-weight: 600;
                color: var(--accent);
                letter-spacing: 0.02em;
            }

            .top-bar .subtitle {
                font-size: 0.7rem;
                color: var(--text-muted);
                margin-left: auto;
            }

        .stats-bar {
            display: flex;
            gap: 24px;
            padding: 8px 28px;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .stat {
            font-size: 0.65rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 5px;
        }

            .stat strong {
                color: var(--accent);
                font-weight: 500;
            }

        /* Reading area */
        .reading-area {
            flex: 1;
            overflow-y: auto;
            padding: 48px 80px;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .reading-area::-webkit-scrollbar {
                width: 4px;
            }

            .reading-area::-webkit-scrollbar-track {
                background: transparent;
            }

            .reading-area::-webkit-scrollbar-thumb {
                background: var(--border);
                border-radius: 2px;
            }

        #texto-contenido {
            font-family: 'Lora', serif;
            font-size: 1.1rem;
            line-height: 1.85;
            color: var(--text);
            max-width: 680px;
            margin: 0 auto;
        }

            #texto-contenido p {
                margin-bottom: 1.2em;
            }

        /* Progress bar at bottom of reading area */
        .progress-wrap {
            flex-shrink: 0;
            padding: 0 28px 0;
            background: var(--surface);
            border-top: 1px solid var(--border);
        }

        .progress-track {
            height: 2px;
            background: var(--border);
            position: relative;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            width: 0%;
            transition: width 0.3s ease;
        }

        .tts-status-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 8px 0;
            font-size: 0.65rem;
            color: var(--text-dim);
        }

        .tts-percent-badge {
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 0.6rem;
            color: var(--accent);
            font-weight: 500;
        }

        /* Editor panel (collapsible) */
        .editor-panel {
            flex-shrink: 0;
            background: var(--surface2);
            border-top: 1px solid var(--border);
            transition: max-height 0.3s ease;
            max-height: 0;
            overflow: hidden;
        }

            .editor-panel.open {
                max-height: 260px;
            }

        .editor-inner {
            padding: 16px 28px;
        }

        #editor-texto {
            width: 100%;
            height: 130px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.78rem;
            padding: 12px;
            resize: vertical;
            outline: none;
            margin-bottom: 10px;
        }

            #editor-texto:focus {
                border-color: var(--accent);
            }

        .editor-actions {
            display: flex;
            gap: 8px;
        }

        /* ─── SIDEBAR (RIGHT) ─── */
        .sidebar {
            width: var(--sidebar-w);
            flex-shrink: 0;
            background: var(--surface);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: var(--border) transparent;
        }

            .sidebar::-webkit-scrollbar {
                width: 3px;
            }

            .sidebar::-webkit-scrollbar-thumb {
                background: var(--border);
            }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

            .sidebar-section:last-child {
                border-bottom: none;
            }

        .section-label {
            font-size: 0.6rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .section-label::after {
                content: '';
                flex: 1;
                height: 1px;
                background: var(--border);
            }

        /* File upload */
        .file-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
            padding: 10px;
            background: var(--accent);
            color: var(--bg);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.72rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            transition: opacity 0.2s;
        }

            .file-label:hover {
                opacity: 0.85;
            }

        input[type="file"] {
            display: none;
        }

        #file-name {
            display: block;
            font-size: 0.62rem;
            color: var(--text-dim);
            margin-top: 6px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Chapter select */
        #chapters {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 4px;
            height: 110px;
            outline: none;
        }

            #chapters:focus {
                border-color: var(--accent);
            }

            #chapters option {
                padding: 4px 6px;
            }

                #chapters option:checked {
                    background: var(--accent);
                    color: var(--bg);
                }

        /* Toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }

            .toggle-row span {
                font-size: 0.68rem;
                color: var(--text-muted);
            }

        .toggle {
            position: relative;
            width: 36px;
            height: 19px;
        }

            .toggle input {
                opacity: 0;
                width: 0;
                height: 0;
            }

        .toggle-slider {
            position: absolute;
            inset: 0;
            background: var(--border);
            border-radius: 19px;
            cursor: pointer;
            transition: background 0.2s;
        }

            .toggle-slider::before {
                content: '';
                position: absolute;
                width: 13px;
                height: 13px;
                left: 3px;
                top: 3px;
                background: var(--text-muted);
                border-radius: 50%;
                transition: transform 0.2s, background 0.2s;
            }

        .toggle input:checked + .toggle-slider {
            background: var(--accent2);
        }

            .toggle input:checked + .toggle-slider::before {
                transform: translateX(17px);
                background: white;
            }

        #translation-status {
            font-size: 0.6rem;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        /* Replace */
        .replace-pair {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* TTS Buttons */
        .tts-btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        /* Sliders */
        .slider-row {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.62rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

            .slider-label span {
                color: var(--accent);
            }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--accent);
                cursor: pointer;
                transition: transform 0.15s;
            }

                input[type="range"]::-webkit-slider-thumb:hover {
                    transform: scale(1.3);
                }

        select#voice-select {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            padding: 6px 8px;
            outline: none;
            margin-bottom: 12px;
        }

            select#voice-select:focus {
                border-color: var(--accent);
            }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.68rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            transition: opacity 0.2s, transform 0.1s;
        }

            .btn:hover {
                opacity: 0.85;
            }

            .btn:active {
                transform: scale(0.97);
            }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn-secondary {
            background: var(--surface2);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .btn-success {
            background: var(--accent2);
            color: var(--bg);
        }

        .btn-tts {
            background: var(--surface2);
            color: var(--text);
            border: 1px solid var(--border);
            font-size: 0.65rem;
            padding: 7px 6px;
        }

            .btn-tts:disabled {
                opacity: 0.35;
                cursor: not-allowed;
                transform: none;
            }

            .btn-tts.active {
                background: var(--accent);
                color: var(--bg);
                border-color: var(--accent);
            }

        .btn-full {
            width: 100%;
        }

        /* Inputs */
        input[type="text"] {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.7rem;
            padding: 7px 10px;
            outline: none;
        }

            input[type="text"]:focus {
                border-color: var(--accent);
            }

            input[type="text"]::placeholder {
                color: var(--text-dim);
            }

        /* Notification */
        #notification {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(80px);
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'DM Mono', monospace;
            font-size: 0.72rem;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

            #notification.show {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }

        /* Editor toggle button */
        .editor-toggle-btn {
            position: fixed;
            bottom: 24px;
            right: calc(var(--sidebar-w) + 24px);
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s;
        }

            .editor-toggle-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

        /* Scrollbar for reading area */
        .reading-area {
            scroll-behavior: smooth;
        }

        /* Highlight spoken word */
        .spoken {
            background: rgba(200, 169, 110, 0.18);
            border-radius: 2px;
        }

        /* TTS sentence highlight */
        .tts-sentence {
            border-radius: 3px;
            transition: background 0.25s ease, box-shadow 0.25s ease;
        }

            .tts-sentence.tts-active {
                background: rgba(200, 169, 110, 0.22);
                box-shadow: 0 0 0 2px rgba(200, 169, 110, 0.15);
                border-radius: 3px;
            }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .playing-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent2);
            animation: pulse 1s infinite;
            margin-right: 6px;
        }

        /* Responsive */
        @media (max-width: 700px) {
            :root {
                --sidebar-w: 240px;
            }

            .reading-area {
                padding: 32px 24px;
            }
        }

        /* ─── AMBIENT MUSIC PLAYER ─── */
        #ambient-player {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 260px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

            #ambient-player.collapsed .ambient-body {
                display: none;
            }

        .ambient-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            cursor: pointer;
            background: var(--surface2);
            border-bottom: 1px solid var(--border);
            user-select: none;
        }

        .ambient-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.68rem;
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .ambient-eq {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 12px;
        }

            .ambient-eq span {
                width: 3px;
                background: var(--accent2);
                border-radius: 1px;
                animation: none;
                height: 3px;
                transition: height 0.2s;
            }

            .ambient-eq.playing span:nth-child(1) {
                animation: eq1 0.8s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(2) {
                animation: eq2 0.6s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(3) {
                animation: eq3 1s ease-in-out infinite;
            }

            .ambient-eq.playing span:nth-child(4) {
                animation: eq2 0.7s ease-in-out infinite;
            }

        @keyframes eq1 {
            0%,100% {
                height: 3px
            }

            50% {
                height: 10px
            }
        }

        @keyframes eq2 {
            0%,100% {
                height: 6px
            }

            50% {
                height: 12px
            }
        }

        @keyframes eq3 {
            0%,100% {
                height: 9px
            }

            50% {
                height: 4px
            }
        }

        .ambient-collapse-btn {
            font-size: 0.6rem;
            color: var(--text-dim);
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
        }

        .ambient-body {
            padding: 14px;
        }

        .ambient-genres {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 12px;
        }

        .genre-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 8px 4px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            font-size: 0.58rem;
            color: var(--text-muted);
            transition: all 0.2s;
        }

            .genre-btn:hover {
                border-color: var(--accent);
                color: var(--text);
            }

            .genre-btn.active {
                border-color: var(--accent2);
                background: rgba(126, 184, 154, 0.1);
                color: var(--accent2);
            }

            .genre-btn .genre-icon {
                font-size: 1rem;
            }

        .ambient-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .ambient-play-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--accent2);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: var(--bg);
            flex-shrink: 0;
            transition: transform 0.15s, opacity 0.15s;
        }

            .ambient-play-btn:hover {
                transform: scale(1.1);
            }

        .ambient-track-info {
            flex: 1;
            overflow: hidden;
        }

        .ambient-track-name {
            font-size: 0.6rem;
            color: var(--text);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ambient-track-genre {
            font-size: 0.55rem;
            color: var(--text-dim);
        }

        .ambient-vol-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ambient-vol-icon {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .ambient-vol-row input[type=range] {
            flex: 1;
            height: 3px;
        }

        .ambient-vol-val {
            font-size: 0.6rem;
            color: var(--text-dim);
            width: 26px;
            text-align: right;
        }


        /* ─── GRABACIÓN & VIDEO ─── */
        .rec-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--surface2);
            color: var(--text-muted);
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }

            .rec-btn:hover {
                border-color: var(--accent);
                color: var(--accent);
            }

            .rec-btn.recording {
                border-color: #e05555;
                color: #e05555;
                animation: recpulse 1s infinite;
            }

        @keyframes recpulse {
            0%,100% {
                opacity: 1
            }

            50% {
                opacity: 0.5
            }
        }

        /* Spotify-style karaoke overlay */
        #karaoke-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 9, 8, 0.92);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
        }

            #karaoke-overlay.active {
                display: flex;
            }

        #karaoke-canvas {
            border-radius: 12px;
            background: transparent;
        }

        #karaoke-close {
            position: absolute;
            top: 20px;
            right: 24px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.4rem;
            cursor: pointer;
            transition: color 0.2s;
        }

            #karaoke-close:hover {
                color: var(--text);
            }

        .karaoke-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-top: 16px;
            width: min(900px, 95vw);
            position: relative;
        }

        .karaoke-track {
            font-family: 'DM Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .karaoke-controls {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

            .karaoke-controls button {
                background: var(--surface2);
                border: 1px solid var(--border);
                border-radius: 6px;
                color: var(--text-muted);
                font-size: 0.65rem;
                font-family: 'DM Mono', monospace;
                padding: 6px 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

                .karaoke-controls button:hover {
                    border-color: var(--accent);
                    color: var(--accent);
                }

                .karaoke-controls button.ai-active {
                    border-color: var(--accent2);
                    color: var(--accent2);
                    background: rgba(126,184,154,0.1);
                }

        /* Barra de controles de reproducción centrada */
        .karaoke-playbar {
            display: flex;
            align-items: center;
            gap: 12px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .kbtn {
            border: none;
            cursor: pointer;
            font-family: 'DM Mono', monospace;
            transition: all 0.18s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kbtn-nav {
            background: rgba(255,255,255,0.06);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.65rem;
            padding: 8px 14px;
            letter-spacing: 0.02em;
        }

            .kbtn-nav:hover {
                background: rgba(200,169,110,0.12);
                border-color: var(--accent);
                color: var(--accent);
            }

        .kbtn-music {
            background: rgba(126,184,154,0.08);
            border: 1px solid rgba(126,184,154,0.2);
            border-radius: 6px;
            color: var(--accent2);
            font-size: 0.55rem;
            padding: 4px 8px;
        }

            .kbtn-music:hover {
                background: rgba(126,184,154,0.18);
                border-color: var(--accent2);
            }

        .kbtn-play {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent);
            color: var(--bg);
            font-size: 1.1rem;
            box-shadow: 0 0 20px rgba(200,169,110,0.3);
        }

            .kbtn-play:hover {
                transform: scale(1.08);
                box-shadow: 0 0 28px rgba(200,169,110,0.5);
            }

            .kbtn-play.paused {
                background: var(--accent2);
                box-shadow: 0 0 20px rgba(126,184,154,0.3);
            }
    </style>
</head>
<body>

    <div id="notification" class="notification"></div>

    <!-- ─── MAIN PANEL ─── -->
    <div class="main-panel">
        <div class="top-bar">
            <h1>📚 Lector EPUB</h1>
            <button class="rec-btn" id="btn-rec-audio" onclick="toggleGrabacion()" style="margin-left:16px;margin-bottom:0;">
                <span id="rec-dot">⏺</span> Grabar audio
            </button>
            <button class="rec-btn" onclick="abrirKaraoke()" style="margin-bottom:0;">
                🎬 Modo Video
            </button>
            <span class="subtitle" id="current-chapter-title">Ningún capítulo seleccionado</span>
        </div>

        <div class="stats-bar">
            <div class="stat">📝 Palabras: <strong id="contador-palabras">0</strong></div>
            <div class="stat">🔤 Chars: <strong id="contador-caracteres">0</strong></div>
            <div class="stat">📄 Párrafos: <strong id="contador-parrafos">0</strong></div>
            <div class="stat" id="tts-stat" style="margin-left:auto;">⏹️ <strong id="tts-status">Detenido</strong></div>
        </div>

        <div class="reading-area">
            <div id="texto-contenido" style="font-family:'Lora',serif;font-size:1.1rem;line-height:1.85;color:var(--text);max-width:680px;margin:0 auto;">
                <p style="color:var(--text-dim);font-style:italic;">Carga un archivo EPUB desde el panel lateral para comenzar a leer...</p>
            </div>
        </div>

        <div class="editor-panel" id="editor-panel">
            <div class="editor-inner">
                <div class="section-label">Editor de Texto</div>
                <textarea id="editor-texto" placeholder="Pega aquí tu texto o edita el contenido actual..."></textarea>
                <div class="editor-actions">
                    <button class="btn btn-success" onclick="aplicarTexto()">Aplicar</button>
                    <button class="btn btn-secondary" onclick="limpiarEditor()">Limpiar</button>
                    <button class="btn btn-secondary" onclick="copiarTexto()">Copiar</button>
                    <button class="btn btn-secondary" onclick="traducirTextoActual()" style="margin-left:auto;">Traducir</button>
                </div>
            </div>
        </div>

        <div class="progress-wrap">
            <div class="tts-status-bar">
                <span id="tts-status-label">⏹ Sin reproducción</span>
                <span class="tts-percent-badge" id="tts-percent" style="display:none;">0%</span>
            </div>
            <div class="progress-track" onclick="seekTTS(event)">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div style="height:8px;"></div>
        </div>
    </div>

    <button class="editor-toggle-btn" onclick="toggleEditor()" id="editor-toggle-btn">✏️ Editor</button>

    <!-- ─── SIDEBAR ─── -->
    <div class="sidebar">

        <!-- Cargar EPUB -->
        <div class="sidebar-section">
            <div class="section-label">Archivo</div>
            <label for="epub-file" class="file-label">📂 Seleccionar EPUB</label>
            <input type="file" id="epub-file" accept=".epub">
            <span id="file-name">Ningún archivo seleccionado</span>
        </div>

        <!-- Capítulos -->
        <div class="sidebar-section">
            <div class="section-label">Capítulos</div>
            <div id="chapter-selector">
                <input type="text" id="chapter-search" placeholder="🔍 Buscar capítulo..."
                       oninput="filtrarCapitulos(this.value)"
                       style="width:100%;margin-bottom:6px;font-size:0.68rem;padding:6px 10px;
                              background:var(--bg);border:1px solid var(--border);border-radius:4px;
                              color:var(--text);font-family:'DM Mono',monospace;outline:none;">
                <select id="chapters" size="6">
                    <option disabled>— sin capítulos —</option>
                </select>
            </div>
        </div>

        <!-- Traducción -->
        <div class="sidebar-section">
            <div class="section-label">Traducción</div>
            <div class="toggle-row">
                <span>Auto EN → ES</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-translate" onchange="toggleAutoTranslate()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div id="translation-status">Traducción desactivada</div>
            <div class="toggle-row" id="auto-play-row" style="margin-top:8px; display:none;">
                <span style="font-size:0.85rem; color:var(--text-dim);">▶ Reproducir al terminar</span>
                <label class="toggle">
                    <input type="checkbox" id="auto-play-after-translate">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <!-- Reemplazar palabras -->
        <div class="sidebar-section">
            <div class="section-label collapsible-label" onclick="toggleReemplazar()" style="cursor:pointer;user-select:none;">
                Reemplazar <span id="reemplazar-arrow" style="margin-left:auto;font-size:0.7rem;color:var(--text-dim);">▶</span>
            </div>
            <div class="replace-pair" id="reemplazar-body" style="display:none;">
                <input type="text" id="palabra-buscar" placeholder="Buscar...">
                <input type="text" id="palabra-reemplazar" placeholder="Reemplazar con...">
                <button class="btn btn-primary" onclick="reemplazarPalabra()">Reemplazar</button>
            </div>
        </div>

        <!-- TTS Controles -->
        <div class="sidebar-section">
            <div class="section-label">Reproducción</div>
            <div class="tts-btn-grid">
                <button class="btn-tts btn" onclick="iniciarTTS()" id="btn-play">▶ Play</button>
                <button class="btn-tts btn" onclick="pausarTTS()" id="btn-pause" disabled>⏸ Pausa</button>
                <button class="btn-tts btn" onclick="reanudarTTS()" id="btn-resume" disabled>▶ Cont.</button>
                <button class="btn-tts btn" onclick="detenerTTS()" id="btn-stop" disabled>⏹ Stop</button>
            </div>

            <div class="section-label" style="margin-top:4px;">Voz</div>
            <select id="voice-select"></select>

            <div class="slider-row">
                <div class="slider-label">Velocidad <span id="rate-value">1.0</span>x</div>
                <input type="range" id="rate-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Tono <span id="pitch-value">1.0</span></div>
                <input type="range" id="pitch-control" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>

            <div class="slider-row">
                <div class="slider-label">Volumen <span id="volume-value">100</span>%</div>
                <input type="range" id="volume-control" min="0" max="100" step="5" value="100">
            </div>
        </div>

    </div>

    <script src="js/main.js"></script>
    <script>
        // Reemplazar toggle
        function toggleReemplazar() {
            const body = document.getElementById('reemplazar-body');
            const arrow = document.getElementById('reemplazar-arrow');
            const open = body.style.display === 'none';
            body.style.display = open ? 'flex' : 'none';
            arrow.textContent = open ? '▼' : '▶';
        }

        // Editor toggle (UI only)
        function toggleEditor() {
            const panel = document.getElementById('editor-panel');
            const btn = document.getElementById('editor-toggle-btn');
            panel.classList.toggle('open');
            btn.textContent = panel.classList.contains('open') ? '✕ Cerrar Editor' : '✏️ Editor';
        }

        // Sync chapter title in top bar when chapter changes
        document.getElementById('chapters').addEventListener('change', function (e) {
            const opt = e.target.options[e.target.selectedIndex];
            if (opt) document.getElementById('current-chapter-title').textContent = opt.textContent;
        });

        // Patch actualizarEstadoTTS to also update the extra status elements in the new layout
        const _origActualizarEstadoTTS = actualizarEstadoTTS;
        // Wait for main.js to load first
        window.addEventListener('DOMContentLoaded', () => { });

        // Patch iniciarTTS: reconstruir slot map de IA y detectar universo al iniciar
        const _origIniciarTTS = iniciarTTS;
        window.iniciarTTS = function () {
            _origIniciarTTS.apply(this, arguments);
            // Tras iniciar, sentences ya fue reconstruido en main.js
            setTimeout(() => {
                if (typeof buildAiSlotMap === 'function') buildAiSlotMap();
                if (typeof detectarUniverso === 'function') detectarUniverso();
            }, 80);
        };
        iniciarTTS = window.iniciarTTS;
    </script>

    <!-- ─── AMBIENT MUSIC PLAYER ─── -->
    <div id="ambient-player" class="collapsed">
        <div class="ambient-header" onclick="toggleAmbientPanel()">
            <div class="ambient-header-left">
                <div class="ambient-eq" id="ambient-eq">
                    <span></span><span></span><span></span><span></span>
                </div>
                Música Ambiental
            </div>
            <button class="ambient-collapse-btn" id="ambient-arrow">▲</button>
        </div>
        <div class="ambient-body">

            <!-- API Key panel -->
            <div id="freesound-key-panel" style="margin-bottom:10px;">
                <div style="font-size:0.58rem;color:var(--text-dim);margin-bottom:4px;">
                    🎵 Freesound API Key <span style="color:var(--accent2)" id="key-status"></span>
                </div>
                <div style="display:flex;gap:6px;">
                    <input type="password" id="freesound-api-key" placeholder="Pegar API key..."
                           style="flex:1;background:var(--bg);border:1px solid var(--border);border-radius:4px;
                    color:var(--text);font-family:'DM Mono',monospace;font-size:0.62rem;padding:5px 8px;outline:none;">
                    <button onclick="guardarApiKey()"
                            style="background:var(--accent2);border:none;border-radius:4px;color:var(--bg);
                    font-family:'DM Mono',monospace;font-size:0.6rem;padding:5px 8px;cursor:pointer;">
                        OK
                    </button>
                </div>
                <div style="font-size:0.55rem;color:var(--text-dim);margin-top:3px;">
                    Sin key → generador procedural local
                </div>
            </div>

            <div class="ambient-genres">
                <button class="genre-btn" onclick="selectGenre('mystery')" id="genre-mystery">
                    <span class="genre-icon">🔍</span>Misterio
                </button>
                <button class="genre-btn" onclick="selectGenre('suspense')" id="genre-suspense">
                    <span class="genre-icon">😰</span>Suspenso
                </button>
                <button class="genre-btn" onclick="selectGenre('drama')" id="genre-drama">
                    <span class="genre-icon">🎭</span>Drama
                </button>
                <button class="genre-btn" onclick="selectGenre('action')" id="genre-action">
                    <span class="genre-icon">⚡</span>Acción
                </button>
                <button class="genre-btn" onclick="selectGenre('fantasy')" id="genre-fantasy">
                    <span class="genre-icon">🧙</span>Fantasía
                </button>
                <button class="genre-btn" onclick="selectGenre('romance')" id="genre-romance">
                    <span class="genre-icon">💫</span>Romance
                </button>
                <button class="genre-btn" onclick="selectGenre('lofi')" id="genre-lofi">
                    <span class="genre-icon">📚</span>Lo-Fi
                </button>
                <button class="genre-btn" onclick="selectGenre('nature')" id="genre-nature">
                    <span class="genre-icon">🌿</span>Naturaleza
                </button>
            </div>

            <button class="btn btn-secondary" onclick="detectarGeneroConIA()" id="btn-detect-genre"
                    style="width:100%;margin-bottom:10px;font-size:0.62rem;gap:6px;">
                ✨ Detectar género del texto
            </button>

            <div class="ambient-controls">
                <button class="ambient-play-btn" id="ambient-play-btn" onclick="toggleAmbientPlay()">▶</button>
                <div class="ambient-track-info">
                    <div class="ambient-track-name" id="ambient-track-name">Selecciona un género</div>
                    <div class="ambient-track-genre" id="ambient-track-genre">─</div>
                </div>
                <button onclick="siguienteTrack()" title="Siguiente track" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:0.9rem;padding:4px;transition:color 0.2s;" onmouseover="this.style.color='var(--accent)'" onmouseout="this.style.color='var(--text-dim)'">⏭</button>
            </div>

            <div class="ambient-vol-row">
                <span class="ambient-vol-icon">🎵</span>
                <input type="range" id="ambient-volume" min="0" max="100" value="20" oninput="setAmbientVolume(this.value)">
                <span class="ambient-vol-val" id="ambient-vol-val">20%</span>
            </div>
        </div>
    </div>

    <script>
        // ─── AMBIENT MUSIC ENGINE — Web Audio API Procedural Generation ───
        // Genera música ambiental 100% en el navegador sin URLs externas

        let ambientCtx = null;
        let ambientNodes = [];
        let ambientPlaying = false;
        let ambientGenre = null;
        let ambientGainNode = null;
        let ambientVolume = 0.20;

        function getAudioCtx() {
            if (!ambientCtx) ambientCtx = new (window.AudioContext || window.webkitAudioContext)();
            return ambientCtx;
        }

        // ── Generadores por género ──
        const GENRE_GENERATORS = {

            mystery: (ctx, gain) => {
                // Notas oscuras lentas + reverb simulado
                const notes = [130.81, 155.56, 174.61, 196.00, 220.00];
                const nodes = [];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain);
                    osc.start();
                    // Pulsa cada nota con tiempo diferente
                    const interval = setInterval(() => {
                        const now = ctx.currentTime;
                        g.gain.setValueAtTime(0, now);
                        g.gain.linearRampToValueAtTime(0.08, now + 0.3);
                        g.gain.linearRampToValueAtTime(0, now + 2.5);
                    }, 3000 + i * 700);
                    nodes.push({ osc, interval });
                });
                // Rumble bajo
                const rumble = ctx.createOscillator();
                const rg = ctx.createGain();
                rumble.type = 'sine'; rumble.frequency.value = 55;
                rg.gain.value = 0.04;
                rumble.connect(rg); rg.connect(gain); rumble.start();
                nodes.push({ osc: rumble });
                return nodes;
            },

            suspense: (ctx, gain) => {
                const nodes = [];
                // Tremolo tense string simulation
                [220, 233, 246].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();
                    const g = ctx.createGain();
                    osc.type = 'sawtooth'; osc.frequency.value = freq;
                    lfo.type = 'sine'; lfo.frequency.value = 6 + i;
                    lfoGain.gain.value = 0.03;
                    g.gain.value = 0.04;
                    lfo.connect(lfoGain); lfoGain.connect(g.gain);
                    osc.connect(g); g.connect(gain);
                    osc.start(); lfo.start();
                    nodes.push({ osc }, { osc: lfo });
                });
                // Heartbeat-like bass
                const bass = ctx.createOscillator();
                const bg = ctx.createGain();
                bass.type = 'sine'; bass.frequency.value = 80;
                bg.gain.value = 0;
                bass.connect(bg); bg.connect(gain); bass.start();
                const beat = setInterval(() => {
                    const now = ctx.currentTime;
                    bg.gain.setValueAtTime(0, now);
                    bg.gain.linearRampToValueAtTime(0.12, now + 0.05);
                    bg.gain.linearRampToValueAtTime(0, now + 0.3);
                    bg.gain.setValueAtTime(0, now + 0.5);
                    bg.gain.linearRampToValueAtTime(0.08, now + 0.55);
                    bg.gain.linearRampToValueAtTime(0, now + 0.8);
                }, 1800);
                nodes.push({ osc: bass, interval: beat });
                return nodes;
            },

            drama: (ctx, gain) => {
                const nodes = [];
                // Slow cinematic pads
                [[261.63, 0.06], [329.63, 0.04], [392.00, 0.03], [493.88, 0.025]].forEach(([freq, vol]) => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    g.gain.value = vol;
                    osc.connect(g); g.connect(gain); osc.start();
                    nodes.push({ osc });
                });
                // Slow filter sweep
                const noise = ctx.createOscillator();
                const ng = ctx.createGain();
                noise.type = 'triangle'; noise.frequency.value = 110;
                ng.gain.value = 0.05;
                noise.connect(ng); ng.connect(gain); noise.start();
                nodes.push({ osc: noise });
                return nodes;
            },

            action: (ctx, gain) => {
                const nodes = [];
                // Aggressive rhythm + brass-like hits
                const bassOsc = ctx.createOscillator();
                const bg = ctx.createGain();
                bassOsc.type = 'square'; bassOsc.frequency.value = 110;
                bg.gain.value = 0;
                bassOsc.connect(bg); bg.connect(gain); bassOsc.start();
                let beat = 0;
                const rhythm = [1, 0, 1, 0, 1, 1, 0, 1];
                const interval = setInterval(() => {
                    if (rhythm[beat % rhythm.length]) {
                        const now = ctx.currentTime;
                        bg.gain.setValueAtTime(0.1, now);
                        bg.gain.linearRampToValueAtTime(0, now + 0.15);
                    }
                    beat++;
                }, 200);
                nodes.push({ osc: bassOsc, interval });
                // High tension strings
                [440, 554, 659].forEach(freq => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sawtooth'; o.frequency.value = freq;
                    g.gain.value = 0.025;
                    o.connect(g); g.connect(gain); o.start();
                    nodes.push({ osc: o });
                });
                return nodes;
            },

            fantasy: (ctx, gain) => {
                const nodes = [];
                // Magical harp-like arpeggios
                const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
                let noteIdx = 0;
                const playNote = () => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = scale[noteIdx % scale.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(0.07, now + 0.05);
                    g.gain.linearRampToValueAtTime(0, now + 1.2);
                    setTimeout(() => osc.stop(), 1500);
                    noteIdx++;
                };
                const interval = setInterval(playNote, 400);
                nodes.push({ interval });
                // Pad underneath
                const pad = ctx.createOscillator();
                const pg = ctx.createGain();
                pad.type = 'sine'; pad.frequency.value = 130.81;
                pg.gain.value = 0.03;
                pad.connect(pg); pg.connect(gain); pad.start();
                nodes.push({ osc: pad });
                return nodes;
            },

            romance: (ctx, gain) => {
                const nodes = [];
                // Warm, slow piano-like notes
                const melody = [261.63, 329.63, 392.00, 329.63, 261.63, 293.66, 349.23, 293.66];
                let idx = 0;
                const interval = setInterval(() => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = melody[idx % melody.length];
                    g.gain.value = 0;
                    osc.connect(g); g.connect(gain); osc.start();
                    const now = ctx.currentTime;
                    g.gain.linearRampToValueAtTime(0.08, now + 0.1);
                    g.gain.linearRampToValueAtTime(0, now + 1.8);
                    setTimeout(() => osc.stop(), 2000);
                    // Armonía
                    const osc2 = ctx.createOscillator();
                    const g2 = ctx.createGain();
                    osc2.type = 'sine'; osc2.frequency.value = melody[idx % melody.length] * 1.5;
                    g2.gain.value = 0;
                    osc2.connect(g2); g2.connect(gain); osc2.start();
                    g2.gain.linearRampToValueAtTime(0.04, now + 0.15);
                    g2.gain.linearRampToValueAtTime(0, now + 1.5);
                    setTimeout(() => osc2.stop(), 1800);
                    idx++;
                }, 800);
                nodes.push({ interval });
                return nodes;
            },

            lofi: (ctx, gain) => {
                const nodes = [];
                // Lo-fi: muffled chords + vinyl crackle simulation
                const chords = [[261.63, 329.63, 392.00], [246.94, 311.13, 369.99], [220.00, 277.18, 329.63]];
                let ci = 0;
                const interval = setInterval(() => {
                    chords[ci % chords.length].forEach(freq => {
                        const osc = ctx.createOscillator();
                        const g = ctx.createGain();
                        const filter = ctx.createBiquadFilter();
                        filter.type = 'lowpass'; filter.frequency.value = 800; // Muffled
                        osc.type = 'triangle'; osc.frequency.value = freq;
                        g.gain.value = 0;
                        osc.connect(filter); filter.connect(g); g.connect(gain); osc.start();
                        const now = ctx.currentTime;
                        g.gain.linearRampToValueAtTime(0.05, now + 0.1);
                        g.gain.linearRampToValueAtTime(0.04, now + 1.5);
                        g.gain.linearRampToValueAtTime(0, now + 2);
                        setTimeout(() => osc.stop(), 2200);
                    });
                    ci++;
                }, 2000);
                nodes.push({ interval });
                // Rain-like noise
                const bufferSize = ctx.sampleRate * 2;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.015;
                const src = ctx.createBufferSource();
                src.buffer = buffer; src.loop = true;
                const nf = ctx.createBiquadFilter();
                nf.type = 'bandpass'; nf.frequency.value = 2000;
                src.connect(nf); nf.connect(gain); src.start();
                nodes.push({ src });
                return nodes;
            },

            nature: (ctx, gain) => {
                const nodes = [];
                // Wind + birds simulation
                // Wind: filtered noise
                const bufferSize = ctx.sampleRate * 3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const wind = ctx.createBufferSource();
                wind.buffer = buffer; wind.loop = true;
                const wf = ctx.createBiquadFilter();
                wf.type = 'bandpass'; wf.frequency.value = 400; wf.Q.value = 0.5;
                const wg = ctx.createGain(); wg.gain.value = 0.08;
                wind.connect(wf); wf.connect(wg); wg.connect(gain); wind.start();
                nodes.push({ src: wind });
                // Bird chirps
                const chirp = () => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(2000 + Math.random() * 1000, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(2800 + Math.random() * 800, ctx.currentTime + 0.1);
                    g.gain.setValueAtTime(0, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0.04, ctx.currentTime + 0.02);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.15);
                    o.connect(g); g.connect(gain); o.start();
                    setTimeout(() => o.stop(), 200);
                };
                const interval = setInterval(() => {
                    chirp();
                    if (Math.random() > 0.5) setTimeout(chirp, 150);
                }, 1500 + Math.random() * 3000);
                nodes.push({ interval });
                return nodes;
            }
        };

        const GENRE_LABELS = {
            mystery: 'Misterio oscuro', suspense: 'Suspenso tenso', drama: 'Drama cinematográfico',
            action: 'Acción intensa', fantasy: 'Fantasía mágica', romance: 'Romance suave',
            lofi: 'Lo-Fi + lluvia', nature: 'Naturaleza y viento'
        };

        // ── Freesound API key management ──
        let freesoundApiKey = localStorage.getItem('freesound_api_key') || 'JCXLtKvEpLo3DJTYy3pRIXEcEWMTLRWK3UEcJ5iD';

        function guardarApiKey() {
            const key = document.getElementById('freesound-api-key').value.trim();
            if (key) {
                freesoundApiKey = key;
                localStorage.setItem('freesound_api_key', key);
                document.getElementById('key-status').textContent = '✓ guardada';
                document.getElementById('freesound-api-key').value = '';
                setTimeout(() => document.getElementById('key-status').textContent = '', 2000);
            }
        }

        // Show key status on load
        window.addEventListener('DOMContentLoaded', () => {
            if (freesoundApiKey) {
                document.getElementById('key-status').textContent = '✓ configurada';
            }
        });

        // ── Freesound multi-query system con subtonos ──
        // Múltiples queries por género para mejor variedad y precisión
        const FREESOUND_QUERIES = {
            mystery: ['dark mystery ambient', 'noir detective atmosphere', 'eerie suspense drone', 'dark cinematic tension'],
            suspense: ['suspense thriller tension', 'psychological horror ambient', 'heartbeat tense atmosphere', 'chase scene cinematic'],
            drama: ['emotional piano ambient', 'cinematic sad orchestral', 'melancholy strings atmosphere', 'dramatic film score'],
            action: ['epic battle cinematic', 'intense action orchestral', 'war drums epic', 'adrenaline cinematic score'],
            fantasy: ['magical fantasy ambient', 'ethereal fantasy soundscape', 'enchanted forest music', 'epic fantasy orchestral'],
            romance: ['romantic piano soft', 'love theme gentle strings', 'tender romantic ambient', 'soft acoustic romance'],
            lofi: ['lofi hip hop chill', 'study music ambient beats', 'chill lofi background', 'jazzy lofi instrumental'],
            nature: ['forest nature ambient', 'rain birds peaceful', 'ocean waves relaxing', 'meditation nature sounds'],
            horror: ['horror dark ambient', 'scary atmosphere drone', 'creepy tension music', 'dark horror soundscape'],
            adventure: ['adventure epic journey', 'exploration cinematic', 'heroic adventure theme', 'discovery orchestral'],
        };

        // Análisis avanzado: detecta tono, intensidad y subtono del texto
        function analizarTextoDetallado(texto) {
            const lower = texto.toLowerCase().slice(0, 3000);
            const words = lower.split(/\s+/);
            const totalWords = words.length;

            // Función helper: cuenta ocurrencias por 1000 palabras (normalizado)
            const freq = (lista) => lista.reduce((s, w) => s + (lower.split(w).length - 1), 0) / totalWords * 1000;

            const scores = {
                mystery: freq(['misterio', 'enigma', 'sombra', 'oscuro', 'secreto', 'oculto', 'extraño', 'cadáver', 'crimen', 'investigar', 'pista', 'detecti', 'desapareció', 'cuerpo', 'asesino', 'veneno', 'conspiración']),
                suspense: freq(['tensión', 'peligro', 'trampa', 'amenaza', 'miedo', 'terror', 'acecho', 'perseguir', 'escapar', 'corazón', 'aceleró', 'tiempo', 'demasiado tarde', 'pistola', 'arma', 'disparó', 'huir', 'atrapado']),
                drama: freq(['llanto', 'lágrimas', 'dolor', 'sufrir', 'perder', 'traición', 'soledad', 'sacrificio', 'promesa', 'herida', 'culpa', 'perdón', 'familia', 'ruptura', 'pérdida', 'luto', 'desesperanza', 'fracasó']),
                action: freq(['combate', 'batalla', 'golpe', 'atacar', 'disparar', 'explotar', 'luchar', 'espada', 'victoria', 'enemigo', 'guerrero', 'sangre', 'herido', 'correr', 'saltar', 'velocidad', 'patada', 'puño', 'chocó']),
                fantasy: freq(['magia', 'hechizo', 'dragón', 'reino', 'elfo', 'mago', 'destino', 'profecía', 'criatura', 'portal', 'artefacto', 'encantamiento', 'espíritu', 'runa', 'hada', 'brujo', 'varita', 'conjuro', 'poción']),
                romance: freq(['amor', 'beso', 'mirada', 'suave', 'sentir', 'latir', 'ternura', 'abrazo', 'sonrisa', 'deseo', 'piel', 'suspirar', 'juntos', 'enamorar', 'cariño', 'corazón', 'acarició', 'besó', 'amaba']),
                lofi: freq(['estudiar', 'aprender', 'libro', 'notas', 'lección', 'conocimiento', 'teoría', 'análisis', 'investigación', 'datos', 'concepto', 'comprender', 'fórmula', 'clase', 'universidad', 'examen', 'trabajo']),
                nature: freq(['bosque', 'árbol', 'río', 'montaña', 'viento', 'lluvia', 'animal', 'campo', 'flor', 'tierra', 'cielo', 'amanecer', 'naturaleza', 'verde', 'agua', 'pájaro', 'mar', 'playa', 'selva', 'tormenta']),
                horror: freq(['horror', 'aterrador', 'monstruo', 'demonio', 'sangre', 'muerte', 'oscuridad', 'grito', 'pesadilla', 'fantasma', 'sombra', 'aparición', 'terror', 'carne', 'víscera', 'mutilado', 'cadáver', 'pudrir']),
                adventure: ['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'montaña', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio'].reduce ? freq(['aventura', 'explorar', 'viaje', 'camino', 'destino', 'mapa', 'tesoro', 'expedición', 'descubrir', 'horizonte', 'navegar', 'peligro', 'misión', 'héroe', 'guardia', 'fortaleza', 'territorio']) : 0,
            };

            // Detectar intensidad general del texto
            const intensityWords = freq(['!', 'muy', 'enorme', 'increíble', 'absolutamente', 'completamente', 'jamás', 'nunca', 'siempre', 'desesperado', 'urgente']);
            const intensity = Math.min(intensityWords / 5, 1); // 0-1

            // Detectar ritmo (oraciones cortas = acción/suspenso, largas = drama/romance)
            const avgSentenceLen = lower.split(/[.!?]+/).filter(s => s.trim()).reduce((s, o) => s + o.split(' ').length, 0) / Math.max(lower.split(/[.!?]+/).length, 1);
            const isPaced = avgSentenceLen < 12; // oraciones cortas = más urgente

            // Ganador
            const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            const winner = sorted[0][0];
            const runnerUp = sorted[1][0];
            const confidence = sorted[0][1] > 0 ? Math.min(sorted[0][1] / (sorted[1][1] + 0.1), 3) : 0;

            return { genre: winner, secondary: runnerUp, confidence, intensity, isPaced, scores };
        }

        let freesoundTrackUrl = null;
        let freesoundAudio = null;
        let _lastFreesoundResults = {};  // cache por género

        async function buscarEnFreesound(genre, subtono) {
            if (!freesoundApiKey) return null;

            // Elegir query: usar subtono si hay alta confianza, sino query principal
            const queries = FREESOUND_QUERIES[genre] || FREESOUND_QUERIES['mystery'];
            const queryStr = queries[Math.floor(Math.random() * queries.length)];

            // Cache: si ya tenemos resultados de este género, rotar entre ellos
            if (_lastFreesoundResults[genre] && _lastFreesoundResults[genre].length > 1) {
                const pool = _lastFreesoundResults[genre];
                const pick = pool[Math.floor(Math.random() * pool.length)];
                return pick;
            }

            const query = encodeURIComponent(queryStr);
            const url = `https://freesound.org/apiv2/search/text/?query=${query}&filter=duration:[60 TO 360]&fields=name,previews,duration,avg_rating&page_size=20&sort=rating_desc&token=${freesoundApiKey}`;

            try {
                const res = await fetch(url);
                if (!res.ok) {
                    if (res.status === 401) document.getElementById('key-status').textContent = '✗ key inválida';
                    return null;
                }
                const data = await res.json();
                if (data.results && data.results.length > 0) {
                    // Filtrar los mejores (rating > 3 o top 10)
                    const good = data.results
                        .filter(t => t.avg_rating >= 3 || data.results.indexOf(t) < 8)
                        .map(t => ({ url: t.previews['preview-hq-mp3'], name: t.name, duration: t.duration }));
                    _lastFreesoundResults[genre] = good;
                    return good[Math.floor(Math.random() * good.length)];
                }
            } catch (e) { console.warn('Freesound error:', e); }
            return null;
        }

        function toggleAmbientPanel() {
            const player = document.getElementById('ambient-player');
            const arrow = document.getElementById('ambient-arrow');
            player.classList.toggle('collapsed');
            arrow.textContent = player.classList.contains('collapsed') ? '▲' : '▼';
        }

        async function selectGenre(genre) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('genre-' + genre).classList.add('active');
            ambientGenre = genre;
            stopAmbient();
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando...';
            document.getElementById('ambient-track-genre').textContent = freesoundApiKey ? 'buscando en Freesound...' : 'generador local';
            // Clear cache for this genre so we get a fresh random track
            delete _lastFreesoundResults[genre];
            await playAmbient(genre);
        }

        async function playAmbient(genre) {
            const g = genre || ambientGenre;

            // Try Freesound first if key is available
            if (freesoundApiKey) {
                const track = await buscarEnFreesound(g, null);
                if (track) {
                    freesoundAudio = new Audio(track.url);
                    freesoundAudio.loop = true;
                    freesoundAudio.volume = ambientVolume;
                    freesoundAudio.crossOrigin = 'anonymous';
                    freesoundAudio.play().then(() => {
                        ambientPlaying = true;
                        document.getElementById('ambient-play-btn').textContent = '⏸';
                        document.getElementById('ambient-eq').classList.add('playing');
                        document.getElementById('ambient-track-name').textContent = track.name;
                        document.getElementById('ambient-track-genre').textContent = '♪ Freesound CC0';
                    }).catch(() => playAmbientLocal(g));
                    return;
                }
            }
            // Fallback: procedural
            playAmbientLocal(g);
        }

        function playAmbientLocal(genre) {
            const ctx = getAudioCtx();
            if (ctx.state === 'suspended') ctx.resume();
            ambientGainNode = ctx.createGain();
            ambientGainNode.gain.value = ambientVolume;
            ambientGainNode.connect(ctx.destination);
            const generator = GENRE_GENERATORS[genre || ambientGenre];
            if (!generator) return;
            ambientNodes = generator(ctx, ambientGainNode);
            ambientPlaying = true;
            document.getElementById('ambient-play-btn').textContent = '⏸';
            document.getElementById('ambient-eq').classList.add('playing');
            document.getElementById('ambient-track-name').textContent = GENRE_LABELS[genre];
            document.getElementById('ambient-track-genre').textContent = '♪ generado localmente';
        }

        function stopAmbient() {
            // Stop Freesound audio
            if (freesoundAudio) {
                freesoundAudio.pause();
                freesoundAudio.src = '';
                freesoundAudio = null;
            }
            // Stop procedural nodes
            ambientNodes.forEach(n => {
                try { if (n.osc) n.osc.stop(); } catch (e) { }
                try { if (n.src) n.src.stop(); } catch (e) { }
                if (n.interval) clearInterval(n.interval);
            });
            ambientNodes = [];
            if (ambientGainNode) {
                try { ambientGainNode.disconnect(); } catch (e) { }
                ambientGainNode = null;
            }
            ambientPlaying = false;
            document.getElementById('ambient-play-btn').textContent = '▶';
            document.getElementById('ambient-eq').classList.remove('playing');
        }

        function toggleAmbientPlay() {
            if (!ambientGenre) {
                document.getElementById('ambient-track-name').textContent = '← Elige un género primero';
                return;
            }
            if (ambientPlaying) { stopAmbient(); } else { playAmbient(ambientGenre); }
        }

        async function siguienteTrack() {
            if (!ambientGenre) return;
            stopAmbient();
            // Force new search (clear single-item cache)
            if (_lastFreesoundResults[ambientGenre]) {
                // Rotate: remove first item and re-search if empty
                _lastFreesoundResults[ambientGenre].shift();
                if (_lastFreesoundResults[ambientGenre].length === 0) {
                    delete _lastFreesoundResults[ambientGenre];
                }
            }
            document.getElementById('ambient-track-name').textContent = '⏳ Cargando siguiente...';
            await playAmbient(ambientGenre);
        }

        function setAmbientVolume(val) {
            ambientVolume = val / 100;
            document.getElementById('ambient-vol-val').textContent = val + '%';
            if (ambientGainNode) ambientGainNode.gain.value = ambientVolume;
            if (freesoundAudio) freesoundAudio.volume = ambientVolume;
        }

        // detectarGeneroLocal reemplazado por analizarTextoDetallado arriba

        async function detectarGeneroConIA() {
            const texto = document.getElementById('texto-contenido').textContent.trim();
            if (!texto || texto.length < 100) {
                document.getElementById('ambient-track-name').textContent = 'Carga un capítulo primero';
                return;
            }

            const btn = document.getElementById('btn-detect-genre');
            btn.textContent = '⏳ Analizando...';
            btn.disabled = true;

            // Análisis local rico
            const analysis = analizarTextoDetallado(texto);
            const { genre, secondary, confidence, intensity, isPaced, scores } = analysis;

            // Mostrar top 3 en consola para debug
            const top3 = Object.entries(scores).sort((a, b) => b[1] - a[1]).slice(0, 3);
            console.log('🎵 Análisis de texto:', top3.map(([g, s]) => `${g}:${s.toFixed(2)}`).join(', '), '| intensidad:', intensity.toFixed(2), '| ritmo:', isPaced ? 'rápido' : 'lento');

            // Seleccionar género con subtono
            await selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced);

            btn.textContent = '✨ Detectar género del texto';
            btn.disabled = false;
        }

        async function selectGenreWithAnalysis(genre, secondary, confidence, intensity, isPaced) {
            document.querySelectorAll('.genre-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('genre-' + genre);
            if (btn) btn.classList.add('active');
            ambientGenre = genre;
            stopAmbient();

            // Descripción de confianza
            const confLabel = confidence > 2 ? 'muy claro' : confidence > 1 ? 'probable' : 'leve';
            const rhythmLabel = isPaced ? 'ritmo rápido' : 'ritmo pausado';
            document.getElementById('ambient-track-name').textContent = '⏳ Buscando en Freesound...';
            document.getElementById('ambient-track-genre').textContent = `${GENRE_LABELS[genre]} · ${confLabel} · ${rhythmLabel}`;

            await playAmbient(genre);
        }
    </script>

    <script>
        // roundRect polyfill for browsers that don't support it
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                r = Math.min(r, w / 2, h / 2);
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
                return this;
            };
        }
    </script>
    <!-- ─── GRABACIÓN / VIDEO ─── -->
    <!-- Karaoke overlay -->
    <div id="karaoke-overlay">
        <button id="karaoke-close" onclick="cerrarKaraoke()">✕</button>
        <!-- Fondo IA: dos divs para crossfade via CSS, detrás del canvas -->
        <!-- Contenedor compartido: imagen de fondo + canvas alineados -->
        <div id="ai-bg-wrap" style="
            position:relative;
            width:min(900px,95vw);
            height:min(506px,53vw);
            flex-shrink:0;
        ">
            <div id="ai-bg-a" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <div id="ai-bg-b" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background-size:cover;
                background-position:center;
                background-repeat:no-repeat;
                transition:opacity 2s ease;
                opacity:0;
            "></div>
            <!-- Overlay oscuro encima de la imagen para que el texto sea legible -->
            <div id="ai-bg-overlay" style="
                position:absolute;
                inset:0;
                border-radius:12px;
                background:rgba(8,7,6,0);
                transition:background 1s ease;
                pointer-events:none;
            "></div>
            <canvas id="karaoke-canvas" width="1280" height="720" style="position:absolute;inset:0;width:100%;height:100%;z-index:1;background:transparent;border-radius:12px;"></canvas>
        </div>

        <!-- Barra inferior principal -->
        <div class="karaoke-bar">
            <!-- Info del capítulo + controles de música -->
            <div style="display:flex;align-items:center;gap:8px;">
                <span class="karaoke-track" id="karaoke-track-label">Sin capítulo</span>
                <div style="display:flex;align-items:center;gap:4px;margin-left:8px;">
                    <button class="kbtn kbtn-music" onclick="karaokeMusicaPrev()" title="Música anterior">&#9664;</button>
                    <span id="karaoke-music-label" style="font-size:0.58rem;color:var(--text-dim);font-family:'DM Mono',monospace;max-width:100px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">♪</span>
                    <button class="kbtn kbtn-music" onclick="karaokeMusicaSiguiente()" title="Música siguiente">&#9654;</button>
                </div>
            </div>

            <!-- Controles centrados: nav + play/pause -->
            <div class="karaoke-playbar">
                <button class="kbtn kbtn-nav" id="kbtn-prev" onclick="karaokeCapituloAnterior()" title="Capítulo anterior">&#9664;&#9664;</button>
                <button class="kbtn kbtn-play" id="kbtn-playpause" onclick="karaokeTogglePlay()" title="Play / Pausa">&#9654;</button>
                <button class="kbtn kbtn-nav" id="kbtn-next" onclick="karaokeCapituloSiguiente()" title="Capítulo siguiente">&#9654;&#9654;</button>
            </div>

            <!-- Acciones: exportar y cerrar -->
            <div class="karaoke-controls">
                <button id="btn-toggle-ai-img" onclick="toggleAIImages()" title="Activar/desactivar imágenes IA de fondo">🖼 IA Imágenes</button>
                <button id="btn-export-video" onclick="exportarVideo()">⬇ Exportar video</button>
                <button id="btn-cancel-export" onclick="cancelarExportacion()" style="display:none;">✕ Cancelar</button>
                <button onclick="cerrarKaraoke()">Cerrar</button>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════
        // GRABACIÓN DE AUDIO (TTS + Música)
        // ═══════════════════════════════════════

        let mediaRecorder = null;
        let grabacionChunks = [];
        let grabando = false;
        let destinationNode = null;
        let audioCtxGrab = null;

        async function toggleGrabacion() {
            if (grabando) {
                detenerGrabacion();
            } else {
                iniciarGrabacion();
            }
        }

        async function iniciarGrabacion() {
            try {
                // Crear AudioContext compartido para mezclar TTS + música
                audioCtxGrab = getAudioCtx();

                const dest = audioCtxGrab.createMediaStreamDestination();
                destinationNode = dest;

                // Conectar música ambiental al stream de grabación
                if (ambientGainNode) ambientGainNode.connect(dest);

                // Para TTS del navegador necesitamos capturar el audio del sistema
                // Usamos un approach mixto: capturamos pantalla con audio del sistema
                let stream;
                try {
                    stream = await navigator.mediaDevices.getDisplayMedia({
                        video: false,
                        audio: { systemAudio: 'include' }
                    });
                    // Mezclar con la música del AudioContext
                    const sysSource = audioCtxGrab.createMediaStreamSource(stream);
                    sysSource.connect(dest);
                } catch (e) {
                    // Fallback: solo audio del AudioContext (música sin TTS si no hay permiso)
                    stream = dest.stream;
                    mostrarNotificacion('⚠ Solo se grabará la música (permite audio del sistema para incluir voz)');
                }

                // Combinar streams
                const tracks = [...dest.stream.getTracks()];
                if (stream && stream.getAudioTracks) {
                    stream.getAudioTracks().forEach(t => tracks.push(t));
                }
                const combinedStream = new MediaStream(tracks);

                grabacionChunks = [];
                mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'audio/webm' });
                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) grabacionChunks.push(e.data); };
                mediaRecorder.onstop = descargarAudio;
                mediaRecorder.start(100);

                grabando = true;
                const btn = document.getElementById('btn-rec-audio');
                btn.classList.add('recording');
                btn.querySelector('#rec-dot').textContent = '⏹';
                btn.childNodes[1].textContent = ' Detener grabación';
                mostrarNotificacion('🔴 Grabando...');

            } catch (e) {
                console.error('Error al iniciar grabación:', e);
                mostrarNotificacion('⚠ Error al iniciar grabación');
            }
        }

        function detenerGrabacion() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            grabando = false;
            const btn = document.getElementById('btn-rec-audio');
            btn.classList.remove('recording');
            btn.querySelector('#rec-dot').textContent = '⏺';
            btn.childNodes[1].textContent = ' Grabar audio';
            mostrarNotificacion('💾 Procesando audio...');
        }

        function descargarAudio() {
            const blob = new Blob(grabacionChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const capitulo = document.getElementById('current-chapter-title').textContent || 'lectura';
            a.download = `${capitulo.replace(/[^a-zA-Z0-9]/g, '_')}_audio.webm`;
            a.click();
            URL.revokeObjectURL(url);
            mostrarNotificacion('✓ Audio descargado');
        }

        // ═══════════════════════════════════════
        // KARAOKE / VISTA SPOTIFY
        // ═══════════════════════════════════════

        let karaokeAnimFrame = null;
        let karaokeCanvas = null;
        let karaokeCtx = null;
        let karaokeRecorder = null;
        let karaokeChunks = [];
        let karaokeActive = false;

        const KARAOKE_BG = '#0a0908';
        const KARAOKE_TEXT_DIM = '#5a5248';
        const KARAOKE_TEXT = '#e8e0d0';
        const KARAOKE_HIGHLIGHT = '#c8a96e';
        const KARAOKE_SECONDARY = 'rgba(200,169,110,0.3)';

        function abrirKaraoke() {
            const overlay = document.getElementById('karaoke-overlay');
            overlay.classList.add('active');
            karaokeCanvas = document.getElementById('karaoke-canvas');
            karaokeCtx = karaokeCanvas.getContext('2d');
            karaokeActive = true;

            const capitulo = document.getElementById('current-chapter-title').textContent || 'Capítulo';
            document.getElementById('karaoke-track-label').textContent = capitulo;

            // Reiniciar sistema de imágenes IA para el nuevo capítulo
            aiSlotSolicitado = {};
            aiCurrentSlot = -1;
            aiActivePanel = 'a';
            aiSlotActivo = false;
            aiLoadingSlot = null;
            document.getElementById('ai-bg-a').style.opacity = '0';
            document.getElementById('ai-bg-b').style.opacity = '0';
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
            if (aiImagesEnabled) {
                solicitarImagenParaSlot(0);
                solicitarImagenParaSlot(1);
            }

            renderKaraokeFrame();
        }

        function cerrarKaraoke() {
            karaokeActive = false;
            document.getElementById('karaoke-overlay').classList.remove('active');
            if (karaokeAnimFrame) cancelAnimationFrame(karaokeAnimFrame);
            if (karaokeRecorder && karaokeRecorder.state !== 'inactive') karaokeRecorder.stop();
        }

        // Cerrar modo video con tecla Escape
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' && karaokeActive) {
                cerrarKaraoke();
            }
        });

        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let line = '';
            for (const word of words) {
                const test = line ? line + ' ' + word : word;
                if (ctx.measureText(test).width > maxWidth && line) {
                    lines.push(line);
                    line = word;
                } else {
                    line = test;
                }
            }
            if (line) lines.push(line);
            return lines;
        }

        // Measures lines height for a text block
        function measureTextBlock(ctx, text, maxW, lineH) {
            return wrapText(ctx, text, maxW).length * lineH;
        }

        function drawKaraokeScene(ctx, W, H, current, total) {
            // Background: sólido si no hay imágenes IA, transparente si las hay
            if (aiImagesEnabled && aiSlotActivo) {
                ctx.clearRect(0, 0, W, H);
                // Overlay de viñeta leve sobre la imagen CSS
                ctx.fillStyle = 'rgba(8,7,6,0.35)';
                ctx.fillRect(0, 0, W, H);
            } else {
                ctx.fillStyle = KARAOKE_BG;
                ctx.fillRect(0, 0, W, H);
            }

            // Vignette
            const vignette = ctx.createRadialGradient(W / 2, H / 2, H * 0.2, W / 2, H / 2, H * 0.85);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.65)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, W, H);

            // Header: chapter title + counter
            ctx.font = '15px "Courier New", monospace';
            ctx.fillStyle = KARAOKE_TEXT_DIM;
            ctx.textAlign = 'left';
            ctx.fillText(document.getElementById('current-chapter-title').textContent, W * 0.1, 36);
            ctx.textAlign = 'right';
            ctx.fillText(`${current + 1} / ${total}`, W * 0.9, 36);

            if (!sentences || total === 0) {
                ctx.fillStyle = KARAOKE_TEXT_DIM;
                ctx.font = 'italic 26px "Georgia", serif';
                ctx.textAlign = 'center';
                ctx.fillText('Inicia la reproducción para ver el karaoke', W / 2, H / 2);
                return;
            }

            const MAX_W = W * 0.78;
            const CX = W / 2;

            // ── Layout dinámico: calcular alturas reales antes de dibujar ──
            const PREV_SIZE = 22;
            const CUR_SIZE = 36;
            const NEXT_SIZE = 20;
            const PREV_LH = 32;
            const CUR_LH = 52;
            const NEXT_LH = 30;
            const GAP = 28; // espacio entre bloques

            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            const curLines = wrapText(ctx, sentences[current] || '', MAX_W);
            const curBlockH = curLines.length * CUR_LH;

            ctx.font = `${PREV_SIZE}px "Georgia", serif`;
            const prevLines = current > 0 ? wrapText(ctx, sentences[current - 1], MAX_W) : [];
            const prevBlockH = prevLines.length * PREV_LH;

            ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
            const nextLines = current < total - 1 ? wrapText(ctx, sentences[current + 1], MAX_W) : [];
            const nextBlockH = nextLines.length * NEXT_LH;

            // Center the current block, then place prev above and next below
            const USABLE_TOP = 60;
            const USABLE_BOT = H - 60;
            const USABLE_H = USABLE_BOT - USABLE_TOP;

            const totalH = prevBlockH + (prevLines.length ? GAP : 0)
                + curBlockH
                + (nextLines.length ? GAP : 0)
                + nextBlockH;

            // Start Y so the whole layout is vertically centered
            let startY = USABLE_TOP + (USABLE_H - totalH) / 2;
            startY = Math.max(startY, USABLE_TOP + 10);

            let drawY = startY;

            // Draw previous (dim, above)
            if (prevLines.length) {
                ctx.font = `${PREV_SIZE}px "Georgia", serif`;
                ctx.fillStyle = KARAOKE_TEXT_DIM;
                ctx.textAlign = 'center';
                prevLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * PREV_LH);
                });
                drawY += prevBlockH + GAP;
            }

            // Draw current (highlighted, glow)
            ctx.font = `italic ${CUR_SIZE}px "Georgia", serif`;
            ctx.textAlign = 'center';
            ctx.shadowColor = KARAOKE_HIGHLIGHT;
            ctx.shadowBlur = 18;
            ctx.fillStyle = KARAOKE_HIGHLIGHT;
            curLines.forEach((l, i) => {
                ctx.fillText(l, CX, drawY + i * CUR_LH);
            });
            ctx.shadowBlur = 0;
            drawY += curBlockH + GAP;

            // Draw next (very dim, below)
            if (nextLines.length) {
                ctx.font = `${NEXT_SIZE}px "Georgia", serif`;
                ctx.fillStyle = 'rgba(200,169,110,0.22)';
                ctx.textAlign = 'center';
                nextLines.forEach((l, i) => {
                    ctx.fillText(l, CX, drawY + i * NEXT_LH);
                });
            }

            // Progress bar
            const prog = total > 1 ? (current / (total - 1)) : 1;
            ctx.fillStyle = 'rgba(255,255,255,0.07)';
            ctx.beginPath(); ctx.roundRect(W * 0.1, H - 38, W * 0.8, 3, 2); ctx.fill();
            ctx.fillStyle = KARAOKE_HIGHLIGHT;
            ctx.beginPath(); ctx.roundRect(W * 0.1, H - 38, W * 0.8 * prog, 3, 2); ctx.fill();

            // Music indicator
            if (ambientPlaying) {
                ctx.font = '16px monospace';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(126,184,154,0.45)';
                ctx.fillText('♪', W * 0.1, H - 16);
            }

            // Indicador de carga de imagen IA
            if (aiImagesEnabled && aiLoadingSlot !== null) {
                ctx.font = '11px "Courier New", monospace';
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(126,184,154,0.45)';
                ctx.fillText('✦ generando imagen con IA...', W * 0.9, H - 16);
            }
        }

        function renderKaraokeFrame() {
            if (!karaokeActive) return;
            drawKaraokeScene(karaokeCtx, karaokeCanvas.width, karaokeCanvas.height,
                currentSentenceIndex, sentences.length);
            karaokeAnimFrame = requestAnimationFrame(renderKaraokeFrame);
        }

        // ── Generación de video en segundo plano (sin grabar en tiempo real) ──
        // Dibuja cada frame del karaoke a velocidad acelerada y los codifica
        let exportandoVideo = false;

        async function exportarVideo() {
            if (!sentences || sentences.length === 0) {
                mostrarNotificacion('Cargá y reproducí un capítulo primero');
                return;
            }
            if (exportandoVideo) { mostrarNotificacion('Ya hay una exportación en curso...'); return; }

            exportandoVideo = true;

            // Asegurar que el karaoke esté abierto (necesitamos el canvas)
            if (!karaokeActive) abrirKaraoke();

            const W = karaokeCanvas.width;
            const H = karaokeCanvas.height;
            const FPS = 24;
            // Estimar duración: promedio de 3.5 segundos por oración
            const SEC_PER_SENTENCE = 3.5;
            const totalSec = sentences.length * SEC_PER_SENTENCE;
            const totalFrames = Math.ceil(totalSec * FPS);

            mostrarNotificacion(`⏳ Generando ${sentences.length} escenas... (${Math.ceil(totalSec)}s de video)`);
            document.getElementById('karaoke-track-label').textContent = '⏳ Generando video en segundo plano...';

            // Usar un canvas offscreen para no interferir con la vista live
            const offCanvas = document.createElement('canvas');
            offCanvas.width = W; offCanvas.height = H;
            const offCtx = offCanvas.getContext('2d');

            // Capturar el stream del offscreen canvas
            const stream = offCanvas.captureStream(FPS);

            // Agregar audio ambiental al stream si está disponible
            if (ambientGainNode) {
                try {
                    const actx = getAudioCtx();
                    const audioDest = actx.createMediaStreamDestination();
                    ambientGainNode.connect(audioDest);
                    audioDest.stream.getAudioTracks().forEach(t => stream.addTrack(t));
                } catch (e) { }
            }

            karaokeChunks = [];
            const mimeType = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm']
                .find(m => MediaRecorder.isTypeSupported(m)) || 'video/webm';

            karaokeRecorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 });
            karaokeRecorder.ondataavailable = e => { if (e.data.size > 0) karaokeChunks.push(e.data); };
            karaokeRecorder.onstop = () => {
                const blob = new Blob(karaokeChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const cap = (document.getElementById('current-chapter-title').textContent || 'lectura').trim();
                a.download = `${cap.replace(/[^a-zA-Z0-9áéíóúñ ]/g, '_')}_karaoke.webm`;
                a.click();
                URL.revokeObjectURL(url);
                exportandoVideo = false;
                document.getElementById('btn-export-video').style.display = 'inline';
                document.getElementById('btn-cancel-export').style.display = 'none';
                mostrarNotificacion('✓ Video generado y descargado');
                document.getElementById('karaoke-track-label').textContent = cap;
            };

            karaokeRecorder.start();
            document.getElementById('btn-export-video').style.display = 'none';
            document.getElementById('btn-cancel-export').style.display = 'inline';

            // Renderizar frame a frame en segundo plano a mayor velocidad
            // ~4 frames por oración = transición suave sin que dure 30 min
            const FRAMES_PER_SENTENCE = FPS * SEC_PER_SENTENCE;
            let frameIdx = 0;

            const renderNext = () => {
                if (!exportandoVideo) { karaokeRecorder.stop(); return; }

                const sentenceIdx = Math.min(Math.floor(frameIdx / FRAMES_PER_SENTENCE), sentences.length - 1);
                const frameInSentence = frameIdx % FRAMES_PER_SENTENCE;
                const total = sentences.length;

                drawKaraokeScene(offCtx, W, H, sentenceIdx, total);

                // Transición suave: fade en los primeros/últimos frames de la oración
                if (frameInSentence < 8) {
                    const alpha = frameInSentence / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.7})`;
                    offCtx.fillRect(0, 0, W, H);
                } else if (frameInSentence > FRAMES_PER_SENTENCE - 8) {
                    const alpha = (FRAMES_PER_SENTENCE - frameInSentence) / 8;
                    offCtx.fillStyle = `rgba(10,9,8,${(1 - alpha) * 0.5})`;
                    offCtx.fillRect(0, 0, W, H);
                }

                frameIdx++;

                // Progreso
                if (frameIdx % (FPS * 2) === 0) {
                    const pct = Math.round((frameIdx / totalFrames) * 100);
                    document.getElementById('karaoke-track-label').textContent = `⏳ Generando video... ${pct}%`;
                }

                if (frameIdx >= totalFrames) {
                    // Último frame — pausa un momento y termina
                    setTimeout(() => karaokeRecorder.stop(), 300);
                    return;
                }

                // Usar setTimeout(0) para no bloquear el UI, pero ir rápido
                setTimeout(renderNext, 1000 / FPS / 4); // 4x más rápido que tiempo real
            };

            renderNext();
        }

        function cancelarExportacion() {
            exportandoVideo = false;
            if (karaokeRecorder && karaokeRecorder.state !== 'inactive') karaokeRecorder.stop();
            mostrarNotificacion('Exportación cancelada');
        }

        // ═══════════════════════════════════════
        // SISTEMA DE IMÁGENES IA — Claude + Pollinations.AI (model=flux)
        // ═══════════════════════════════════════

        let aiImagesEnabled = false;
        let aiSlotActivo = false;
        let aiLoadingSlot = null;
        let aiCurrentSlot = -1;
        let aiActivePanel = 'a';

        // Cambiar imagen cada ~280 chars acumulados (≈ 2-3 párrafos extensos)
        const AI_CHARS_PER_IMAGE = 280;
        let aiSlotSolicitado = {};
        let aiSentenceToSlot = [];   // idx oración → número de slot

        // Construir el mapa de slots basado en acumulación de chars reales
        function buildAiSlotMap() {
            aiSentenceToSlot = [];
            if (!sentences || sentences.length === 0) return;
            let slot = 0, chars = 0;
            for (let i = 0; i < sentences.length; i++) {
                aiSentenceToSlot[i] = slot;
                chars += sentences[i].length;
                if (chars >= AI_CHARS_PER_IMAGE) { slot++; chars = 0; }
            }
        }

        function getSlotForSentence(idx) {
            return (aiSentenceToSlot && aiSentenceToSlot[idx] !== undefined)
                ? aiSentenceToSlot[idx]
                : Math.floor(idx / 8);
        }

        // Fragmento de texto para un slot
        function extraerFragmentoParaSlot(slot) {
            if (!sentences || sentences.length === 0) return '';
            const idxs = aiSentenceToSlot
                .map((s, i) => s === slot ? i : -1)
                .filter(i => i >= 0);
            if (idxs.length === 0) return sentences.slice(0, 8).join(' ');
            // Incluir un poco de contexto previo para mejor coherencia
            const start = Math.max(0, idxs[0] - 3);
            const end = idxs[idxs.length - 1] + 1;
            return sentences.slice(start, end).join(' ');
        }

        // ── Detección automática del universo/libro ──
        let aiDetectedUniverse = null;

        const AI_UNIVERSES = {
            'shadow slave': 'Shadow Slave webnovel',
            'esclavo de las sombras': 'Shadow Slave webnovel',
            'forgotten shore': 'Shadow Slave webnovel',
            'guiltythree': 'Shadow Slave webnovel',
        };

        // Estilos base por universo detectado
        const AI_UNIVERSE_STYLES = {
            'Shadow Slave webnovel':
                'dark fantasy concept art, Shadow Slave webnovel visual style, ruined ancient citadel consumed by eldritch darkness, nightmare realm with shattered obsidian sky, bioluminescent corruption spreading across crumbling stone, golden divine light cutting through ash and shadow, nightmare creatures with multiple eyes, Dark Souls meets Diablo aesthetic, high-detail atmospheric digital painting, no text no watermark',
        };

        const AI_DEFAULT_STYLE = 'cinematic dark fantasy digital painting, dramatic chiaroscuro lighting, atmospheric depth, no text no watermark';

        function detectarUniverso() {
            const fuentes = [
                document.getElementById('file-name')?.textContent || '',
                document.getElementById('current-chapter-title')?.textContent || '',
                (sentences || []).slice(0, 30).join(' ')
            ].join(' ').toLowerCase();

            aiDetectedUniverse = null;
            for (const [key, val] of Object.entries(AI_UNIVERSES)) {
                if (fuentes.includes(key)) {
                    aiDetectedUniverse = val;
                    console.log(`📚 Universo detectado: ${val}`);
                    mostrarNotificacion(`📚 Estilo visual: ${val}`);
                    break;
                }
            }
        }

        function getStyleTag() {
            if (aiDetectedUniverse && AI_UNIVERSE_STYLES[aiDetectedUniverse]) {
                return AI_UNIVERSE_STYLES[aiDetectedUniverse];
            }
            return AI_DEFAULT_STYLE;
        }

        function toggleAIImages() {
            aiImagesEnabled = !aiImagesEnabled;
            const btn = document.getElementById('btn-toggle-ai-img');
            if (aiImagesEnabled) {
                btn.classList.add('ai-active');
                btn.textContent = '🖼 IA ON';
                detectarUniverso();
                buildAiSlotMap();
                mostrarNotificacion('🖼 Imágenes IA activadas');
                aiSlotSolicitado = {};
                aiCurrentSlot = -1;
                aiActivePanel = 'a';
                const slot = getSlotForSentence(typeof currentSentenceIndex !== 'undefined' ? currentSentenceIndex : 0);
                solicitarImagenParaSlot(slot);
                setTimeout(() => solicitarImagenParaSlot(slot + 1), 800);
                setTimeout(() => solicitarImagenParaSlot(slot + 2), 1600);
            } else {
                btn.classList.remove('ai-active');
                btn.textContent = '🖼 IA Imágenes';
                document.getElementById('ai-bg-a').style.opacity = '0';
                document.getElementById('ai-bg-b').style.opacity = '0';
                document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0)';
                aiSlotActivo = false;
                mostrarNotificacion('Imágenes IA desactivadas');
            }
        }

        // ── Cache de prompts ──
        const aiPromptCache = {};

        // Genera el prompt visual usando Pollinations GET API (sin CORS, sin key, sin POST)
        async function generarPromptConClaude(fragmento) {
            const cacheKey = fragmento.slice(0, 100);
            if (aiPromptCache[cacheKey]) return aiPromptCache[cacheKey];

            const styleTag = getStyleTag();
            const universeHint = aiDetectedUniverse
                ? `From webnovel "${aiDetectedUniverse}", match its visual style.`
                : '';

            // System prompt compacto
            const systemPrompt = `You are an image prompt generator. ${universeHint} Given a fiction passage, output ONLY an English image generation prompt (max 60 words): describe the specific environment, mood, lighting, time of day; never name characters, describe by silhouette or role only; always end with: "${styleTag}". No preamble.`;

            // Texto del pasaje
            const pasaje = fragmento.slice(0, 350).replace(/"/g, "'");

            // Helper: detectar si el texto es el aviso de deprecación u otro error
            function esRespuestaInvalida(txt) {
                return !txt || txt.length < 20 ||
                    txt.includes('IMPORTANT NOTICE') ||
                    txt.includes('deprecated') ||
                    txt.includes('DEPRECATED') ||
                    txt.includes('please update') ||
                    txt.includes('Please update') ||
                    txt.toUpperCase().includes('NOTICE');
            }

            // Intentar con Pollinations (timeout corto para no bloquear)
            try {
                const ctrl = new AbortController();
                const timer = setTimeout(() => ctrl.abort(), 6000);
                const res = await fetch('https://text.pollinations.ai/openai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'mistral',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: pasaje }
                        ],
                        private: true,
                        seed: Math.floor(Math.random() * 9999)
                    }),
                    signal: ctrl.signal
                });
                clearTimeout(timer);
                if (res.ok) {
                    const data = await res.json();
                    let prompt = (data?.choices?.[0]?.message?.content || '').trim();
                    prompt = prompt.split('\n')[0].trim();
                    if (!esRespuestaInvalida(prompt)) {
                        aiPromptCache[cacheKey] = prompt;
                        console.log('Prompt (Pollinations/mistral):', prompt.slice(0, 80));
                        return prompt;
                    }
                }
            } catch (e) { /* timeout o error — usar prompt local */ }

            // Prompt local: extracción semántica sin LLM
            const promptLocal = construirPromptDirecto(fragmento, styleTag);
            aiPromptCache[cacheKey] = promptLocal;
            console.log('Prompt (local):', promptLocal.slice(0, 80));
            return promptLocal;
        }

        // Generador de prompts sin LLM — extrae entidades reales del texto
        function construirPromptDirecto(fragmento, styleTag) {
            const t = fragmento.toLowerCase();
            const parts = [];

            // — ESCENARIO —
            if (/laboratorio|lab|experiment|científico|scientist/.test(t)) parts.push('underground science laboratory, flickering monitors, cables everywhere');
            else if (/hospital|enfermería|nurse|médico|doctor|clínica/.test(t)) parts.push('abandoned hospital corridor, flickering fluorescent lights, sterile decay');
            else if (/prisión|celda|prison|jail|dungeon|calabozo/.test(t)) parts.push('stone dungeon cell, iron bars, dripping walls');
            else if (/mansión|manor|palacio|palace|salón|hall/.test(t)) parts.push('grand decaying mansion interior, ornate but crumbling');
            else if (/bosque|selva|forest|jungle|árbol|tree/.test(t)) parts.push('ancient dark forest, gnarled roots, fog between trees');
            else if (/ciudad|city|calle|street|edificio|building|urbano/.test(t)) parts.push('dystopian urban sprawl, neon reflections on wet asphalt, towering structures');
            else if (/castillo|fortress|torre|tower|muralla|castle/.test(t)) parts.push('ancient stone fortress at dusk, crumbling battlements, ravens circling');
            else if (/cueva|cave|cavern|túnel|tunnel|underground/.test(t)) parts.push('vast underground cavern, bioluminescent fungi, stalactites');
            else if (/desierto|wasteland|arena|sand|desert/.test(t)) parts.push('scorched wasteland under blood-red sky, cracked earth, ruins in distance');
            else if (/mar|ocean|sea|costa|coast|playa|beach|puerto/.test(t)) parts.push('storm-lashed ocean coast, massive waves, jagged cliffs');
            else if (/montaña|mountain|cumbre|peak|cliff|acantilado/.test(t)) parts.push('treacherous mountain peaks shrouded in mist, sheer drop below');
            else if (/templo|temple|shrine|sanctuario|altar/.test(t)) parts.push('ancient temple interior, moss-covered stone pillars, shafts of divine light');
            else if (/mercado|market|plaza|tavern|taberna|inn/.test(t)) parts.push('crowded medieval marketplace, torchlit stalls, cobblestone streets');
            else if (/nave|spaceship|space|cosmos|espacio|galaxy/.test(t)) parts.push('deep space void, distant nebula, derelict starship hull');
            else parts.push('vast desolate realm, broken landscape, oppressive silence');

            // — ACCIÓN / TENSIÓN —
            if (/batalla|combate|fight|battle|lucha|clash|guerra|war/.test(t)) parts.push('mid-battle chaos, dust and sparks');
            else if (/huir|escape|chase|perseguir|run|correr/.test(t)) parts.push('desperate chase, motion blur, panic in the air');
            else if (/ritual|ceremony|spell|hechizo|magia|magic/.test(t)) parts.push('arcane ritual in progress, glowing sigils, dark energy swirling');
            else if (/muerte|death|dead|matar|kill|sangre|blood/.test(t)) parts.push('aftermath of violence, ominous stillness');
            else if (/reunión|meeting|gather|consejo|council/.test(t)) parts.push('tense gathering of shadowed figures');
            else if (/silencio|quiet|alone|soledad|lonely/.test(t)) parts.push('solitary figure in vast emptiness');

            // — HORA Y LUZ —
            if (/amanecer|dawn|sunrise|alba/.test(t)) parts.push('cold dawn light breaking through clouds');
            else if (/atardecer|sunset|dusk|crepúsculo/.test(t)) parts.push('deep amber sunset casting long shadows');
            else if (/noche|night|midnight|medianoche|oscuridad/.test(t)) parts.push('moonless night, only distant stars');
            else if (/mediodía|noon|midday|sol|bright|sunlight/.test(t)) parts.push('harsh midday sun, deep shadows');
            else if (/lluvia|rain|storm|tormenta|thunder|trueno/.test(t)) parts.push('driving rain, lightning illuminating the scene');
            else if (/niebla|fog|mist|neblina/.test(t)) parts.push('thick fog, diffused ghostly light');
            else if (/fuego|fire|llama|flame|antorcha|torch/.test(t)) parts.push('dramatic firelight, dancing orange shadows');
            else parts.push('dim atmospheric light, deep chiaroscuro');

            // — PERSONAJES (por rol, nunca por nombre) —
            if (/guerrero|warrior|knight|caballero|soldier|soldado/.test(t)) parts.push('armored silhouette in foreground');
            else if (/mago|wizard|sorcerer|brujo|mage/.test(t)) parts.push('robed figure wreathed in magical energy');
            else if (/asesino|assassin|rogue|ladrón|thief/.test(t)) parts.push('cloaked figure in deep shadow');
            else if (/monstruo|monster|beast|bestia|creature|criatura/.test(t)) parts.push('massive terrifying creature emerging from darkness');
            else if (/rey|king|queen|reina|emperor|emperador/.test(t)) parts.push('commanding royal silhouette on throne');

            // — MOOD —
            if (/esperanza|hope|victory|victoria|triumph/.test(t)) parts.push('faint hopeful glimmer amid darkness');
            else if (/terror|horror|miedo|dread|fear/.test(t)) parts.push('oppressive dread, wrongness in the air');
            else if (/misterio|mystery|secret|secreto/.test(t)) parts.push('mysterious and unsettling atmosphere');
            else parts.push('cinematic epic atmosphere');

            return parts.join(', ') + ', ' + styleTag;
        }

        // URL de Pollinations — model=flux, parámetros documentados
        function pollinationsUrl(prompt, seed) {
            const encoded = encodeURIComponent(prompt);
            return `https://image.pollinations.ai/prompt/${encoded}?model=flux&width=1280&height=720&seed=${seed}&nologo=true&enhance=true&private=true`;
        }

        // ── STABLE HORDE: generación AI distribuida, anónima, sin API key ──
        // API docs: https://stablehorde.net/api/
        const HORDE_API = 'https://stablehorde.net/api/v2';
        const hordeQueue = {};   // slot → { jobId, polling }

        // Modelos disponibles en Stable Horde (sin key anónima)
        const HORDE_MODELS = ['Deliberate 3.0', 'Dreamshaper 8', 'AbsoluteReality 1.8.1', 'Deliberate'];

        async function generarImagenStableHorde(prompt, seed, slot) {
            // Obtener modelos disponibles para elegir uno válido
            let modelosActivos = HORDE_MODELS;
            try {
                const mr = await fetch(`${HORDE_API}/status/models?type=image&min_count=1`, { signal: AbortSignal.timeout(5000) });
                if (mr.ok) {
                    const lista = await mr.json();
                    modelosActivos = lista.slice(0, 5).map(m => m.name);
                    console.log('Horde modelos disponibles:', modelosActivos.slice(0, 3).join(', '));
                }
            } catch (e) { /* usar lista por defecto */ }

            // Intentar enviar, con reintento si hay 429
            for (let intento = 0; intento < 3; intento++) {
                if (intento > 0) await new Promise(r => setTimeout(r, 5000 * intento));
                try {
                    const resp = await fetch(`${HORDE_API}/generate/async`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'apikey': '0000000000' },
                        body: JSON.stringify({
                            prompt: prompt.slice(0, 500),
                            params: {
                                width: 1024, height: 576,
                                steps: 20, cfg_scale: 7,
                                seed: String(seed),
                                sampler_name: 'k_euler_a'
                            },
                            models: [modelosActivos[0]],
                            r2: true,
                            nsfw: false,
                            slow_workers: true
                        })
                    });
                    if (resp.status === 429) {
                        console.warn(`Horde 429, reintentando en ${5 * (intento + 1)}s...`);
                        continue;
                    }
                    if (!resp.ok) {
                        const txt = await resp.text();
                        console.warn(`Horde ${resp.status}:`, txt.slice(0, 100));
                        // Intentar con siguiente modelo
                        if (modelosActivos.length > 1) modelosActivos.shift();
                        continue;
                    }
                    const { id } = await resp.json();
                    if (!id) continue;
                    console.log(`🎨 Horde job enviado: ${id} (slot ${slot})`);
                    return await pollHordeJob(id, slot);
                } catch (e) {
                    console.warn('Horde error:', e.message);
                }
            }
            return null;
        }

        async function pollHordeJob(jobId, slot, attempts = 0) {
            if (attempts > 40) return null; // máx ~2 min
            await new Promise(r => setTimeout(r, 3000));
            try {
                const resp = await fetch(`${HORDE_API}/generate/check/${jobId}`);
                if (!resp.ok) return null;
                const status = await resp.json();
                if (status.done) {
                    // Obtener la imagen
                    const resp2 = await fetch(`${HORDE_API}/generate/status/${jobId}`);
                    const data = await resp2.json();
                    const imgUrl = data?.generations?.[0]?.img;
                    if (imgUrl) {
                        console.log(`🖼 Horde imagen lista — slot ${slot}`);
                        return imgUrl;
                    }
                    return null;
                }
                console.log(`⏳ Horde esperando (slot ${slot}): queue=${status.queue_position}, workers=${status.waiting}`);
                return await pollHordeJob(jobId, slot, attempts + 1);
            } catch (e) { return null; }
        }

        // ── PUTER.JS: imagen IA gratuita sin API key, sin queue ──
        // Usa modelo FLUX.1 Schnell (rápido) o SDXL como fallback
        // El "User-Pays" model: el usuario cubre el costo de sus propias generaciones
        let puterDisponible = true; // optimistic — verificamos en el primer intento

        async function intentarPuter(prompt, seed) {
            // Verificar disponibilidad en tiempo real (Puter carga async)
            if (!puterDisponible) return null;
            if (typeof puter === 'undefined' || !puter?.ai?.txt2img) {
                console.log('Puter.js no cargado, saltando...');
                puterDisponible = false;
                return null;
            }
            try {
                // txt2img devuelve un HTMLImageElement con src ya cargado
                const imgEl = await Promise.race([
                    puter.ai.txt2img(prompt.slice(0, 300), {
                        model: 'black-forest-labs/FLUX.1-schnell',
                    }),
                    new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 28000))
                ]);
                if (imgEl && imgEl.src) {
                    console.log('✅ Puter.js imagen lista:', imgEl.src.slice(0, 60));
                    return imgEl.src;
                }
                return null;
            } catch (e) {
                console.warn('Puter.js falló:', e.message);
                // Si falla por auth o cuenta, no reintentar
                if (e.message && (e.message.includes('401') || e.message.includes('auth') || e.message.includes('sign'))) {
                    puterDisponible = false;
                }
                return null;
            }
        }

        // Pollinations — rate limit: 1 req cada 15s en tier anónimo
        let pollinationsLastRequest = 0;

        async function intentarPollinations(prompt, seed) {
            // Respetar rate limit: esperar si hace menos de 16s del último request
            const ahora = Date.now();
            const espera = Math.max(0, 16000 - (ahora - pollinationsLastRequest));
            if (espera > 0) await new Promise(r => setTimeout(r, espera));
            pollinationsLastRequest = Date.now();

            // Endpoint correcto: image.pollinations.ai
            const shortPrompt = prompt.slice(0, 280);
            const urls = [
                `https://image.pollinations.ai/prompt/${encodeURIComponent(shortPrompt)}?width=1280&height=720&seed=${seed}&model=flux&nologo=true`,
                `https://image.pollinations.ai/prompt/${encodeURIComponent(shortPrompt)}?width=1280&height=720&seed=${seed}&model=turbo&nologo=true`,
                `https://image.pollinations.ai/prompt/${encodeURIComponent(getStyleTag())}?width=1280&height=720&seed=${seed}&model=flux&nologo=true`,
            ];
            for (let i = 0; i < urls.length; i++) {
                const ok = await new Promise(resolve => {
                    const img = new Image();
                    // Timeout reducido a 12s para no bloquear la cola demasiado tiempo
                    const t = setTimeout(() => { img.src = ''; resolve(false); }, 12000);
                    img.onload = () => { clearTimeout(t); resolve(true); };
                    img.onerror = () => { clearTimeout(t); resolve(false); };
                    img.src = urls[i];
                });
                if (ok) { console.log(`Pollinations OK (modelo ${i + 1}):`, urls[i].slice(0, 80)); return urls[i]; }
            }
            return null;
        }

        // Cola serializada para Pollinations — garantiza 1 request activo a la vez
        // Cada tarea devuelve su URL para evitar el bug de variable compartida
        let pollinationsQueue = Promise.resolve(null);

        function encolarPollinations(prompt, seed) {
            // Encadena la tarea ANTES de ejecutar nada — retorna la promesa del resultado
            const tareaActual = pollinationsQueue.then(() => intentarPollinations(prompt, seed));
            // La cola global espera a que esta tarea termine (sin propagar el valor)
            pollinationsQueue = tareaActual.then(() => null, () => null);
            return tareaActual;
        }

        // Cola serializada para Horde — garantiza 1 job activo a la vez con key anónima
        let hordeQueue2 = Promise.resolve();

        function encolarHorde(prompt, seed, slot) {
            const tarea = hordeQueue2.then(async () => {
                console.log(`🎨 Pollinations no disponible, usando Stable Horde para slot ${slot}...`);
                const hordeUrl = await generarImagenStableHorde(prompt, seed, slot);
                if (aiLoadingSlot === slot) aiLoadingSlot = null;
                if (hordeUrl) mostrarImagenEnPanel(slot, hordeUrl);
                else console.warn(`🖼 Sin imagen para slot ${slot}`);
            });
            hordeQueue2 = tarea.then(() => null, () => null);
            return tarea;
        }

        async function cargarImagenConFallback(prompt, seed, slot) {
            // 1️⃣ Puter.js — sin key, sin queue, FLUX Schnell (~5-10s)
            const puterUrl = await intentarPuter(prompt, seed);
            if (puterUrl) {
                if (aiLoadingSlot === slot) aiLoadingSlot = null;
                mostrarImagenEnPanel(slot, puterUrl);
                return;
            }

            // 2️⃣ Pollinations — serializado, 1 req cada 16s
            const polUrl = await encolarPollinations(prompt, seed);
            if (polUrl) {
                if (aiLoadingSlot === slot) aiLoadingSlot = null;
                mostrarImagenEnPanel(slot, polUrl);
                return;
            }

            // 3️⃣ Stable Horde — slots 0 y 1 solamente, cola serializada
            if (slot <= 1) {
                encolarHorde(prompt, seed, slot);
            } else {
                if (aiLoadingSlot === slot) aiLoadingSlot = null;
                console.warn(`🖼 Slot ${slot} omitido (pre-carga lejana), imagen no disponible`);
            }
        }

        async function solicitarImagenParaSlot(slot) {
            if (slot < 0 || aiSlotSolicitado[slot]) return;
            aiSlotSolicitado[slot] = true;
            if (aiLoadingSlot === null) aiLoadingSlot = slot;

            const fragmento = extraerFragmentoParaSlot(slot);
            if (!fragmento) { if (aiLoadingSlot === slot) aiLoadingSlot = null; return; }

            console.log(`🧠 Generando prompt — slot ${slot}`);
            const prompt = await generarPromptConClaude(fragmento);
            const seed = slot * 113 + 7;
            cargarImagenConFallback(prompt, seed, slot);
        }

        function mostrarImagenEnPanel(slot, url) {
            if (!aiImagesEnabled) return;

            const panelAct = aiActivePanel === 'a' ? 'ai-bg-a' : 'ai-bg-b';
            const panelPrev = aiActivePanel === 'a' ? 'ai-bg-b' : 'ai-bg-a';
            const divAct = document.getElementById(panelAct);
            const divPrev = document.getElementById(panelPrev);

            if (slot === aiCurrentSlot) return;

            divAct.style.backgroundImage = `url("${url}")`;
            divAct.style.opacity = '1';
            divPrev.style.opacity = '0';
            document.getElementById('ai-bg-overlay').style.background = 'rgba(8,7,6,0.48)';
            aiActivePanel = aiActivePanel === 'a' ? 'b' : 'a';
            aiCurrentSlot = slot;
            aiSlotActivo = true;
        }

        // Se llama en cada cambio de oración desde main.js
        function actualizarSlideAI(sentenceIdx) {
            if (!aiImagesEnabled) return;

            const slotActual = getSlotForSentence(sentenceIdx);
            solicitarImagenParaSlot(slotActual);

            // Pre-cargar slots siguientes con delay escalonado para no saturar APIs
            // Slot+1: empezar cuando slot actual ya está en cola (800ms)
            // Slot+2: solo si los anteriores ya están procesando (1600ms)
            setTimeout(() => solicitarImagenParaSlot(slotActual + 1), 800);
            setTimeout(() => solicitarImagenParaSlot(slotActual + 2), 1600);
        }

        // ═══════════════════════════════════════
        // CONTROLES DE MODO VIDEO (play/pause + nav capítulos)
        // ═══════════════════════════════════════

        function karaokeTogglePlay() {
            const btn = document.getElementById('kbtn-playpause');
            if (!isReading || isPaused) {
                // Si nunca se inició o está pausado → iniciar/reanudar
                if (!isReading) {
                    iniciarTTS();
                } else {
                    reanudarTTS();
                }
                btn.innerHTML = '&#9646;&#9646;'; // pausa
                btn.classList.remove('paused');
            } else {
                pausarTTS();
                btn.innerHTML = '&#9654;'; // play
                btn.classList.add('paused');
            }
        }

        // Sincronizar el ícono del botón cuando el TTS se detiene/pausa desde afuera
        const _origDetenerTTS = window.detenerTTS;
        window.detenerTTS = function () {
            if (typeof _origDetenerTTS === 'function') _origDetenerTTS();
            const btn = document.getElementById('kbtn-playpause');
            if (btn) { btn.innerHTML = '&#9654;'; btn.classList.remove('paused'); }
        };

        function _getChapterOptions() {
            return Array.from(document.getElementById('chapters').options)
                .filter(o => !o.disabled && o.value);
        }

        function karaokeCapituloAnterior() {
            const sel = document.getElementById('chapters');
            const opts = _getChapterOptions();
            const idx = opts.findIndex(o => o.value === sel.value);
            if (idx > 0) {
                sel.value = opts[idx - 1].value;
                sel.dispatchEvent(new Event('change'));
                // Reiniciar TTS con el nuevo capítulo
                setTimeout(() => { detenerTTS(); iniciarTTS(); }, 300);
            } else {
                mostrarNotificacion('Ya estás en el primer capítulo');
            }
        }

        function karaokeCapituloSiguiente() {
            const sel = document.getElementById('chapters');
            const opts = _getChapterOptions();
            const idx = opts.findIndex(o => o.value === sel.value);
            if (idx < opts.length - 1) {
                sel.value = opts[idx + 1].value;
                sel.dispatchEvent(new Event('change'));
                setTimeout(() => { detenerTTS(); iniciarTTS(); }, 300);
            } else {
                mostrarNotificacion('Ya estás en el último capítulo');
            }
        }

        // ═══════════════════════════════════════
        // CONTROLES DE MÚSICA DESDE MODO VIDEO
        // ═══════════════════════════════════════

        const GENRE_ORDER = ['mystery', 'suspense', 'drama', 'action', 'fantasy', 'romance', 'lofi', 'nature'];

        function _genreIdx() {
            return ambientGenre ? GENRE_ORDER.indexOf(ambientGenre) : -1;
        }

        async function karaokeMusicaSiguiente() {
            const idx = _genreIdx();
            const next = GENRE_ORDER[(idx + 1) % GENRE_ORDER.length];
            await selectGenre(next);
            _actualizarMusicLabel();
        }

        async function karaokeMusicaPrev() {
            const idx = _genreIdx();
            const prev = GENRE_ORDER[(idx - 1 + GENRE_ORDER.length) % GENRE_ORDER.length];
            await selectGenre(prev);
            _actualizarMusicLabel();
        }

        function _actualizarMusicLabel() {
            const lbl = document.getElementById('karaoke-music-label');
            if (!lbl) return;
            const trackName = document.getElementById('ambient-track-name');
            lbl.textContent = trackName ? trackName.textContent : (ambientGenre || '♪');
        }

        // Sincronizar label de música cuando cambia el track
        const _origAmbientTrackName = Object.getOwnPropertyDescriptor(Element.prototype, 'textContent');
        setInterval(_actualizarMusicLabel, 2000); // sync pasivo cada 2s

        // ═══════════════════════════════════════
        // BUSCADOR DE CAPÍTULOS
        // ═══════════════════════════════════════

        // Guardar todas las opciones originales una vez cargado el EPUB
        let _todasLasOpciones = [];

        // Observer para capturar las opciones cuando se populan
        const _chaptersObserver = new MutationObserver(() => {
            const opts = _getChapterOptions();
            if (opts.length > 0) _todasLasOpciones = opts.map(o => ({ value: o.value, text: o.textContent }));
        });
        _chaptersObserver.observe(document.getElementById('chapters'), { childList: true });

        function filtrarCapitulos(query) {
            const sel = document.getElementById('chapters');
            const q = query.trim().toLowerCase();

            // Si no hay snapshot aún, tomarlo ahora
            if (_todasLasOpciones.length === 0) {
                _todasLasOpciones = _getChapterOptions().map(o => ({ value: o.value, text: o.textContent }));
            }

            // Restaurar todas las opciones y luego ocultar las que no coinciden
            // (los <option> no tienen display, así que se re-renderizan)
            const valorActual = sel.value;
            sel.innerHTML = '';

            const filtradas = q
                ? _todasLasOpciones.filter(o => o.text.toLowerCase().includes(q))
                : _todasLasOpciones;

            if (filtradas.length === 0) {
                const empty = document.createElement('option');
                empty.disabled = true;
                empty.textContent = '— sin resultados —';
                sel.appendChild(empty);
                return;
            }

            filtradas.forEach(({ value, text }) => {
                const opt = document.createElement('option');
                opt.value = value;
                opt.textContent = text;
                if (value === valorActual) opt.selected = true;
                sel.appendChild(opt);
            });
        }
    </script>

</body>
</html>